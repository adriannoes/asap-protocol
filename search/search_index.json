{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ASAP Protocol","text":"<p>ASAP (Async Simple Agent Protocol) is a streamlined protocol for agent-to-agent communication, designed to be simpler than existing alternatives while maintaining modern standards functionality.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed Messages: Full Pydantic type safety for all protocol messages</li> <li>Async-First: Built on <code>asyncio</code> for high-performance agent communication</li> <li>State Management: Built-in task state machine with persistence support</li> <li>Transport Agnostic: Clean separation between protocol logic and transport capability (HTTP/JSON-RPC provided)</li> <li>Observability: First-class tracking with correlation IDs and trace IDs</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Using uv (recommended)\nuv add asap-protocol\n\n# Using pip\npip install asap-protocol\n</code></pre> <p>\ud83d\udce6 Available on PyPI</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\nfrom asap.models.envelope import Envelope\nfrom asap.models.payloads import TaskRequest\nfrom asap.transport.client import ASAPClient\n\nasync def main():\n    request = TaskRequest(\n        conversation_id=\"conv_01HX5K3MQVN8\",\n        skill_id=\"echo\",\n        input={\"message\": \"hello from client\"},\n    )\n    envelope = Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:client\",\n        recipient=\"urn:asap:agent:echo-agent\",\n        payload_type=\"task.request\",\n        payload=request.model_dump(),\n    )\n    async with ASAPClient(\"http://127.0.0.1:8001\") as client:\n        response = await client.send(envelope)\n        print(response.payload)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>ASAP provides a CLI for schema management and (v1.2) key/manifest operations:</p> <pre><code># Show version\nasap --version\n\n# Export all JSON schemas\nasap export-schemas --output-dir ./schemas\n\n# List available schemas\nasap list-schemas\n\n# Show a specific schema\nasap show-schema agent\n\n# v1.2: Ed25519 keys and signed manifests\nasap keys generate -o key.pem\nasap manifest sign -k key.pem manifest.json\nasap manifest verify signed.json\nasap manifest info signed.json\n</code></pre> <p>See Identity Signing for full CLI reference.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference</li> <li>Observability</li> <li>Error Handling</li> <li>Testing</li> <li>v1.1 Security Model \u2014 OAuth2 trust limitations, Custom Claims, allowlist (ADR-17)</li> <li>Registry verification review (admin) \u2014 How to vet and approve Verified badge requests for the Lite Registry</li> </ul>"},{"location":"#v11-features-api-reference-guides","title":"v1.1 features (API reference &amp; guides)","text":"Feature Description Where OAuth2 / Custom Claims Server and client auth; identity binding via JWT claims Transport, Security, examples: <code>auth_patterns</code> WebSocket Real-time transport; MessageAck for reliability (ADR-16) Transport, <code>asap.transport.websocket</code>, examples: <code>websocket_concept</code> Webhooks Signed POST callbacks to URLs; SSRF checks, retry, DLQ API Reference (<code>asap.transport</code>), <code>WebhookDelivery</code>, <code>WebhookRetryManager</code> Discovery Well-known manifest, Lite Registry, health endpoint Transport, <code>asap.discovery</code> State Storage SQLite backend, env-based backend selection State Management, Best Practices: Failover, examples: <code>storage_backends</code>, <code>state_migration</code> Health <code>GET /.well-known/asap/health</code> for liveness Transport, <code>asap.discovery.health</code>"},{"location":"api-reference/","title":"API Reference","text":"<p>This reference is generated via mkdocstrings and reflects the public API.</p>"},{"location":"api-reference/#core-models","title":"Core Models","text":""},{"location":"api-reference/#base","title":"Base","text":""},{"location":"api-reference/#asap.models.base","title":"<code>asap.models.base</code>","text":"<p>Base Pydantic model configuration for ASAP protocol models.</p> <p>All ASAP models inherit from ASAPBaseModel to ensure consistent behavior: - Immutability (frozen=True) for thread-safety and predictability - Strict validation (extra=\"forbid\") to catch typos and invalid fields - Flexible field naming (populate_by_name=True) for alias support - JSON Schema generation with proper metadata</p>"},{"location":"api-reference/#asap.models.base.ASAPBaseModel","title":"<code>ASAPBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all ASAP protocol entities.</p> <p>This base class provides: - Immutability: Models are frozen after creation (thread-safe) - Strict validation: Extra fields are forbidden (catches errors early) - Flexible naming: Fields can be populated by name or alias - JSON Schema: Proper schema generation for interoperability</p> Example <p>from pydantic import Field class MyModel(ASAPBaseModel): ...     name: str ...     count: int = Field(default=0, ge=0)</p> <p>obj = MyModel(name=\"test\", count=5) obj.name 'test' obj.count = 10  # Raises ValidationError (frozen) Traceback (most recent call last): ... pydantic_core._pydantic_core.ValidationError: ...</p> Source code in <code>src/asap/models/base.py</code> <pre><code>class ASAPBaseModel(BaseModel):\n    \"\"\"Base model for all ASAP protocol entities.\n\n    This base class provides:\n    - **Immutability**: Models are frozen after creation (thread-safe)\n    - **Strict validation**: Extra fields are forbidden (catches errors early)\n    - **Flexible naming**: Fields can be populated by name or alias\n    - **JSON Schema**: Proper schema generation for interoperability\n\n    Example:\n        &gt;&gt;&gt; from pydantic import Field\n        &gt;&gt;&gt; class MyModel(ASAPBaseModel):\n        ...     name: str\n        ...     count: int = Field(default=0, ge=0)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; obj = MyModel(name=\"test\", count=5)\n        &gt;&gt;&gt; obj.name\n        'test'\n        &gt;&gt;&gt; obj.count = 10  # Raises ValidationError (frozen)\n        Traceback (most recent call last):\n        ...\n        pydantic_core._pydantic_core.ValidationError: ...\n    \"\"\"\n\n    model_config = ConfigDict(\n        # Immutability: prevents accidental mutations after creation\n        frozen=True,\n        # Strict validation: reject unknown fields to catch typos\n        extra=\"forbid\",\n        # Allow populating fields by both name and alias\n        populate_by_name=True,\n        # JSON Schema configuration\n        use_enum_values=False,\n        validate_default=True,\n        validate_assignment=True,\n        # JSON Schema extras for better documentation\n        json_schema_extra={\n            \"additionalProperties\": False,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#ids","title":"IDs","text":""},{"location":"api-reference/#asap.models.ids","title":"<code>asap.models.ids</code>","text":"<p>ULID-based ID generation for ASAP protocol entities.</p> <p>ULIDs (Universally Unique Lexicographically Sortable Identifiers) provide: - 128-bit compatibility with UUID - Lexicographic sorting by creation time when timestamps differ (millisecond precision) - Canonically encoded as 26-character string (Crockford's Base32)</p> <p>Note: Order is guaranteed only across different milliseconds. Two ULIDs generated within the same millisecond share the same timestamp prefix; their lexicographic order is then determined by the random component and may not match generation order.</p>"},{"location":"api-reference/#asap.models.ids.extract_timestamp","title":"<code>extract_timestamp(ulid)</code>","text":"<p>Extract the timestamp from a ULID string.</p> <p>Parameters:</p> Name Type Description Default <code>ulid</code> <code>str</code> <p>A 26-character ULID string</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>A timezone-aware datetime in UTC representing when the ULID was created</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ULID string is invalid</p> Example <p>ulid = generate_id() timestamp = extract_timestamp(ulid) timestamp.tzinfo == timezone.utc True</p> Source code in <code>src/asap/models/ids.py</code> <pre><code>def extract_timestamp(ulid: str) -&gt; datetime:\n    \"\"\"Extract the timestamp from a ULID string.\n\n    Args:\n        ulid: A 26-character ULID string\n\n    Returns:\n        A timezone-aware datetime in UTC representing when the ULID was created\n\n    Raises:\n        ValueError: If the ULID string is invalid\n\n    Example:\n        &gt;&gt;&gt; ulid = generate_id()\n        &gt;&gt;&gt; timestamp = extract_timestamp(ulid)\n        &gt;&gt;&gt; timestamp.tzinfo == timezone.utc\n        True\n    \"\"\"\n    ulid_obj = ULID.from_str(ulid)\n    # ULID.datetime returns a timezone-aware datetime in UTC\n    return ulid_obj.datetime\n</code></pre>"},{"location":"api-reference/#asap.models.ids.generate_id","title":"<code>generate_id()</code>","text":"<p>Generate a new ULID string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A 26-character ULID string that is:</p> <code>str</code> <ul> <li>Globally unique</li> </ul> <code>str</code> <ul> <li>Lexicographically sortable by creation time when generated in different milliseconds (within the same millisecond, order is not guaranteed)</li> </ul> <code>str</code> <ul> <li>URL-safe (uses Crockford's Base32 alphabet)</li> </ul> Example <p>id1 = generate_id() len(id1) 26 id2 = generate_id() id1 &lt; id2  # True when timestamps differ (e.g. different ms) True</p> Source code in <code>src/asap/models/ids.py</code> <pre><code>def generate_id() -&gt; str:\n    \"\"\"Generate a new ULID string.\n\n    Returns:\n        A 26-character ULID string that is:\n        - Globally unique\n        - Lexicographically sortable by creation time when generated in different\n          milliseconds (within the same millisecond, order is not guaranteed)\n        - URL-safe (uses Crockford's Base32 alphabet)\n\n    Example:\n        &gt;&gt;&gt; id1 = generate_id()\n        &gt;&gt;&gt; len(id1)\n        26\n        &gt;&gt;&gt; id2 = generate_id()\n        &gt;&gt;&gt; id1 &lt; id2  # True when timestamps differ (e.g. different ms)\n        True\n    \"\"\"\n    return str(ULID())\n</code></pre>"},{"location":"api-reference/#enums","title":"Enums","text":""},{"location":"api-reference/#asap.models.enums","title":"<code>asap.models.enums</code>","text":"<p>Enumerations for ASAP protocol.</p> <p>This module defines all enum types used in the protocol to ensure type safety and prevent magic strings.</p>"},{"location":"api-reference/#asap.models.enums.MessageRole","title":"<code>MessageRole</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Message sender roles.</p> <p>Defines the role of the entity sending a message in a conversation.</p> Example <p>MessageRole.USER.value 'user'</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>class MessageRole(str, Enum):\n    \"\"\"Message sender roles.\n\n    Defines the role of the entity sending a message in a conversation.\n\n    Example:\n        &gt;&gt;&gt; MessageRole.USER.value\n        'user'\n    \"\"\"\n\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n    SYSTEM = \"system\"\n</code></pre>"},{"location":"api-reference/#asap.models.enums.TaskStatus","title":"<code>TaskStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Task lifecycle states.</p> <p>Tasks progress through these states during their lifecycle. Terminal states are: COMPLETED, FAILED, CANCELLED.</p> Example <p>TaskStatus.COMPLETED.is_terminal() True TaskStatus.WORKING.is_terminal() False</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>class TaskStatus(str, Enum):\n    \"\"\"Task lifecycle states.\n\n    Tasks progress through these states during their lifecycle.\n    Terminal states are: COMPLETED, FAILED, CANCELLED.\n\n    Example:\n        &gt;&gt;&gt; TaskStatus.COMPLETED.is_terminal()\n        True\n        &gt;&gt;&gt; TaskStatus.WORKING.is_terminal()\n        False\n    \"\"\"\n\n    SUBMITTED = \"submitted\"\n    WORKING = \"working\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    INPUT_REQUIRED = \"input_required\"\n\n    @classmethod\n    def terminal_states(cls) -&gt; frozenset[\"TaskStatus\"]:\n        \"\"\"Return all terminal states.\n\n        Returns:\n            Frozen set containing all terminal task states\n        \"\"\"\n        return frozenset({cls.COMPLETED, cls.FAILED, cls.CANCELLED})\n\n    def is_terminal(self) -&gt; bool:\n        \"\"\"Check if this status represents a terminal state.\"\"\"\n        return self in self.terminal_states()\n</code></pre>"},{"location":"api-reference/#asap.models.enums.TaskStatus.is_terminal","title":"<code>is_terminal()</code>","text":"<p>Check if this status represents a terminal state.</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>def is_terminal(self) -&gt; bool:\n    \"\"\"Check if this status represents a terminal state.\"\"\"\n    return self in self.terminal_states()\n</code></pre>"},{"location":"api-reference/#asap.models.enums.TaskStatus.terminal_states","title":"<code>terminal_states()</code>  <code>classmethod</code>","text":"<p>Return all terminal states.</p> <p>Returns:</p> Type Description <code>frozenset[TaskStatus]</code> <p>Frozen set containing all terminal task states</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>@classmethod\ndef terminal_states(cls) -&gt; frozenset[\"TaskStatus\"]:\n    \"\"\"Return all terminal states.\n\n    Returns:\n        Frozen set containing all terminal task states\n    \"\"\"\n    return frozenset({cls.COMPLETED, cls.FAILED, cls.CANCELLED})\n</code></pre>"},{"location":"api-reference/#asap.models.enums.UpdateType","title":"<code>UpdateType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Task update types.</p> <p>Defines the type of update being sent for a task.</p> Example <p>UpdateType.PROGRESS.value 'progress'</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>class UpdateType(str, Enum):\n    \"\"\"Task update types.\n\n    Defines the type of update being sent for a task.\n\n    Example:\n        &gt;&gt;&gt; UpdateType.PROGRESS.value\n        'progress'\n    \"\"\"\n\n    PROGRESS = \"progress\"\n    INPUT_REQUIRED = \"input_required\"\n    STATUS_CHANGE = \"status_change\"\n</code></pre>"},{"location":"api-reference/#asap.models.enums.VerificationState","title":"<code>VerificationState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Verification status for marketplace trust badge (Task 3.6).</p> <p>When status is VERIFIED, the agent displays a Verified badge in the registry UI.</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>class VerificationState(str, Enum):\n    \"\"\"Verification status for marketplace trust badge (Task 3.6).\n\n    When status is VERIFIED, the agent displays a Verified badge in the registry UI.\n    \"\"\"\n\n    VERIFIED = \"verified\"\n    PENDING = \"pending\"\n    REJECTED = \"rejected\"\n</code></pre>"},{"location":"api-reference/#types","title":"Types","text":""},{"location":"api-reference/#asap.models.types","title":"<code>asap.models.types</code>","text":"<p>Type aliases for ASAP protocol.</p> <p>This module defines type aliases to improve code readability and document the semantic meaning of string types.</p>"},{"location":"api-reference/#asap.models.types.AgentURN","title":"<code>AgentURN = str</code>  <code>module-attribute</code>","text":"<p>Agent identifier in URN format: urn:asap:agent:{name}</p>"},{"location":"api-reference/#asap.models.types.ArtifactID","title":"<code>ArtifactID = str</code>  <code>module-attribute</code>","text":"<p>Unique artifact identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.ConversationID","title":"<code>ConversationID = str</code>  <code>module-attribute</code>","text":"<p>Unique conversation identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.MIMEType","title":"<code>MIMEType = str</code>  <code>module-attribute</code>","text":"<p>MIME type string (e.g., 'application/json')</p>"},{"location":"api-reference/#asap.models.types.MessageID","title":"<code>MessageID = str</code>  <code>module-attribute</code>","text":"<p>Unique message identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.PartID","title":"<code>PartID = str</code>  <code>module-attribute</code>","text":"<p>Unique part identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.SemanticVersion","title":"<code>SemanticVersion = str</code>  <code>module-attribute</code>","text":"<p>Semantic version string (e.g., '1.0.0')</p>"},{"location":"api-reference/#asap.models.types.SnapshotID","title":"<code>SnapshotID = str</code>  <code>module-attribute</code>","text":"<p>Unique state snapshot identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.TaskID","title":"<code>TaskID = str</code>  <code>module-attribute</code>","text":"<p>Unique task identifier (ULID format)</p>"},{"location":"api-reference/#asap.models.types.URI","title":"<code>URI = str</code>  <code>module-attribute</code>","text":"<p>Uniform Resource Identifier</p>"},{"location":"api-reference/#entities","title":"Entities","text":""},{"location":"api-reference/#asap.models.entities","title":"<code>asap.models.entities</code>","text":"<p>Core entity models for the ASAP protocol.</p> <p>This module defines the fundamental entities used in agent-to-agent communication: - Agent: An autonomous entity capable of sending/receiving ASAP messages - Manifest: Self-describing metadata about an agent's capabilities - Conversation: Context for related interactions between agents - Task: Fundamental unit of work with lifecycle management - Message: Single communication turn containing parts - Artifact: Concrete output produced by task execution - StateSnapshot: First-class state persistence mechanism - Skill: A specific capability that an agent can perform - Capability: Collection of an agent's features and supported operations - Endpoint: Network endpoints for agent communication - AuthScheme: Authentication configuration for agent access - SLADefinition: Service level agreement guarantees (availability, latency, error rate)</p>"},{"location":"api-reference/#asap.models.entities.Agent","title":"<code>Agent</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>An autonomous entity capable of sending and receiving ASAP messages.</p> <p>Agents are symmetric peers with no inherent client/server distinction. Each agent has a unique identifier and publishes a manifest describing its capabilities.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>AgentURN</code> <p>Unique agent identifier (URN format, e.g., \"urn:asap:agent:research-v1\")</p> <code>manifest_uri</code> <code>str</code> <p>URL where the agent's manifest can be retrieved</p> <code>capabilities</code> <code>list[str]</code> <p>List of capability strings (e.g., [\"task.execute\", \"mcp.tools\"])</p> Example <p>agent = Agent( ...     id=\"urn:asap:agent:research-v1\", ...     manifest_uri=\"https://agents.example.com/.well-known/asap/research-v1.json\", ...     capabilities=[\"task.execute\", \"state.persist\", \"mcp.tools\"] ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Agent(ASAPBaseModel):\n    \"\"\"An autonomous entity capable of sending and receiving ASAP messages.\n\n    Agents are symmetric peers with no inherent client/server distinction.\n    Each agent has a unique identifier and publishes a manifest describing\n    its capabilities.\n\n    Attributes:\n        id: Unique agent identifier (URN format, e.g., \"urn:asap:agent:research-v1\")\n        manifest_uri: URL where the agent's manifest can be retrieved\n        capabilities: List of capability strings (e.g., [\"task.execute\", \"mcp.tools\"])\n\n    Example:\n        &gt;&gt;&gt; agent = Agent(\n        ...     id=\"urn:asap:agent:research-v1\",\n        ...     manifest_uri=\"https://agents.example.com/.well-known/asap/research-v1.json\",\n        ...     capabilities=[\"task.execute\", \"state.persist\", \"mcp.tools\"]\n        ... )\n    \"\"\"\n\n    id: AgentURN = Field(..., description=\"Unique agent identifier (URN format)\")\n    manifest_uri: str = Field(..., description=\"URL to agent's manifest\")\n    capabilities: list[str] = Field(..., min_length=1, description=\"Agent capability strings\")\n\n    @field_validator(\"id\")\n    @classmethod\n    def validate_urn_format(cls, v: str) -&gt; str:\n        return validate_agent_urn(v)\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Artifact","title":"<code>Artifact</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Concrete output produced by task execution.</p> <p>Artifacts represent the tangible results of task completion, such as reports, data files, or other generated content.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>ArtifactID</code> <p>Unique artifact identifier (ULID format)</p> <code>task_id</code> <code>TaskID</code> <p>ID of the task that produced this artifact</p> <code>name</code> <code>str</code> <p>Human-readable artifact name</p> <code>parts</code> <code>list[PartID]</code> <p>List of part IDs that make up this artifact</p> <code>created_at</code> <code>datetime</code> <p>When the artifact was created (UTC)</p> Example <p>from datetime import datetime, timezone artifact = Artifact( ...     id=\"art_01HX5K6Q...\", ...     task_id=\"task_01HX5K4N...\", ...     name=\"Q3 Market Analysis Report\", ...     parts=[\"part_01HX5K...\"], ...     created_at=datetime.now(timezone.utc) ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Artifact(ASAPBaseModel):\n    \"\"\"Concrete output produced by task execution.\n\n    Artifacts represent the tangible results of task completion,\n    such as reports, data files, or other generated content.\n\n    Attributes:\n        id: Unique artifact identifier (ULID format)\n        task_id: ID of the task that produced this artifact\n        name: Human-readable artifact name\n        parts: List of part IDs that make up this artifact\n        created_at: When the artifact was created (UTC)\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; artifact = Artifact(\n        ...     id=\"art_01HX5K6Q...\",\n        ...     task_id=\"task_01HX5K4N...\",\n        ...     name=\"Q3 Market Analysis Report\",\n        ...     parts=[\"part_01HX5K...\"],\n        ...     created_at=datetime.now(timezone.utc)\n        ... )\n    \"\"\"\n\n    id: ArtifactID = Field(..., description=\"Unique artifact identifier (ULID)\")\n    task_id: TaskID = Field(..., description=\"Parent task ID\")\n    name: str = Field(..., description=\"Human-readable artifact name\")\n    parts: list[PartID] = Field(..., description=\"Part IDs making up this artifact\")\n    created_at: datetime = Field(..., description=\"Creation timestamp (UTC)\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.AuthScheme","title":"<code>AuthScheme</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Authentication configuration for agent access.</p> <p>Defines the authentication methods supported by an agent and optional OAuth2 configuration.</p> <p>Attributes:</p> Name Type Description <code>schemes</code> <code>list[str]</code> <p>List of supported auth schemes (e.g., [\"bearer\", \"oauth2\"])</p> <code>oauth2</code> <code>dict[str, Any] | None</code> <p>Optional OAuth2 configuration with URLs and scopes</p> Example <p>auth = AuthScheme( ...     schemes=[\"bearer\", \"oauth2\"], ...     oauth2={ ...         \"authorization_url\": \"https://auth.example.com/authorize\", ...         \"token_url\": \"https://auth.example.com/token\", ...         \"scopes\": [\"asap:execute\", \"asap:read\"] ...     } ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class AuthScheme(ASAPBaseModel):\n    \"\"\"Authentication configuration for agent access.\n\n    Defines the authentication methods supported by an agent and\n    optional OAuth2 configuration.\n\n    Attributes:\n        schemes: List of supported auth schemes (e.g., [\"bearer\", \"oauth2\"])\n        oauth2: Optional OAuth2 configuration with URLs and scopes\n\n    Example:\n        &gt;&gt;&gt; auth = AuthScheme(\n        ...     schemes=[\"bearer\", \"oauth2\"],\n        ...     oauth2={\n        ...         \"authorization_url\": \"https://auth.example.com/authorize\",\n        ...         \"token_url\": \"https://auth.example.com/token\",\n        ...         \"scopes\": [\"asap:execute\", \"asap:read\"]\n        ...     }\n        ... )\n    \"\"\"\n\n    schemes: list[str] = Field(..., description=\"Supported authentication schemes\")\n    oauth2: dict[str, Any] | None = Field(\n        default=None, description=\"OAuth2 configuration if oauth2 is in schemes\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Capability","title":"<code>Capability</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Collection of an agent's features and supported operations.</p> <p>Capabilities describe what an agent can do, including skills, state persistence, streaming support, and MCP tool integration.</p> <p>Attributes:</p> Name Type Description <code>asap_version</code> <code>str</code> <p>ASAP protocol version supported (e.g., \"0.1\")</p> <code>skills</code> <code>list[Skill]</code> <p>List of skills the agent can perform</p> <code>state_persistence</code> <code>bool</code> <p>Whether the agent supports state snapshots</p> <code>streaming</code> <code>bool</code> <p>Whether the agent supports streaming responses</p> <code>mcp_tools</code> <code>list[str]</code> <p>List of MCP tool names the agent can execute</p> Example <p>capability = Capability( ...     asap_version=\"0.1\", ...     skills=[Skill(id=\"research\", description=\"Research skill\")], ...     state_persistence=True, ...     streaming=True, ...     mcp_tools=[\"web_search\"] ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Capability(ASAPBaseModel):\n    \"\"\"Collection of an agent's features and supported operations.\n\n    Capabilities describe what an agent can do, including skills,\n    state persistence, streaming support, and MCP tool integration.\n\n    Attributes:\n        asap_version: ASAP protocol version supported (e.g., \"0.1\")\n        skills: List of skills the agent can perform\n        state_persistence: Whether the agent supports state snapshots\n        streaming: Whether the agent supports streaming responses\n        mcp_tools: List of MCP tool names the agent can execute\n\n    Example:\n        &gt;&gt;&gt; capability = Capability(\n        ...     asap_version=\"0.1\",\n        ...     skills=[Skill(id=\"research\", description=\"Research skill\")],\n        ...     state_persistence=True,\n        ...     streaming=True,\n        ...     mcp_tools=[\"web_search\"]\n        ... )\n    \"\"\"\n\n    asap_version: str = Field(default=ASAP_PROTOCOL_VERSION, description=\"ASAP protocol version\")\n    skills: list[Skill] = Field(default_factory=list, description=\"Available skills\")\n    state_persistence: bool = Field(default=False, description=\"Supports state snapshots\")\n    streaming: bool = Field(default=False, description=\"Supports streaming responses\")\n    mcp_tools: list[str] = Field(default_factory=list, description=\"Available MCP tools\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.CommonMetadata","title":"<code>CommonMetadata</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Common metadata keys (extra allowed).</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class CommonMetadata(ASAPBaseModel):\n    \"\"\"Common metadata keys (extra allowed).\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    purpose: str | None = Field(default=None, description=\"Conversation purpose\")\n    ttl_hours: int | None = Field(default=None, ge=1, description=\"Time-to-live in hours\")\n    source: str | None = Field(default=None, description=\"Source identifier\")\n    timestamp: str | None = Field(default=None, description=\"ISO timestamp\")\n    tags: list[str] | None = Field(default=None, description=\"Tags for categorization\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Conversation","title":"<code>Conversation</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>A context for related interactions between agents.</p> <p>Conversations enable shared context accumulation, task grouping, and state isolation between unrelated work.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>ConversationID</code> <p>Unique conversation identifier (ULID format)</p> <code>participants</code> <code>list[AgentURN]</code> <p>List of agent URNs participating in the conversation</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when the conversation was created (UTC)</p> <code>metadata</code> <code>CommonMetadata | None</code> <p>Optional metadata (e.g., purpose, TTL, tags)</p> Example <p>from datetime import datetime, timezone conversation = Conversation( ...     id=\"conv_01HX5K3MQVN8...\", ...     participants=[\"urn:asap:agent:coordinator\", \"urn:asap:agent:research-v1\"], ...     created_at=datetime.now(timezone.utc), ...     metadata={\"purpose\": \"quarterly_report_research\", \"ttl_hours\": 72} ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Conversation(ASAPBaseModel):\n    \"\"\"A context for related interactions between agents.\n\n    Conversations enable shared context accumulation, task grouping,\n    and state isolation between unrelated work.\n\n    Attributes:\n        id: Unique conversation identifier (ULID format)\n        participants: List of agent URNs participating in the conversation\n        created_at: Timestamp when the conversation was created (UTC)\n        metadata: Optional metadata (e.g., purpose, TTL, tags)\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; conversation = Conversation(\n        ...     id=\"conv_01HX5K3MQVN8...\",\n        ...     participants=[\"urn:asap:agent:coordinator\", \"urn:asap:agent:research-v1\"],\n        ...     created_at=datetime.now(timezone.utc),\n        ...     metadata={\"purpose\": \"quarterly_report_research\", \"ttl_hours\": 72}\n        ... )\n    \"\"\"\n\n    id: ConversationID = Field(..., description=\"Unique conversation identifier (ULID)\")\n    participants: list[AgentURN] = Field(\n        ..., min_length=1, description=\"Agent URNs in conversation\"\n    )\n    created_at: datetime = Field(..., description=\"Creation timestamp (UTC)\")\n    metadata: CommonMetadata | None = Field(\n        default=None, description=\"Optional metadata (purpose, TTL, etc.)\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Endpoint","title":"<code>Endpoint</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Network endpoints for agent communication.</p> <p>Defines the URLs where an agent can be reached for different types of communication.</p> <p>Attributes:</p> Name Type Description <code>asap</code> <code>str</code> <p>HTTP endpoint for ASAP protocol messages (required)</p> <code>events</code> <code>str | None</code> <p>Optional WebSocket endpoint for streaming events</p> Example <p>endpoint = Endpoint( ...     asap=\"https://api.example.com/asap\", ...     events=\"wss://api.example.com/asap/events\" ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Endpoint(ASAPBaseModel):\n    \"\"\"Network endpoints for agent communication.\n\n    Defines the URLs where an agent can be reached for different\n    types of communication.\n\n    Attributes:\n        asap: HTTP endpoint for ASAP protocol messages (required)\n        events: Optional WebSocket endpoint for streaming events\n\n    Example:\n        &gt;&gt;&gt; endpoint = Endpoint(\n        ...     asap=\"https://api.example.com/asap\",\n        ...     events=\"wss://api.example.com/asap/events\"\n        ... )\n    \"\"\"\n\n    asap: str = Field(..., description=\"HTTP endpoint for ASAP messages\")\n    events: str | None = Field(default=None, description=\"WebSocket endpoint for streaming events\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Manifest","title":"<code>Manifest</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Self-describing metadata about an agent's capabilities.</p> <p>The manifest is analogous to A2A's Agent Card but extended with additional ASAP-specific features. It provides all information needed to interact with an agent.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>AgentURN</code> <p>Unique agent identifier (matches Agent.id)</p> <code>name</code> <code>str</code> <p>Human-readable agent name</p> <code>version</code> <code>SemanticVersion</code> <p>Semantic version of the agent</p> <code>description</code> <code>str</code> <p>Description of what the agent does</p> <code>capabilities</code> <code>Capability</code> <p>Detailed capability information</p> <code>endpoints</code> <code>Endpoint</code> <p>Network endpoints for communication</p> <code>auth</code> <code>AuthScheme | None</code> <p>Optional authentication configuration</p> <code>signature</code> <code>str | None</code> <p>Optional cryptographic signature for manifest verification</p> <code>sla</code> <code>SLADefinition | None</code> <p>Optional SLA guarantees (availability, latency, error rate)</p> <code>ttl_seconds</code> <code>int</code> <p>How long to consider agent alive without re-check (default 300)</p> Example <p>manifest = Manifest( ...     id=\"urn:asap:agent:research-v1\", ...     name=\"Research Agent\", ...     version=\"1.0.0\", ...     description=\"Performs web research and summarization\", ...     capabilities=Capability( ...         asap_version=\"0.1\", ...         skills=[Skill(id=\"web_research\", description=\"Research skill\")], ...         state_persistence=True ...     ), ...     endpoints=Endpoint(asap=\"https://api.example.com/asap\") ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Manifest(ASAPBaseModel):\n    \"\"\"Self-describing metadata about an agent's capabilities.\n\n    The manifest is analogous to A2A's Agent Card but extended with\n    additional ASAP-specific features. It provides all information\n    needed to interact with an agent.\n\n    Attributes:\n        id: Unique agent identifier (matches Agent.id)\n        name: Human-readable agent name\n        version: Semantic version of the agent\n        description: Description of what the agent does\n        capabilities: Detailed capability information\n        endpoints: Network endpoints for communication\n        auth: Optional authentication configuration\n        signature: Optional cryptographic signature for manifest verification\n        sla: Optional SLA guarantees (availability, latency, error rate)\n        ttl_seconds: How long to consider agent alive without re-check (default 300)\n\n    Example:\n        &gt;&gt;&gt; manifest = Manifest(\n        ...     id=\"urn:asap:agent:research-v1\",\n        ...     name=\"Research Agent\",\n        ...     version=\"1.0.0\",\n        ...     description=\"Performs web research and summarization\",\n        ...     capabilities=Capability(\n        ...         asap_version=\"0.1\",\n        ...         skills=[Skill(id=\"web_research\", description=\"Research skill\")],\n        ...         state_persistence=True\n        ...     ),\n        ...     endpoints=Endpoint(asap=\"https://api.example.com/asap\")\n        ... )\n        &gt;&gt;&gt; # With SLA (optional):\n        &gt;&gt;&gt; manifest_with_sla = Manifest(\n        ...     id=\"urn:asap:agent:research-v1\",\n        ...     name=\"Research Agent\",\n        ...     version=\"1.0.0\",\n        ...     description=\"Performs web research\",\n        ...     capabilities=Capability(\n        ...         asap_version=\"0.1\",\n        ...         skills=[Skill(id=\"web_research\", description=\"Research skill\")],\n        ...         state_persistence=True,\n        ...     ),\n        ...     endpoints=Endpoint(asap=\"https://api.example.com/asap\"),\n        ...     sla=SLADefinition(\n        ...         availability=\"99.5%\",\n        ...         max_latency_p95_ms=500,\n        ...         max_error_rate=\"1%\",\n        ...         support_hours=\"24/7\",\n        ...     ),\n        ... )\n    \"\"\"\n\n    id: AgentURN = Field(..., description=\"Unique agent identifier (URN format)\")\n    name: str = Field(..., description=\"Human-readable agent name\")\n    version: SemanticVersion = Field(..., description=\"Semantic version (e.g., '1.0.0')\")\n    description: str = Field(..., description=\"What the agent does\")\n    capabilities: Capability = Field(..., description=\"Agent capabilities\")\n    endpoints: Endpoint = Field(..., description=\"Communication endpoints\")\n    auth: AuthScheme | None = Field(default=None, description=\"Authentication configuration\")\n    signature: str | None = Field(\n        default=None, description=\"Cryptographic signature for verification\"\n    )\n    sla: SLADefinition | None = Field(\n        default=None, description=\"SLA guarantees (availability, latency, error rate)\"\n    )\n    verification: VerificationStatus | None = Field(\n        default=None,\n        description=\"Verification status for marketplace trust badge (Task 3.6)\",\n    )\n    ttl_seconds: int = Field(\n        default=DEFAULT_MANIFEST_TTL_SECONDS,\n        ge=1,\n        description=\"How long to consider agent alive without re-check (seconds)\",\n    )\n\n    @field_validator(\"id\")\n    @classmethod\n    def validate_urn_format(cls, v: str) -&gt; str:\n        return validate_agent_urn(v)\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_semver(cls, v: str) -&gt; str:\n        try:\n            Version(v)\n        except InvalidVersion as e:\n            raise ValueError(f\"Invalid semantic version '{v}': {e}\") from e\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_auth_schemes(self) -&gt; \"Manifest\":\n        if self.auth is not None:\n            _validate_auth_scheme(self.auth)\n        return self\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Manifest--with-sla-optional","title":"With SLA (optional):","text":"<p>manifest_with_sla = Manifest( ...     id=\"urn:asap:agent:research-v1\", ...     name=\"Research Agent\", ...     version=\"1.0.0\", ...     description=\"Performs web research\", ...     capabilities=Capability( ...         asap_version=\"0.1\", ...         skills=[Skill(id=\"web_research\", description=\"Research skill\")], ...         state_persistence=True, ...     ), ...     endpoints=Endpoint(asap=\"https://api.example.com/asap\"), ...     sla=SLADefinition( ...         availability=\"99.5%\", ...         max_latency_p95_ms=500, ...         max_error_rate=\"1%\", ...         support_hours=\"24/7\", ...     ), ... )</p>"},{"location":"api-reference/#asap.models.entities.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>A single communication turn containing one or more parts.</p> <p>Messages are the atomic units of communication within tasks, containing content parts and metadata about the sender and role.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>MessageID</code> <p>Unique message identifier (ULID format)</p> <code>task_id</code> <code>TaskID</code> <p>ID of the task this message belongs to</p> <code>sender</code> <code>AgentURN</code> <p>Agent URN of the message sender</p> <code>role</code> <code>MessageRole</code> <p>Message role (user, assistant, system)</p> <code>parts</code> <code>list[PartID]</code> <p>List of part IDs or part references</p> <code>timestamp</code> <code>datetime</code> <p>When the message was sent (UTC)</p> Example <p>from datetime import datetime, timezone message = Message( ...     id=\"msg_01HX5K5P...\", ...     task_id=\"task_01HX5K4N...\", ...     sender=\"urn:asap:agent:coordinator\", ...     role=\"user\", ...     parts=[\"part_01HX5K...\", \"part_01HX5L...\"], ...     timestamp=datetime.now(timezone.utc) ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Message(ASAPBaseModel):\n    \"\"\"A single communication turn containing one or more parts.\n\n    Messages are the atomic units of communication within tasks,\n    containing content parts and metadata about the sender and role.\n\n    Attributes:\n        id: Unique message identifier (ULID format)\n        task_id: ID of the task this message belongs to\n        sender: Agent URN of the message sender\n        role: Message role (user, assistant, system)\n        parts: List of part IDs or part references\n        timestamp: When the message was sent (UTC)\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; message = Message(\n        ...     id=\"msg_01HX5K5P...\",\n        ...     task_id=\"task_01HX5K4N...\",\n        ...     sender=\"urn:asap:agent:coordinator\",\n        ...     role=\"user\",\n        ...     parts=[\"part_01HX5K...\", \"part_01HX5L...\"],\n        ...     timestamp=datetime.now(timezone.utc)\n        ... )\n    \"\"\"\n\n    id: MessageID = Field(..., description=\"Unique message identifier (ULID)\")\n    task_id: TaskID = Field(..., description=\"Parent task ID\")\n    sender: AgentURN = Field(..., description=\"Sender agent URN\")\n    role: MessageRole = Field(..., description=\"Message role (user, assistant, system)\")\n    parts: list[PartID] = Field(..., description=\"Part IDs or references\")\n    timestamp: datetime = Field(..., description=\"Message timestamp (UTC)\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.SLADefinition","title":"<code>SLADefinition</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Service level agreement guarantees published by an agent.</p> <p>SLAs define availability, latency, error rate, and support hours. Used as trust signals in the marketplace (v2.0) and for breach detection.</p> <p>Attributes:</p> Name Type Description <code>availability</code> <code>str | None</code> <p>Target uptime as percentage string (e.g., \"99.5%\").</p> <code>max_latency_p95_ms</code> <code>int | None</code> <p>Maximum 95th percentile latency in milliseconds.</p> <code>max_error_rate</code> <code>str | None</code> <p>Maximum acceptable error rate as percentage string (e.g., \"1%\").</p> <code>support_hours</code> <code>str | None</code> <p>Support coverage (e.g., \"24/7\", \"business\").</p> Example <p>sla = SLADefinition( ...     availability=\"99.5%\", ...     max_latency_p95_ms=500, ...     max_error_rate=\"1%\", ...     support_hours=\"24/7\" ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class SLADefinition(ASAPBaseModel):\n    \"\"\"Service level agreement guarantees published by an agent.\n\n    SLAs define availability, latency, error rate, and support hours.\n    Used as trust signals in the marketplace (v2.0) and for breach detection.\n\n    Attributes:\n        availability: Target uptime as percentage string (e.g., \"99.5%\").\n        max_latency_p95_ms: Maximum 95th percentile latency in milliseconds.\n        max_error_rate: Maximum acceptable error rate as percentage string (e.g., \"1%\").\n        support_hours: Support coverage (e.g., \"24/7\", \"business\").\n\n    Example:\n        &gt;&gt;&gt; sla = SLADefinition(\n        ...     availability=\"99.5%\",\n        ...     max_latency_p95_ms=500,\n        ...     max_error_rate=\"1%\",\n        ...     support_hours=\"24/7\"\n        ... )\n    \"\"\"\n\n    availability: str | None = Field(\n        default=None, description=\"Target uptime as percentage (e.g., '99.5%')\"\n    )\n    max_latency_p95_ms: int | None = Field(\n        default=None, ge=0, description=\"Maximum p95 latency in milliseconds\"\n    )\n    max_error_rate: str | None = Field(\n        default=None, description=\"Maximum error rate as percentage (e.g., '1%')\"\n    )\n    support_hours: str | None = Field(\n        default=None, description=\"Support coverage (e.g., '24/7', 'business')\"\n    )\n\n    @field_validator(\"availability\", \"max_error_rate\", mode=\"before\")\n    @classmethod\n    def _validate_percentage_format(cls, v: str | None) -&gt; str | None:\n        if v is not None:\n            from asap.models.validators import validate_percentage_format\n\n            validate_percentage_format(v)\n        return v\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Skill","title":"<code>Skill</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>A specific capability that an agent can perform.</p> <p>Skills define what an agent can do, along with the expected input and output schemas for validation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the skill (e.g., \"web_research\")</p> <code>description</code> <code>str</code> <p>Human-readable description of what the skill does</p> <code>input_schema</code> <code>dict[str, Any] | None</code> <p>Optional JSON Schema for validating skill inputs</p> <code>output_schema</code> <code>dict[str, Any] | None</code> <p>Optional JSON Schema for validating skill outputs</p> Example <p>skill = Skill( ...     id=\"web_research\", ...     description=\"Search and synthesize information from the web\", ...     input_schema={\"type\": \"object\", \"properties\": {\"query\": {\"type\": \"string\"}}}, ...     output_schema={\"type\": \"object\", \"properties\": {\"summary\": {\"type\": \"string\"}}} ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Skill(ASAPBaseModel):\n    \"\"\"A specific capability that an agent can perform.\n\n    Skills define what an agent can do, along with the expected input\n    and output schemas for validation.\n\n    Attributes:\n        id: Unique identifier for the skill (e.g., \"web_research\")\n        description: Human-readable description of what the skill does\n        input_schema: Optional JSON Schema for validating skill inputs\n        output_schema: Optional JSON Schema for validating skill outputs\n\n    Example:\n        &gt;&gt;&gt; skill = Skill(\n        ...     id=\"web_research\",\n        ...     description=\"Search and synthesize information from the web\",\n        ...     input_schema={\"type\": \"object\", \"properties\": {\"query\": {\"type\": \"string\"}}},\n        ...     output_schema={\"type\": \"object\", \"properties\": {\"summary\": {\"type\": \"string\"}}}\n        ... )\n    \"\"\"\n\n    id: str = Field(..., description=\"Unique skill identifier\")\n    description: str = Field(..., description=\"Human-readable skill description\")\n    input_schema: dict[str, Any] | None = Field(\n        default=None, description=\"JSON Schema for skill input validation\"\n    )\n    output_schema: dict[str, Any] | None = Field(\n        default=None, description=\"JSON Schema for skill output validation\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.entities.StateSnapshot","title":"<code>StateSnapshot</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>First-class state persistence mechanism.</p> <p>StateSnapshots enable task state to be saved and restored, addressing a key limitation in other agent protocols. Supports versioning and checkpoint flagging for important states.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>SnapshotID</code> <p>Unique snapshot identifier (ULID format)</p> <code>task_id</code> <code>TaskID</code> <p>ID of the task this snapshot belongs to</p> <code>version</code> <code>int</code> <p>Snapshot version number (auto-incremented)</p> <code>data</code> <code>dict[str, Any]</code> <p>Arbitrary state data (JSON-serializable dict)</p> <code>checkpoint</code> <code>bool</code> <p>Whether this is a significant checkpoint (default: False)</p> <code>created_at</code> <code>datetime</code> <p>When the snapshot was created (UTC)</p> Example <p>from datetime import datetime, timezone snapshot = StateSnapshot( ...     id=\"snap_01HX5K7R...\", ...     task_id=\"task_01HX5K4N...\", ...     version=3, ...     data={\"search_completed\": True, \"sources_analyzed\": 15}, ...     checkpoint=True, ...     created_at=datetime.now(timezone.utc) ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class StateSnapshot(ASAPBaseModel):\n    \"\"\"First-class state persistence mechanism.\n\n    StateSnapshots enable task state to be saved and restored,\n    addressing a key limitation in other agent protocols. Supports\n    versioning and checkpoint flagging for important states.\n\n    Attributes:\n        id: Unique snapshot identifier (ULID format)\n        task_id: ID of the task this snapshot belongs to\n        version: Snapshot version number (auto-incremented)\n        data: Arbitrary state data (JSON-serializable dict)\n        checkpoint: Whether this is a significant checkpoint (default: False)\n        created_at: When the snapshot was created (UTC)\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; snapshot = StateSnapshot(\n        ...     id=\"snap_01HX5K7R...\",\n        ...     task_id=\"task_01HX5K4N...\",\n        ...     version=3,\n        ...     data={\"search_completed\": True, \"sources_analyzed\": 15},\n        ...     checkpoint=True,\n        ...     created_at=datetime.now(timezone.utc)\n        ... )\n    \"\"\"\n\n    id: SnapshotID = Field(..., description=\"Unique snapshot identifier (ULID)\")\n    task_id: TaskID = Field(..., description=\"Parent task ID\")\n    version: int = Field(..., description=\"Snapshot version number\", ge=1)\n    data: dict[str, Any] = Field(..., description=\"State data (JSON-serializable)\")\n    checkpoint: bool = Field(default=False, description=\"Whether this is a significant checkpoint\")\n    created_at: datetime = Field(..., description=\"Creation timestamp (UTC)\")\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Task","title":"<code>Task</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>The fundamental unit of work in ASAP.</p> <p>Tasks are uniquely identified, stateful with a defined lifecycle, cancellable, resumable, and capable of producing artifacts.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TaskID</code> <p>Unique task identifier (ULID format)</p> <code>conversation_id</code> <code>ConversationID</code> <p>ID of the conversation this task belongs to</p> <code>parent_task_id</code> <code>TaskID | None</code> <p>Optional ID of parent task (for subtasks)</p> <code>status</code> <code>TaskStatus</code> <p>Current task status (submitted, working, completed, etc.)</p> <code>depth</code> <code>int</code> <p>Nesting depth (0 = root); must be \u2264 MAX_TASK_DEPTH to prevent infinite recursion</p> <code>progress</code> <code>dict[str, Any] | None</code> <p>Optional progress information (percent, message, ETA)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when the task was created (UTC)</p> <code>updated_at</code> <code>datetime</code> <p>Timestamp of last status update (UTC)</p> Example <p>from datetime import datetime, timezone task = Task( ...     id=\"task_01HX5K4N...\", ...     conversation_id=\"conv_01HX5K3MQVN8...\", ...     status=\"working\", ...     progress={\"percent\": 45, \"message\": \"Analyzing search results...\"}, ...     created_at=datetime.now(timezone.utc), ...     updated_at=datetime.now(timezone.utc) ... )</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class Task(ASAPBaseModel):\n    \"\"\"The fundamental unit of work in ASAP.\n\n    Tasks are uniquely identified, stateful with a defined lifecycle,\n    cancellable, resumable, and capable of producing artifacts.\n\n    Attributes:\n        id: Unique task identifier (ULID format)\n        conversation_id: ID of the conversation this task belongs to\n        parent_task_id: Optional ID of parent task (for subtasks)\n        status: Current task status (submitted, working, completed, etc.)\n        depth: Nesting depth (0 = root); must be \u2264 MAX_TASK_DEPTH to prevent infinite recursion\n        progress: Optional progress information (percent, message, ETA)\n        created_at: Timestamp when the task was created (UTC)\n        updated_at: Timestamp of last status update (UTC)\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; task = Task(\n        ...     id=\"task_01HX5K4N...\",\n        ...     conversation_id=\"conv_01HX5K3MQVN8...\",\n        ...     status=\"working\",\n        ...     progress={\"percent\": 45, \"message\": \"Analyzing search results...\"},\n        ...     created_at=datetime.now(timezone.utc),\n        ...     updated_at=datetime.now(timezone.utc)\n        ... )\n    \"\"\"\n\n    id: TaskID = Field(..., description=\"Unique task identifier (ULID)\")\n    conversation_id: ConversationID = Field(..., description=\"Parent conversation ID\")\n    parent_task_id: TaskID | None = Field(default=None, description=\"Parent task ID for subtasks\")\n    status: TaskStatus = Field(..., description=\"Task status (submitted, working, etc.)\")\n    depth: int = Field(\n        0,\n        ge=0,\n        le=MAX_TASK_DEPTH,\n        description=\"Nesting depth for subtasks (0 = root); prevents infinite recursion\",\n    )\n    progress: dict[str, Any] | None = Field(\n        default=None, description=\"Progress info (percent, message, ETA)\"\n    )\n    created_at: datetime = Field(..., description=\"Creation timestamp (UTC)\")\n    updated_at: datetime = Field(..., description=\"Last update timestamp (UTC)\")\n\n    def is_terminal(self) -&gt; bool:\n        \"\"\"Check if task is in a terminal state (completed, failed, or cancelled).\"\"\"\n        return self.status.is_terminal()\n\n    def can_be_cancelled(self) -&gt; bool:\n        \"\"\"Check if task can be cancelled (only submitted or working tasks).\"\"\"\n        return self.status in {TaskStatus.SUBMITTED, TaskStatus.WORKING}\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Task.can_be_cancelled","title":"<code>can_be_cancelled()</code>","text":"<p>Check if task can be cancelled (only submitted or working tasks).</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>def can_be_cancelled(self) -&gt; bool:\n    \"\"\"Check if task can be cancelled (only submitted or working tasks).\"\"\"\n    return self.status in {TaskStatus.SUBMITTED, TaskStatus.WORKING}\n</code></pre>"},{"location":"api-reference/#asap.models.entities.Task.is_terminal","title":"<code>is_terminal()</code>","text":"<p>Check if task is in a terminal state (completed, failed, or cancelled).</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>def is_terminal(self) -&gt; bool:\n    \"\"\"Check if task is in a terminal state (completed, failed, or cancelled).\"\"\"\n    return self.status.is_terminal()\n</code></pre>"},{"location":"api-reference/#asap.models.entities.VerificationStatus","title":"<code>VerificationStatus</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Verification status for marketplace trust badge (Task 3.6).</p> <p>When status is 'verified', the agent displays a Verified badge in the registry UI. Admins add this after manual review of verification requests.</p> Source code in <code>src/asap/models/entities.py</code> <pre><code>class VerificationStatus(ASAPBaseModel):\n    \"\"\"Verification status for marketplace trust badge (Task 3.6).\n\n    When status is 'verified', the agent displays a Verified badge in the\n    registry UI. Admins add this after manual review of verification requests.\n    \"\"\"\n\n    status: VerificationState = Field(\n        ..., description=\"Verification state (verified, pending, rejected)\"\n    )\n    verified_at: datetime | None = Field(\n        default=None,\n        description=\"ISO timestamp when verification was granted (None when pending)\",\n    )\n</code></pre>"},{"location":"api-reference/#parts","title":"Parts","text":""},{"location":"api-reference/#asap.models.parts","title":"<code>asap.models.parts</code>","text":"<p>Part models for ASAP protocol content types.</p> <p>Parts are atomic content units used within messages and artifacts. They support different content types including text, structured data, files, MCP resources, and parameterized templates.</p>"},{"location":"api-reference/#asap.models.parts.Part","title":"<code>Part = TypeAdapter(PartType)</code>  <code>module-attribute</code>","text":"<p>TypeAdapter for Part discriminated union.</p> <p>Part is a TypeAdapter that can validate and deserialize any of the five part types: TextPart, DataPart, FilePart, ResourcePart, or TemplatePart.</p> <p>The 'type' field is used as a discriminator to automatically deserialize JSON data into the correct Part subtype.</p> Example <p>from asap.models.parts import Part</p>"},{"location":"api-reference/#asap.models.parts.Part--deserializes-to-textpart","title":"Deserializes to TextPart","text":"<p>text_part = Part.validate_python({\"type\": \"text\", \"content\": \"Hello\"})</p>"},{"location":"api-reference/#asap.models.parts.Part--deserializes-to-datapart","title":"Deserializes to DataPart","text":"<p>data_part = Part.validate_python({\"type\": \"data\", \"data\": {\"key\": \"value\"}})</p>"},{"location":"api-reference/#asap.models.parts.Part--deserializes-to-filepart","title":"Deserializes to FilePart","text":"<p>file_part = Part.validate_python({ ...     \"type\": \"file\", ...     \"uri\": \"https://example.com/doc.pdf\", ...     \"mime_type\": \"application/pdf\" ... })</p>"},{"location":"api-reference/#asap.models.parts.DataPart","title":"<code>DataPart</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Structured JSON data part.</p> <p>DataPart represents structured data in JSON format, optionally with a schema URI for validation.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['data']</code> <p>Discriminator field, always \"data\"</p> <code>data</code> <code>dict[str, Any]</code> <p>Arbitrary JSON-serializable data</p> <code>schema_uri</code> <code>str | None</code> <p>Optional URI to JSON Schema for validation</p> Example <p>part = DataPart( ...     type=\"data\", ...     data={\"query\": \"AI trends\", \"max_results\": 10}, ...     schema_uri=\"https://example.com/schemas/search.json\" ... )</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>class DataPart(ASAPBaseModel):\n    \"\"\"Structured JSON data part.\n\n    DataPart represents structured data in JSON format, optionally\n    with a schema URI for validation.\n\n    Attributes:\n        type: Discriminator field, always \"data\"\n        data: Arbitrary JSON-serializable data\n        schema_uri: Optional URI to JSON Schema for validation\n\n    Example:\n        &gt;&gt;&gt; part = DataPart(\n        ...     type=\"data\",\n        ...     data={\"query\": \"AI trends\", \"max_results\": 10},\n        ...     schema_uri=\"https://example.com/schemas/search.json\"\n        ... )\n    \"\"\"\n\n    type: Literal[\"data\"] = Field(..., description=\"Part type discriminator\")\n    data: dict[str, Any] = Field(..., description=\"Structured data (JSON-serializable)\")\n    schema_uri: str | None = Field(\n        default=None, description=\"Optional JSON Schema URI for validation\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.parts.FilePart","title":"<code>FilePart</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Binary or text file part.</p> <p>FilePart represents file content, either by reference (URI) or inline (base64-encoded data). Includes MIME type for proper handling.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['file']</code> <p>Discriminator field, always \"file\"</p> <code>uri</code> <code>str</code> <p>File URI (asap://, https://, or data:; file:// and path traversal rejected)</p> <code>mime_type</code> <code>MIMEType</code> <p>MIME type of the file (e.g., \"application/pdf\")</p> <code>inline_data</code> <code>str | None</code> <p>Optional base64-encoded inline file data</p> Example <p>part = FilePart( ...     type=\"file\", ...     uri=\"asap://artifacts/task_123/report.pdf\", ...     mime_type=\"application/pdf\" ... )</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>class FilePart(ASAPBaseModel):\n    \"\"\"Binary or text file part.\n\n    FilePart represents file content, either by reference (URI) or\n    inline (base64-encoded data). Includes MIME type for proper handling.\n\n    Attributes:\n        type: Discriminator field, always \"file\"\n        uri: File URI (asap://, https://, or data:; file:// and path traversal rejected)\n        mime_type: MIME type of the file (e.g., \"application/pdf\")\n        inline_data: Optional base64-encoded inline file data\n\n    Example:\n        &gt;&gt;&gt; part = FilePart(\n        ...     type=\"file\",\n        ...     uri=\"asap://artifacts/task_123/report.pdf\",\n        ...     mime_type=\"application/pdf\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With inline data\n        &gt;&gt;&gt; part_inline = FilePart(\n        ...     type=\"file\",\n        ...     uri=\"data:text/plain;base64,SGVsbG8gV29ybGQ=\",\n        ...     mime_type=\"text/plain\",\n        ...     inline_data=\"SGVsbG8gV29ybGQ=\"\n        ... )\n    \"\"\"\n\n    type: Literal[\"file\"] = Field(..., description=\"Part type discriminator\")\n    uri: str = Field(\n        ...,\n        description=\"File URI (asap://, https://, data:; file:// and .. rejected)\",\n    )\n    mime_type: MIMEType = Field(..., description=\"MIME type (e.g., application/pdf)\")\n    inline_data: str | None = Field(\n        default=None, description=\"Optional base64-encoded inline file data\"\n    )\n\n    @field_validator(\"uri\")\n    @classmethod\n    def validate_uri(cls, v: str) -&gt; str:\n        \"\"\"Validate URI: reject path traversal and suspicious file:// URIs.\n\n        Rejects URIs containing '..' (path traversal) and file:// URIs\n        to prevent reading arbitrary server paths from user-supplied input.\n\n        Args:\n            v: URI string to validate\n\n        Returns:\n            The same URI if valid\n\n        Raises:\n            ValueError: If URI contains path traversal or is a file:// URI\n        \"\"\"\n        if PATH_TRAVERSAL_PATTERN.search(v):\n            raise ValueError(f\"URI must not contain path traversal (..): {v!r}\")\n        if v.strip().lower().startswith(FILE_URI_PREFIX):\n            raise ValueError(\"file:// URIs are not allowed for security (path traversal risk)\")\n        return v\n\n    @field_validator(\"mime_type\")\n    @classmethod\n    def validate_mime_type(cls, v: str) -&gt; str:\n        \"\"\"Validate MIME type format (type/subtype).\"\"\"\n        # Pattern: type/subtype where both parts can contain alphanumeric, dots, plus, and hyphens\n        if not re.match(r\"^[a-z0-9-]+/[a-z0-9.+\\-]+$\", v.lower()):\n            raise ValueError(f\"Invalid MIME type format: {v}\")\n        return v\n\n    @field_validator(\"inline_data\")\n    @classmethod\n    def validate_base64(cls, v: str | None) -&gt; str | None:\n        \"\"\"Validate that inline_data is valid base64 when provided.\n\n        Args:\n            v: Base64 string or None\n\n        Returns:\n            Base64 string after validation\n\n        Raises:\n            ValueError: If inline_data is not valid base64\n        \"\"\"\n        if v is not None:\n            try:\n                base64.b64decode(v, validate=True)\n            except Exception as e:\n                raise ValueError(f\"inline_data must be valid base64: {e}\") from e\n        return v\n</code></pre>"},{"location":"api-reference/#asap.models.parts.FilePart--with-inline-data","title":"With inline data","text":"<p>part_inline = FilePart( ...     type=\"file\", ...     uri=\"data:text/plain;base64,SGVsbG8gV29ybGQ=\", ...     mime_type=\"text/plain\", ...     inline_data=\"SGVsbG8gV29ybGQ=\" ... )</p>"},{"location":"api-reference/#asap.models.parts.FilePart.validate_base64","title":"<code>validate_base64(v)</code>  <code>classmethod</code>","text":"<p>Validate that inline_data is valid base64 when provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | None</code> <p>Base64 string or None</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Base64 string after validation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inline_data is not valid base64</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>@field_validator(\"inline_data\")\n@classmethod\ndef validate_base64(cls, v: str | None) -&gt; str | None:\n    \"\"\"Validate that inline_data is valid base64 when provided.\n\n    Args:\n        v: Base64 string or None\n\n    Returns:\n        Base64 string after validation\n\n    Raises:\n        ValueError: If inline_data is not valid base64\n    \"\"\"\n    if v is not None:\n        try:\n            base64.b64decode(v, validate=True)\n        except Exception as e:\n            raise ValueError(f\"inline_data must be valid base64: {e}\") from e\n    return v\n</code></pre>"},{"location":"api-reference/#asap.models.parts.FilePart.validate_mime_type","title":"<code>validate_mime_type(v)</code>  <code>classmethod</code>","text":"<p>Validate MIME type format (type/subtype).</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>@field_validator(\"mime_type\")\n@classmethod\ndef validate_mime_type(cls, v: str) -&gt; str:\n    \"\"\"Validate MIME type format (type/subtype).\"\"\"\n    # Pattern: type/subtype where both parts can contain alphanumeric, dots, plus, and hyphens\n    if not re.match(r\"^[a-z0-9-]+/[a-z0-9.+\\-]+$\", v.lower()):\n        raise ValueError(f\"Invalid MIME type format: {v}\")\n    return v\n</code></pre>"},{"location":"api-reference/#asap.models.parts.FilePart.validate_uri","title":"<code>validate_uri(v)</code>  <code>classmethod</code>","text":"<p>Validate URI: reject path traversal and suspicious file:// URIs.</p> <p>Rejects URIs containing '..' (path traversal) and file:// URIs to prevent reading arbitrary server paths from user-supplied input.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>URI string to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The same URI if valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If URI contains path traversal or is a file:// URI</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>@field_validator(\"uri\")\n@classmethod\ndef validate_uri(cls, v: str) -&gt; str:\n    \"\"\"Validate URI: reject path traversal and suspicious file:// URIs.\n\n    Rejects URIs containing '..' (path traversal) and file:// URIs\n    to prevent reading arbitrary server paths from user-supplied input.\n\n    Args:\n        v: URI string to validate\n\n    Returns:\n        The same URI if valid\n\n    Raises:\n        ValueError: If URI contains path traversal or is a file:// URI\n    \"\"\"\n    if PATH_TRAVERSAL_PATTERN.search(v):\n        raise ValueError(f\"URI must not contain path traversal (..): {v!r}\")\n    if v.strip().lower().startswith(FILE_URI_PREFIX):\n        raise ValueError(\"file:// URIs are not allowed for security (path traversal risk)\")\n    return v\n</code></pre>"},{"location":"api-reference/#asap.models.parts.ResourcePart","title":"<code>ResourcePart</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Reference to an MCP resource.</p> <p>ResourcePart represents a reference to a resource provided by an MCP (Model Context Protocol) server, enabling integration with external tools and data sources.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['resource']</code> <p>Discriminator field, always \"resource\"</p> <code>resource_uri</code> <code>str</code> <p>URI of the MCP resource</p> Example <p>part = ResourcePart( ...     type=\"resource\", ...     resource_uri=\"mcp://tools.example.com/web/search_results\" ... )</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>class ResourcePart(ASAPBaseModel):\n    \"\"\"Reference to an MCP resource.\n\n    ResourcePart represents a reference to a resource provided by\n    an MCP (Model Context Protocol) server, enabling integration\n    with external tools and data sources.\n\n    Attributes:\n        type: Discriminator field, always \"resource\"\n        resource_uri: URI of the MCP resource\n\n    Example:\n        &gt;&gt;&gt; part = ResourcePart(\n        ...     type=\"resource\",\n        ...     resource_uri=\"mcp://tools.example.com/web/search_results\"\n        ... )\n    \"\"\"\n\n    type: Literal[\"resource\"] = Field(..., description=\"Part type discriminator\")\n    resource_uri: str = Field(..., description=\"MCP resource URI\")\n</code></pre>"},{"location":"api-reference/#asap.models.parts.TemplatePart","title":"<code>TemplatePart</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Parameterized prompt template.</p> <p>TemplatePart represents a template string with variable placeholders (using {{variable}} syntax) and their corresponding values.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['template']</code> <p>Discriminator field, always \"template\"</p> <code>template</code> <code>str</code> <p>Template string with {{variable}} placeholders</p> <code>variables</code> <code>dict[str, Any]</code> <p>Dictionary mapping variable names to their values</p> Example <p>part = TemplatePart( ...     type=\"template\", ...     template=\"Research {{topic}} for {{timeframe}}\", ...     variables={\"topic\": \"AI trends\", \"timeframe\": \"Q3 2025\"} ... )</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>class TemplatePart(ASAPBaseModel):\n    \"\"\"Parameterized prompt template.\n\n    TemplatePart represents a template string with variable placeholders\n    (using {{variable}} syntax) and their corresponding values.\n\n    Attributes:\n        type: Discriminator field, always \"template\"\n        template: Template string with {{variable}} placeholders\n        variables: Dictionary mapping variable names to their values\n\n    Example:\n        &gt;&gt;&gt; part = TemplatePart(\n        ...     type=\"template\",\n        ...     template=\"Research {{topic}} for {{timeframe}}\",\n        ...     variables={\"topic\": \"AI trends\", \"timeframe\": \"Q3 2025\"}\n        ... )\n    \"\"\"\n\n    type: Literal[\"template\"] = Field(..., description=\"Part type discriminator\")\n    template: str = Field(..., description=\"Template string with {{variable}} syntax\")\n    variables: dict[str, Any] = Field(..., description=\"Variable name to value mapping\")\n</code></pre>"},{"location":"api-reference/#asap.models.parts.TextPart","title":"<code>TextPart</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Plain text content part.</p> <p>TextPart represents simple text content, such as user messages, agent responses, or any textual information.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['text']</code> <p>Discriminator field, always \"text\"</p> <code>content</code> <code>str</code> <p>The text content</p> Example <p>part = TextPart( ...     type=\"text\", ...     content=\"Research Q3 market trends for AI infrastructure\" ... )</p> Source code in <code>src/asap/models/parts.py</code> <pre><code>class TextPart(ASAPBaseModel):\n    \"\"\"Plain text content part.\n\n    TextPart represents simple text content, such as user messages,\n    agent responses, or any textual information.\n\n    Attributes:\n        type: Discriminator field, always \"text\"\n        content: The text content\n\n    Example:\n        &gt;&gt;&gt; part = TextPart(\n        ...     type=\"text\",\n        ...     content=\"Research Q3 market trends for AI infrastructure\"\n        ... )\n    \"\"\"\n\n    type: Literal[\"text\"] = Field(..., description=\"Part type discriminator\")\n    content: str = Field(..., description=\"Text content\")\n</code></pre>"},{"location":"api-reference/#payloads","title":"Payloads","text":""},{"location":"api-reference/#asap.models.payloads","title":"<code>asap.models.payloads</code>","text":"<p>Payload models for ASAP protocol messages.</p> <p>Payloads define the content of protocol messages for different operations like task requests, responses, updates, state management, and MCP integration.</p>"},{"location":"api-reference/#asap.models.payloads.PayloadType","title":"<code>PayloadType = Union[TaskRequest, TaskResponse, TaskUpdate, TaskCancel, MessageSend, StateQuery, StateRestore, ArtifactNotify, McpToolCall, McpToolResult, McpResourceFetch, McpResourceData, MessageAck]</code>  <code>module-attribute</code>","text":"<p>Union type of all ASAP payload types.</p> <p>PayloadType represents any of the 13 payload types used in ASAP protocol messages. The actual payload type discrimination is done via the 'payload_type' field in the Envelope that wraps these payloads.</p> <p>Payload types: - Task operations: TaskRequest, TaskResponse, TaskUpdate, TaskCancel - Messaging: MessageSend - State management: StateQuery, StateRestore, ArtifactNotify - MCP integration: McpToolCall, McpToolResult, McpResourceFetch, McpResourceData - WebSocket reliability: MessageAck (ADR-16)</p>"},{"location":"api-reference/#asap.models.payloads.ArtifactNotify","title":"<code>ArtifactNotify</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Notify about artifact creation or availability.</p> <p>ArtifactNotify informs agents when a new artifact has been created or is available for retrieval.</p> <p>Attributes:</p> Name Type Description <code>artifact_id</code> <code>ArtifactID</code> <p>ID of the artifact</p> <code>task_id</code> <code>TaskID</code> <p>ID of the task that produced the artifact</p> <code>name</code> <code>str | None</code> <p>Optional human-readable artifact name</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class ArtifactNotify(ASAPBaseModel):\n    \"\"\"Notify about artifact creation or availability.\n\n    ArtifactNotify informs agents when a new artifact has been created\n    or is available for retrieval.\n\n    Attributes:\n        artifact_id: ID of the artifact\n        task_id: ID of the task that produced the artifact\n        name: Optional human-readable artifact name\n    \"\"\"\n\n    artifact_id: ArtifactID = Field(..., description=\"Artifact identifier\")\n    task_id: TaskID = Field(..., description=\"Parent task ID\")\n    name: str | None = Field(default=None, description=\"Optional human-readable artifact name\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.McpResourceData","title":"<code>McpResourceData</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Data from an MCP resource.</p> <p>McpResourceData provides the content of a fetched MCP resource.</p> <p>Attributes:</p> Name Type Description <code>resource_uri</code> <code>str</code> <p>URI of the resource</p> <code>content</code> <code>dict[str, Any]</code> <p>Resource content (JSON-serializable)</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class McpResourceData(ASAPBaseModel):\n    \"\"\"Data from an MCP resource.\n\n    McpResourceData provides the content of a fetched MCP resource.\n\n    Attributes:\n        resource_uri: URI of the resource\n        content: Resource content (JSON-serializable)\n    \"\"\"\n\n    resource_uri: str = Field(..., description=\"MCP resource URI\")\n    content: dict[str, Any] = Field(..., description=\"Resource content (JSON-serializable)\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.McpResourceFetch","title":"<code>McpResourceFetch</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Request to fetch an MCP resource.</p> <p>McpResourceFetch requests retrieval of a resource from an MCP server, such as documentation, data, or other content.</p> <p>Attributes:</p> Name Type Description <code>resource_uri</code> <code>str</code> <p>URI of the MCP resource to fetch</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class McpResourceFetch(ASAPBaseModel):\n    \"\"\"Request to fetch an MCP resource.\n\n    McpResourceFetch requests retrieval of a resource from an MCP server,\n    such as documentation, data, or other content.\n\n    Attributes:\n        resource_uri: URI of the MCP resource to fetch\n    \"\"\"\n\n    resource_uri: str = Field(..., description=\"MCP resource URI to fetch\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.McpToolCall","title":"<code>McpToolCall</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Call an MCP tool.</p> <p>McpToolCall invokes a tool provided by an MCP server, enabling agents to leverage external capabilities and integrations.</p> <p>Attributes:</p> Name Type Description <code>request_id</code> <code>str</code> <p>Unique identifier for this tool call request</p> <code>tool_name</code> <code>str</code> <p>Name of the MCP tool to invoke</p> <code>arguments</code> <code>dict[str, Any]</code> <p>Arguments to pass to the tool (JSON-serializable)</p> <code>mcp_context</code> <code>dict[str, Any] | None</code> <p>Optional MCP-specific context (server, session, etc.)</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class McpToolCall(ASAPBaseModel):\n    \"\"\"Call an MCP tool.\n\n    McpToolCall invokes a tool provided by an MCP server, enabling\n    agents to leverage external capabilities and integrations.\n\n    Attributes:\n        request_id: Unique identifier for this tool call request\n        tool_name: Name of the MCP tool to invoke\n        arguments: Arguments to pass to the tool (JSON-serializable)\n        mcp_context: Optional MCP-specific context (server, session, etc.)\n    \"\"\"\n\n    request_id: str = Field(..., description=\"Unique request identifier\")\n    tool_name: str = Field(..., description=\"MCP tool name to invoke\")\n    arguments: dict[str, Any] = Field(..., description=\"Tool arguments (JSON-serializable)\")\n    mcp_context: dict[str, Any] | None = Field(\n        default=None, description=\"Optional MCP context (server, session, etc.)\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.McpToolResult","title":"<code>McpToolResult</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Result of an MCP tool call.</p> <p>McpToolResult provides the outcome of an MCP tool invocation, including success status, result data, or error information.</p> <p>Attributes:</p> Name Type Description <code>request_id</code> <code>str</code> <p>ID of the original tool call request</p> <code>success</code> <code>bool</code> <p>Whether the tool call succeeded</p> <code>result</code> <code>dict[str, Any] | None</code> <p>Optional result data (if successful)</p> <code>error</code> <code>str | None</code> <p>Optional error message (if failed)</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class McpToolResult(ASAPBaseModel):\n    \"\"\"Result of an MCP tool call.\n\n    McpToolResult provides the outcome of an MCP tool invocation,\n    including success status, result data, or error information.\n\n    Attributes:\n        request_id: ID of the original tool call request\n        success: Whether the tool call succeeded\n        result: Optional result data (if successful)\n        error: Optional error message (if failed)\n    \"\"\"\n\n    request_id: str = Field(..., description=\"Original request identifier\")\n    success: bool = Field(..., description=\"Whether tool call succeeded\")\n    result: dict[str, Any] | None = Field(default=None, description=\"Result data (if successful)\")\n    error: str | None = Field(default=None, description=\"Error message (if failed)\")\n\n    @model_validator(mode=\"after\")\n    def validate_result_error_exclusivity(self) -&gt; \"McpToolResult\":\n        if self.success:\n            if self.result is None:\n                raise ValueError(\"result must be provided when success=True\")\n            if self.error is not None:\n                raise ValueError(\"error must be None when success=True\")\n        else:\n            if self.error is None:\n                raise ValueError(\"error must be provided when success=False\")\n            if self.result is not None:\n                raise ValueError(\"result must be None when success=False\")\n        return self\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.MessageAck","title":"<code>MessageAck</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Application-level ack for WebSocket state-changing messages (ADR-16).</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class MessageAck(ASAPBaseModel):\n    \"\"\"Application-level ack for WebSocket state-changing messages (ADR-16).\"\"\"\n\n    original_envelope_id: str = Field(..., description=\"Envelope ID being acknowledged\")\n    status: Literal[\"received\", \"processed\", \"rejected\"] = Field(...)\n    error: str | None = Field(default=None, description=\"Reason when rejected\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.MessageSend","title":"<code>MessageSend</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Send a message within a task conversation.</p> <p>MessageSend exchanges conversation turns between agents during task execution, containing message content as parts.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the task this message belongs to</p> <code>message_id</code> <code>MessageID</code> <p>Unique identifier for this message</p> <code>sender</code> <code>AgentURN</code> <p>Agent URN of the message sender</p> <code>role</code> <code>MessageRole</code> <p>Message role (user, assistant, system)</p> <code>parts</code> <code>list[PartID]</code> <p>List of part IDs that make up this message</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class MessageSend(ASAPBaseModel):\n    \"\"\"Send a message within a task conversation.\n\n    MessageSend exchanges conversation turns between agents during\n    task execution, containing message content as parts.\n\n    Attributes:\n        task_id: ID of the task this message belongs to\n        message_id: Unique identifier for this message\n        sender: Agent URN of the message sender\n        role: Message role (user, assistant, system)\n        parts: List of part IDs that make up this message\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Parent task ID\")\n    message_id: MessageID = Field(..., description=\"Unique message identifier\")\n    sender: AgentURN = Field(..., description=\"Sender agent URN\")\n    role: MessageRole = Field(..., description=\"Message role (user, assistant, system)\")\n    parts: list[PartID] = Field(..., description=\"Part IDs making up this message\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.StateQuery","title":"<code>StateQuery</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Request a state snapshot for a task.</p> <p>StateQuery requests the current or a specific version of a task's state snapshot for inspection or restoration.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the task to query state for</p> <code>version</code> <code>int | None</code> <p>Optional specific version number to retrieve</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class StateQuery(ASAPBaseModel):\n    \"\"\"Request a state snapshot for a task.\n\n    StateQuery requests the current or a specific version of a task's\n    state snapshot for inspection or restoration.\n\n    Attributes:\n        task_id: ID of the task to query state for\n        version: Optional specific version number to retrieve\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Task identifier\")\n    version: int | None = Field(default=None, description=\"Optional specific version to retrieve\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.StateRestore","title":"<code>StateRestore</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Restore a task to a previous state snapshot.</p> <p>StateRestore requests restoration of a task to a previously saved state snapshot, enabling rollback and recovery scenarios.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the task to restore</p> <code>snapshot_id</code> <code>SnapshotID</code> <p>ID of the snapshot to restore from</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class StateRestore(ASAPBaseModel):\n    \"\"\"Restore a task to a previous state snapshot.\n\n    StateRestore requests restoration of a task to a previously saved\n    state snapshot, enabling rollback and recovery scenarios.\n\n    Attributes:\n        task_id: ID of the task to restore\n        snapshot_id: ID of the snapshot to restore from\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Task identifier\")\n    snapshot_id: SnapshotID = Field(..., description=\"Snapshot ID to restore from\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskCancel","title":"<code>TaskCancel</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Request to cancel a running task.</p> <p>TaskCancel requests cancellation of a task that is currently executing. The agent should attempt graceful cancellation and cleanup.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the task to cancel</p> <code>reason</code> <code>str | None</code> <p>Optional reason for cancellation</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskCancel(ASAPBaseModel):\n    \"\"\"Request to cancel a running task.\n\n    TaskCancel requests cancellation of a task that is currently executing.\n    The agent should attempt graceful cancellation and cleanup.\n\n    Attributes:\n        task_id: ID of the task to cancel\n        reason: Optional reason for cancellation\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Task identifier to cancel\")\n    reason: str | None = Field(default=None, description=\"Optional cancellation reason\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskMetrics","title":"<code>TaskMetrics</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>TaskResponse.metrics (extra allowed).</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskMetrics(ASAPBaseModel):\n    \"\"\"TaskResponse.metrics (extra allowed).\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    duration_ms: int | None = Field(\n        default=None, ge=0, description=\"Execution duration in milliseconds\"\n    )\n    tokens_in: int | None = Field(default=None, ge=0, description=\"Input token count\")\n    tokens_out: int | None = Field(default=None, ge=0, description=\"Output token count\")\n    tokens_used: int | None = Field(\n        default=None, ge=0, description=\"Total tokens (fallback for tokens_out)\"\n    )\n    api_calls: int | None = Field(default=None, ge=0, description=\"Number of API calls\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskRequest","title":"<code>TaskRequest</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Request to execute a task on an agent.</p> <p>TaskRequest initiates task execution, specifying the skill to invoke, input data, and optional configuration parameters.</p> <p>Attributes:</p> Name Type Description <code>conversation_id</code> <code>ConversationID</code> <p>ID of the conversation this task belongs to</p> <code>parent_task_id</code> <code>TaskID | None</code> <p>Optional ID of parent task (for subtasks)</p> <code>skill_id</code> <code>str</code> <p>Identifier of the skill to execute</p> <code>input</code> <code>dict[str, Any]</code> <p>Input data for the skill (JSON-serializable)</p> <code>config</code> <code>TaskRequestConfig | None</code> <p>Optional configuration (timeout, priority, streaming, etc.)</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskRequest(ASAPBaseModel):\n    \"\"\"Request to execute a task on an agent.\n\n    TaskRequest initiates task execution, specifying the skill to invoke,\n    input data, and optional configuration parameters.\n\n    Attributes:\n        conversation_id: ID of the conversation this task belongs to\n        parent_task_id: Optional ID of parent task (for subtasks)\n        skill_id: Identifier of the skill to execute\n        input: Input data for the skill (JSON-serializable)\n        config: Optional configuration (timeout, priority, streaming, etc.)\n    \"\"\"\n\n    conversation_id: ConversationID = Field(..., description=\"Parent conversation ID\")\n    parent_task_id: TaskID | None = Field(default=None, description=\"Parent task ID for subtasks\")\n    skill_id: str = Field(..., description=\"Skill identifier to execute\")\n    input: dict[str, Any] = Field(..., description=\"Input data for the skill (skill-specific)\")\n    config: TaskRequestConfig | None = Field(\n        default=None, description=\"Optional configuration (timeout, priority, streaming, etc.)\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskRequestConfig","title":"<code>TaskRequestConfig</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>TaskRequest.config (extra allowed).</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskRequestConfig(ASAPBaseModel):\n    \"\"\"TaskRequest.config (extra allowed).\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    timeout_seconds: int | None = Field(\n        default=None, ge=1, description=\"Maximum execution time in seconds\"\n    )\n    priority: str | None = Field(\n        default=None, description=\"Task priority (e.g., 'low', 'normal', 'high')\"\n    )\n    idempotency_key: str | None = Field(default=None, description=\"Key for idempotent execution\")\n    streaming: bool | None = Field(default=None, description=\"Whether to stream progress updates\")\n    persist_state: bool | None = Field(\n        default=None, description=\"Whether to persist state snapshots\"\n    )\n    model: str | None = Field(default=None, description=\"LLM model identifier\")\n    temperature: float | None = Field(default=None, ge=0, le=2, description=\"LLM temperature (0-2)\")\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskResponse","title":"<code>TaskResponse</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Response to a task execution request.</p> <p>TaskResponse provides the final result of task execution, including status, result data, final state snapshot, and execution metrics.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the completed task</p> <code>status</code> <code>TaskStatus</code> <p>Final task status (completed, failed, cancelled, etc.)</p> <code>result</code> <code>dict[str, Any] | None</code> <p>Optional result data (summary, artifacts, etc.)</p> <code>final_state</code> <code>dict[str, Any] | None</code> <p>Optional final state snapshot</p> <code>metrics</code> <code>TaskMetrics | None</code> <p>Optional execution metrics (duration, tokens used, etc.)</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskResponse(ASAPBaseModel):\n    \"\"\"Response to a task execution request.\n\n    TaskResponse provides the final result of task execution, including\n    status, result data, final state snapshot, and execution metrics.\n\n    Attributes:\n        task_id: ID of the completed task\n        status: Final task status (completed, failed, cancelled, etc.)\n        result: Optional result data (summary, artifacts, etc.)\n        final_state: Optional final state snapshot\n        metrics: Optional execution metrics (duration, tokens used, etc.)\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Task identifier\")\n    status: TaskStatus = Field(..., description=\"Final task status\")\n    result: dict[str, Any] | None = Field(\n        default=None, description=\"Result data (summary, artifacts, etc.)\"\n    )\n    final_state: dict[str, Any] | None = Field(default=None, description=\"Final state snapshot\")\n    metrics: TaskMetrics | None = Field(\n        default=None, description=\"Execution metrics (duration, tokens, etc.)\"\n    )\n</code></pre>"},{"location":"api-reference/#asap.models.payloads.TaskUpdate","title":"<code>TaskUpdate</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Update on task execution progress or status.</p> <p>TaskUpdate provides real-time updates during task execution, including progress information or requests for additional input.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>TaskID</code> <p>ID of the task being updated</p> <code>update_type</code> <code>UpdateType</code> <p>Type of update (progress, input_required, etc.)</p> <code>status</code> <code>TaskStatus</code> <p>Current task status</p> <code>progress</code> <code>dict[str, Any] | None</code> <p>Optional progress information (percent, message, ETA)</p> <code>input_request</code> <code>dict[str, Any] | None</code> <p>Optional request for additional input from user</p> Source code in <code>src/asap/models/payloads.py</code> <pre><code>class TaskUpdate(ASAPBaseModel):\n    \"\"\"Update on task execution progress or status.\n\n    TaskUpdate provides real-time updates during task execution, including\n    progress information or requests for additional input.\n\n    Attributes:\n        task_id: ID of the task being updated\n        update_type: Type of update (progress, input_required, etc.)\n        status: Current task status\n        progress: Optional progress information (percent, message, ETA)\n        input_request: Optional request for additional input from user\n    \"\"\"\n\n    task_id: TaskID = Field(..., description=\"Task identifier\")\n    update_type: UpdateType = Field(..., description=\"Update type (progress, input_required)\")\n    status: TaskStatus = Field(..., description=\"Current task status\")\n    progress: dict[str, Any] | None = Field(\n        default=None, description=\"Progress info (percent, message, ETA)\"\n    )\n    input_request: dict[str, Any] | None = Field(\n        default=None, description=\"Request for additional input\"\n    )\n\n    @field_validator(\"progress\")\n    @classmethod\n    def validate_progress_percent(cls, v: dict[str, Any] | None) -&gt; dict[str, Any] | None:\n        if v and \"percent\" in v:\n            percent = v[\"percent\"]\n            if not isinstance(percent, (int, float)):\n                raise ValueError(\"progress.percent must be a number\")\n            if not (0 &lt;= percent &lt;= 100):\n                raise ValueError(\"progress.percent must be between 0 and 100\")\n        return v\n</code></pre>"},{"location":"api-reference/#envelope","title":"Envelope","text":""},{"location":"api-reference/#asap.models.envelope","title":"<code>asap.models.envelope</code>","text":"<p>Envelope model for ASAP protocol messages.</p> <p>The Envelope wraps all ASAP protocol messages, providing metadata for routing, correlation, tracing, and versioning.</p>"},{"location":"api-reference/#asap.models.envelope.Envelope","title":"<code>Envelope</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>ASAP protocol message envelope.</p> <p>Envelope wraps all protocol messages with metadata for routing, correlation, tracing, and versioning. Auto-generates id and timestamp if not provided.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str | None</code> <p>Unique envelope identifier (auto-generated if not provided)</p> <code>asap_version</code> <code>str</code> <p>ASAP protocol version (e.g., \"0.1\")</p> <code>timestamp</code> <code>datetime | None</code> <p>Message timestamp in UTC (auto-generated if not provided)</p> <code>sender</code> <code>AgentURN</code> <p>Sender agent URN</p> <code>recipient</code> <code>AgentURN</code> <p>Recipient agent URN</p> <code>payload_type</code> <code>str</code> <p>Type of payload (TaskRequest, TaskResponse, etc.)</p> <code>payload</code> <code>PayloadType | dict[str, Any]</code> <p>Actual message payload</p> <code>correlation_id</code> <code>str | None</code> <p>Optional ID for correlating request/response pairs</p> <code>trace_id</code> <code>str | None</code> <p>Optional ID for distributed tracing</p> <code>extensions</code> <code>dict[str, Any] | None</code> <p>Optional custom extensions</p> Example <p>from datetime import datetime, timezone envelope = Envelope( ...     asap_version=\"0.1\", ...     sender=\"urn:asap:agent:coordinator\", ...     recipient=\"urn:asap:agent:research-v1\", ...     payload_type=\"TaskRequest\", ...     payload={\"conversation_id\": \"conv_123\", \"skill_id\": \"research\", \"input\": {}} ... )</p> Source code in <code>src/asap/models/envelope.py</code> <pre><code>class Envelope(ASAPBaseModel):\n    \"\"\"ASAP protocol message envelope.\n\n    Envelope wraps all protocol messages with metadata for routing,\n    correlation, tracing, and versioning. Auto-generates id and timestamp\n    if not provided.\n\n    Attributes:\n        id: Unique envelope identifier (auto-generated if not provided)\n        asap_version: ASAP protocol version (e.g., \"0.1\")\n        timestamp: Message timestamp in UTC (auto-generated if not provided)\n        sender: Sender agent URN\n        recipient: Recipient agent URN\n        payload_type: Type of payload (TaskRequest, TaskResponse, etc.)\n        payload: Actual message payload\n        correlation_id: Optional ID for correlating request/response pairs\n        trace_id: Optional ID for distributed tracing\n        extensions: Optional custom extensions\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; envelope = Envelope(\n        ...     asap_version=\"0.1\",\n        ...     sender=\"urn:asap:agent:coordinator\",\n        ...     recipient=\"urn:asap:agent:research-v1\",\n        ...     payload_type=\"TaskRequest\",\n        ...     payload={\"conversation_id\": \"conv_123\", \"skill_id\": \"research\", \"input\": {}}\n        ... )\n        &gt;&gt;&gt; # id and timestamp are auto-generated\n        &gt;&gt;&gt; assert envelope.id is not None\n        &gt;&gt;&gt; assert envelope.timestamp is not None\n    \"\"\"\n\n    id: str | None = Field(\n        default=None, description=\"Unique envelope identifier (ULID, auto-generated)\"\n    )\n    asap_version: str = Field(..., description=\"ASAP protocol version\")\n    timestamp: datetime | None = Field(\n        default=None, description=\"Message timestamp (UTC, auto-generated)\"\n    )\n    sender: AgentURN = Field(..., description=\"Sender agent URN\")\n    recipient: AgentURN = Field(..., description=\"Recipient agent URN\")\n    payload_type: str = Field(..., description=\"Payload type discriminator\")\n    payload: PayloadType | dict[str, Any] = Field(\n        ..., description=\"Message payload (typed when payload_type known, else dict)\"\n    )\n    correlation_id: str | None = Field(\n        default=None, description=\"Optional correlation ID for request/response pairing\"\n    )\n    trace_id: str | None = Field(\n        default=None, description=\"Optional trace ID for distributed tracing\"\n    )\n    requires_ack: bool = Field(\n        default=False,\n        description=(\n            \"When True, receiver must send a MessageAck for this envelope (WebSocket). \"\n            \"Over WebSocket, auto-set for state-changing payloads: TaskRequest, \"\n            \"TaskCancel, StateRestore, MessageSend. HTTP transport uses response as implicit ack.\"\n        ),\n    )\n    extensions: dict[str, Any] | None = Field(\n        default=None,\n        description=(\n            \"Optional custom extensions. \"\n            \"Can include a 'nonce' field (string) for replay attack prevention. \"\n            \"If provided, the nonce must be unique within the TTL window (typically 10 minutes). \"\n            \"Duplicate nonces will be rejected by the validation layer.\"\n        ),\n    )\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def generate_id_if_missing(cls, v: str | None) -&gt; str:\n        \"\"\"Auto-generate ID if not provided.\"\"\"\n        if v is None:\n            return generate_id()\n        return v\n\n    @field_validator(\"timestamp\", mode=\"before\")\n    @classmethod\n    def generate_timestamp_if_missing(cls, v: datetime | None) -&gt; datetime:\n        \"\"\"Auto-generate timestamp if not provided.\"\"\"\n        if v is None:\n            return datetime.now(timezone.utc)\n        return v\n\n    @field_validator(\"sender\", \"recipient\")\n    @classmethod\n    def validate_sender_recipient_urn(cls, v: str) -&gt; str:\n        \"\"\"Validate sender/recipient URN format and length.\"\"\"\n        return validate_agent_urn(v)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def parse_payload_from_dict(cls, data: Any) -&gt; Any:\n        if not isinstance(data, dict):\n            return data\n        payload = data.get(\"payload\")\n        payload_type = data.get(\"payload_type\")\n        if isinstance(payload, dict) and payload_type:\n            data = dict(data)\n            data[\"payload\"] = _parse_payload(payload_type, payload)\n        return data\n\n    @model_validator(mode=\"after\")\n    def validate_response_correlation(self) -&gt; \"Envelope\":\n        response_type_keys = {\"taskresponse\", \"mcptoolresult\", \"mcpresourcedata\"}\n\n        if (\n            _normalize_payload_type(self.payload_type) in response_type_keys\n            and not self.correlation_id\n        ):\n            raise ValueError(f\"{self.payload_type} must have correlation_id for request tracking\")\n        return self\n\n    @property\n    def payload_dict(self) -&gt; dict[str, Any]:\n        if isinstance(self.payload, ASAPBaseModel):\n            return self.payload.model_dump()\n        return self.payload\n</code></pre>"},{"location":"api-reference/#asap.models.envelope.Envelope--id-and-timestamp-are-auto-generated","title":"id and timestamp are auto-generated","text":"<p>assert envelope.id is not None assert envelope.timestamp is not None</p>"},{"location":"api-reference/#asap.models.envelope.Envelope.generate_id_if_missing","title":"<code>generate_id_if_missing(v)</code>  <code>classmethod</code>","text":"<p>Auto-generate ID if not provided.</p> Source code in <code>src/asap/models/envelope.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\n@classmethod\ndef generate_id_if_missing(cls, v: str | None) -&gt; str:\n    \"\"\"Auto-generate ID if not provided.\"\"\"\n    if v is None:\n        return generate_id()\n    return v\n</code></pre>"},{"location":"api-reference/#asap.models.envelope.Envelope.generate_timestamp_if_missing","title":"<code>generate_timestamp_if_missing(v)</code>  <code>classmethod</code>","text":"<p>Auto-generate timestamp if not provided.</p> Source code in <code>src/asap/models/envelope.py</code> <pre><code>@field_validator(\"timestamp\", mode=\"before\")\n@classmethod\ndef generate_timestamp_if_missing(cls, v: datetime | None) -&gt; datetime:\n    \"\"\"Auto-generate timestamp if not provided.\"\"\"\n    if v is None:\n        return datetime.now(timezone.utc)\n    return v\n</code></pre>"},{"location":"api-reference/#asap.models.envelope.Envelope.validate_sender_recipient_urn","title":"<code>validate_sender_recipient_urn(v)</code>  <code>classmethod</code>","text":"<p>Validate sender/recipient URN format and length.</p> Source code in <code>src/asap/models/envelope.py</code> <pre><code>@field_validator(\"sender\", \"recipient\")\n@classmethod\ndef validate_sender_recipient_urn(cls, v: str) -&gt; str:\n    \"\"\"Validate sender/recipient URN format and length.\"\"\"\n    return validate_agent_urn(v)\n</code></pre>"},{"location":"api-reference/#state","title":"State","text":""},{"location":"api-reference/#asap.state","title":"<code>asap.state</code>","text":"<p>ASAP State Management Module.</p> <p>This module provides state machine functionality for managing task lifecycles and state transitions in the ASAP protocol.</p> Example <p>from asap.models.enums import TaskStatus can_transition(TaskStatus.SUBMITTED, TaskStatus.WORKING) True</p>"},{"location":"api-reference/#asap.state.InMemoryMeteringStore","title":"<code>InMemoryMeteringStore</code>","text":"<p>In-memory implementation of MeteringStore.</p> <p>Stores usage events in a list with asyncio.Lock for async-safe concurrent access. Used for testing and development; not persistent across restarts.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>class InMemoryMeteringStore:\n    \"\"\"In-memory implementation of MeteringStore.\n\n    Stores usage events in a list with asyncio.Lock for async-safe concurrent access.\n    Used for testing and development; not persistent across restarts.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the in-memory metering store.\"\"\"\n        self._lock = asyncio.Lock()\n        self._events: list[UsageEvent] = []\n\n    async def record(self, event: UsageEvent) -&gt; None:\n        \"\"\"Append a usage event to the store (async-safe).\"\"\"\n        async with self._lock:\n            self._events.append(event)\n\n    async def query(\n        self,\n        agent_id: str,\n        start: datetime,\n        end: datetime,\n        limit: int | None = None,\n        offset: int = 0,\n    ) -&gt; list[UsageEvent]:\n        \"\"\"Return events for the agent in [start, end], sorted by timestamp.\"\"\"\n        if offset &lt; 0:\n            raise ValueError(\"offset must be non-negative\")\n        async with self._lock:\n            out = [\n                e for e in self._events if e.agent_id == agent_id and start &lt;= e.timestamp &lt;= end\n            ]\n        out = sorted(out, key=lambda e: e.timestamp)\n        return out[offset : offset + limit] if limit is not None else out[offset:]\n\n    async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate:\n        \"\"\"Aggregate all stored events for the agent into one UsageAggregate.\"\"\"\n        async with self._lock:\n            agent_events = [e for e in self._events if e.agent_id == agent_id]\n        total_tokens = sum(e.metrics.tokens_in + e.metrics.tokens_out for e in agent_events)\n        total_duration = sum(e.metrics.duration_ms for e in agent_events)\n        total_tasks = len(agent_events)\n        total_api_calls = sum(e.metrics.api_calls for e in agent_events)\n        return UsageAggregate(\n            agent_id=agent_id,\n            period=period,\n            total_tokens=total_tokens,\n            total_duration=total_duration,\n            total_tasks=total_tasks,\n            total_api_calls=total_api_calls,\n        )\n</code></pre>"},{"location":"api-reference/#asap.state.InMemoryMeteringStore.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the in-memory metering store.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the in-memory metering store.\"\"\"\n    self._lock = asyncio.Lock()\n    self._events: list[UsageEvent] = []\n</code></pre>"},{"location":"api-reference/#asap.state.InMemoryMeteringStore.aggregate","title":"<code>aggregate(agent_id, period)</code>  <code>async</code>","text":"<p>Aggregate all stored events for the agent into one UsageAggregate.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate:\n    \"\"\"Aggregate all stored events for the agent into one UsageAggregate.\"\"\"\n    async with self._lock:\n        agent_events = [e for e in self._events if e.agent_id == agent_id]\n    total_tokens = sum(e.metrics.tokens_in + e.metrics.tokens_out for e in agent_events)\n    total_duration = sum(e.metrics.duration_ms for e in agent_events)\n    total_tasks = len(agent_events)\n    total_api_calls = sum(e.metrics.api_calls for e in agent_events)\n    return UsageAggregate(\n        agent_id=agent_id,\n        period=period,\n        total_tokens=total_tokens,\n        total_duration=total_duration,\n        total_tasks=total_tasks,\n        total_api_calls=total_api_calls,\n    )\n</code></pre>"},{"location":"api-reference/#asap.state.InMemoryMeteringStore.query","title":"<code>query(agent_id, start, end, limit=None, offset=0)</code>  <code>async</code>","text":"<p>Return events for the agent in [start, end], sorted by timestamp.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>async def query(\n    self,\n    agent_id: str,\n    start: datetime,\n    end: datetime,\n    limit: int | None = None,\n    offset: int = 0,\n) -&gt; list[UsageEvent]:\n    \"\"\"Return events for the agent in [start, end], sorted by timestamp.\"\"\"\n    if offset &lt; 0:\n        raise ValueError(\"offset must be non-negative\")\n    async with self._lock:\n        out = [\n            e for e in self._events if e.agent_id == agent_id and start &lt;= e.timestamp &lt;= end\n        ]\n    out = sorted(out, key=lambda e: e.timestamp)\n    return out[offset : offset + limit] if limit is not None else out[offset:]\n</code></pre>"},{"location":"api-reference/#asap.state.InMemoryMeteringStore.record","title":"<code>record(event)</code>  <code>async</code>","text":"<p>Append a usage event to the store (async-safe).</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>async def record(self, event: UsageEvent) -&gt; None:\n    \"\"\"Append a usage event to the store (async-safe).\"\"\"\n    async with self._lock:\n        self._events.append(event)\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore","title":"<code>InMemorySnapshotStore</code>","text":"<p>In-memory implementation of SnapshotStore.</p> <p>Stores snapshots in memory using dictionaries. Useful for testing and simple applications that don't require persistence across restarts.</p> <p>This implementation is thread-safe using RLock for concurrent access.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>class InMemorySnapshotStore:\n    \"\"\"In-memory implementation of SnapshotStore.\n\n    Stores snapshots in memory using dictionaries. Useful for testing\n    and simple applications that don't require persistence across restarts.\n\n    This implementation is thread-safe using RLock for concurrent access.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the in-memory snapshot store.\"\"\"\n        self._lock = threading.RLock()\n        self._snapshots: dict[TaskID, dict[int, StateSnapshot]] = {}\n        self._latest_versions: dict[TaskID, int] = {}\n\n    def save(self, snapshot: StateSnapshot) -&gt; None:\n        \"\"\"Save a snapshot to the in-memory store.\"\"\"\n        with self._lock:\n            task_id = snapshot.task_id\n            if task_id not in self._snapshots:\n                self._snapshots[task_id] = {}\n            self._snapshots[task_id][snapshot.version] = snapshot\n            self._latest_versions[task_id] = max(\n                self._latest_versions.get(task_id, 0), snapshot.version\n            )\n\n    def get(\n        self,\n        task_id: TaskID,\n        version: int | None = None,\n    ) -&gt; StateSnapshot | None:\n        \"\"\"Retrieve a snapshot from the in-memory store.\"\"\"\n        with self._lock:\n            if task_id not in self._snapshots:\n                return None\n            if version is None:\n                latest_version = self._latest_versions.get(task_id)\n                if latest_version is None:\n                    return None\n                return self._snapshots[task_id].get(latest_version)\n            return self._snapshots[task_id].get(version)\n\n    def list_versions(self, task_id: TaskID) -&gt; list[int]:\n        \"\"\"List all available versions for a task.\"\"\"\n        with self._lock:\n            if task_id not in self._snapshots:\n                return []\n            return sorted(self._snapshots[task_id].keys())\n\n    def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n        \"\"\"Delete snapshot(s) for a task.\"\"\"\n        with self._lock:\n            if task_id not in self._snapshots:\n                return False\n            if version is None:\n                del self._snapshots[task_id]\n                if task_id in self._latest_versions:\n                    del self._latest_versions[task_id]\n                return True\n            if version in self._snapshots[task_id]:\n                del self._snapshots[task_id][version]\n                if self._latest_versions.get(task_id) == version:\n                    if self._snapshots[task_id]:\n                        self._latest_versions[task_id] = max(self._snapshots[task_id].keys())\n                    else:\n                        del self._latest_versions[task_id]\n                if not self._snapshots[task_id]:\n                    del self._snapshots[task_id]\n                    if task_id in self._latest_versions:\n                        del self._latest_versions[task_id]\n                return True\n            return False\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the in-memory snapshot store.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the in-memory snapshot store.\"\"\"\n    self._lock = threading.RLock()\n    self._snapshots: dict[TaskID, dict[int, StateSnapshot]] = {}\n    self._latest_versions: dict[TaskID, int] = {}\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore.delete","title":"<code>delete(task_id, version=None)</code>","text":"<p>Delete snapshot(s) for a task.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n    \"\"\"Delete snapshot(s) for a task.\"\"\"\n    with self._lock:\n        if task_id not in self._snapshots:\n            return False\n        if version is None:\n            del self._snapshots[task_id]\n            if task_id in self._latest_versions:\n                del self._latest_versions[task_id]\n            return True\n        if version in self._snapshots[task_id]:\n            del self._snapshots[task_id][version]\n            if self._latest_versions.get(task_id) == version:\n                if self._snapshots[task_id]:\n                    self._latest_versions[task_id] = max(self._snapshots[task_id].keys())\n                else:\n                    del self._latest_versions[task_id]\n            if not self._snapshots[task_id]:\n                del self._snapshots[task_id]\n                if task_id in self._latest_versions:\n                    del self._latest_versions[task_id]\n            return True\n        return False\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore.get","title":"<code>get(task_id, version=None)</code>","text":"<p>Retrieve a snapshot from the in-memory store.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>def get(\n    self,\n    task_id: TaskID,\n    version: int | None = None,\n) -&gt; StateSnapshot | None:\n    \"\"\"Retrieve a snapshot from the in-memory store.\"\"\"\n    with self._lock:\n        if task_id not in self._snapshots:\n            return None\n        if version is None:\n            latest_version = self._latest_versions.get(task_id)\n            if latest_version is None:\n                return None\n            return self._snapshots[task_id].get(latest_version)\n        return self._snapshots[task_id].get(version)\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore.list_versions","title":"<code>list_versions(task_id)</code>","text":"<p>List all available versions for a task.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>def list_versions(self, task_id: TaskID) -&gt; list[int]:\n    \"\"\"List all available versions for a task.\"\"\"\n    with self._lock:\n        if task_id not in self._snapshots:\n            return []\n        return sorted(self._snapshots[task_id].keys())\n</code></pre>"},{"location":"api-reference/#asap.state.InMemorySnapshotStore.save","title":"<code>save(snapshot)</code>","text":"<p>Save a snapshot to the in-memory store.</p> Source code in <code>src/asap/state/stores/memory.py</code> <pre><code>def save(self, snapshot: StateSnapshot) -&gt; None:\n    \"\"\"Save a snapshot to the in-memory store.\"\"\"\n    with self._lock:\n        task_id = snapshot.task_id\n        if task_id not in self._snapshots:\n            self._snapshots[task_id] = {}\n        self._snapshots[task_id][snapshot.version] = snapshot\n        self._latest_versions[task_id] = max(\n            self._latest_versions.get(task_id, 0), snapshot.version\n        )\n</code></pre>"},{"location":"api-reference/#asap.state.MeteringStore","title":"<code>MeteringStore</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for usage metering storage implementations.</p> <p>Provides the interface for recording and querying usage events and aggregates. Implementations can use various backends (memory, SQLite, etc.). Foundation for v1.3 Usage Metering.</p> Example <p>class CustomMeteringStore: ...     async def record(self, event: UsageEvent) -&gt; None: ... ...     async def query(self, agent_id: str, start: datetime, end: datetime) -&gt; list[UsageEvent]: ... ...     async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate: ... isinstance(CustomMeteringStore(), MeteringStore) True</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>@runtime_checkable\nclass MeteringStore(Protocol):\n    \"\"\"Protocol for usage metering storage implementations.\n\n    Provides the interface for recording and querying usage events and\n    aggregates. Implementations can use various backends (memory, SQLite, etc.).\n    Foundation for v1.3 Usage Metering.\n\n    Example:\n        &gt;&gt;&gt; class CustomMeteringStore:\n        ...     async def record(self, event: UsageEvent) -&gt; None: ...\n        ...     async def query(self, agent_id: str, start: datetime, end: datetime) -&gt; list[UsageEvent]: ...\n        ...     async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate: ...\n        &gt;&gt;&gt; isinstance(CustomMeteringStore(), MeteringStore)\n        True\n    \"\"\"\n\n    def record(self, event: \"UsageEvent\") -&gt; \"Awaitable[None]\":\n        \"\"\"Record a usage event.\n\n        Args:\n            event: The usage event to store.\n\n        Example:\n            &gt;&gt;&gt; store = InMemoryMeteringStore()\n            &gt;&gt;&gt; event = UsageEvent(task_id=\"task_01\", agent_id=\"agent_01\", ...)\n            &gt;&gt;&gt; store.record(event)\n        \"\"\"\n        ...\n\n    def query(\n        self,\n        agent_id: str,\n        start: datetime,\n        end: datetime,\n        limit: int | None = None,\n        offset: int = 0,\n    ) -&gt; Awaitable[list[\"UsageEvent\"]]:\n        \"\"\"Query usage events for an agent in a time range.\n\n        Args:\n            agent_id: Agent identifier.\n            start: Start of the time range (inclusive).\n            end: End of the time range (inclusive).\n            limit: Maximum number of events to return (None = no limit).\n            offset: Number of events to skip (default 0).\n\n        Returns:\n            List of usage events in the range, ordered by timestamp.\n\n        Example:\n            &gt;&gt;&gt; store = InMemoryMeteringStore()\n            &gt;&gt;&gt; events = store.query(\"agent_01\", start, end)\n        \"\"\"\n        ...\n\n    def aggregate(self, agent_id: str, period: str) -&gt; Awaitable[\"UsageAggregate\"]:\n        \"\"\"Aggregate usage for an agent over a period.\n\n        Args:\n            agent_id: Agent identifier.\n            period: Aggregation period (e.g. \"hour\", \"day\").\n\n        Returns:\n            Usage aggregate for the period.\n\n        Example:\n            &gt;&gt;&gt; store = InMemoryMeteringStore()\n            &gt;&gt;&gt; agg = store.aggregate(\"agent_01\", \"day\")\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/#asap.state.MeteringStore.aggregate","title":"<code>aggregate(agent_id, period)</code>","text":"<p>Aggregate usage for an agent over a period.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Agent identifier.</p> required <code>period</code> <code>str</code> <p>Aggregation period (e.g. \"hour\", \"day\").</p> required <p>Returns:</p> Type Description <code>Awaitable['UsageAggregate']</code> <p>Usage aggregate for the period.</p> Example <p>store = InMemoryMeteringStore() agg = store.aggregate(\"agent_01\", \"day\")</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>def aggregate(self, agent_id: str, period: str) -&gt; Awaitable[\"UsageAggregate\"]:\n    \"\"\"Aggregate usage for an agent over a period.\n\n    Args:\n        agent_id: Agent identifier.\n        period: Aggregation period (e.g. \"hour\", \"day\").\n\n    Returns:\n        Usage aggregate for the period.\n\n    Example:\n        &gt;&gt;&gt; store = InMemoryMeteringStore()\n        &gt;&gt;&gt; agg = store.aggregate(\"agent_01\", \"day\")\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.MeteringStore.query","title":"<code>query(agent_id, start, end, limit=None, offset=0)</code>","text":"<p>Query usage events for an agent in a time range.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Agent identifier.</p> required <code>start</code> <code>datetime</code> <p>Start of the time range (inclusive).</p> required <code>end</code> <code>datetime</code> <p>End of the time range (inclusive).</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of events to return (None = no limit).</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of events to skip (default 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>Awaitable[list['UsageEvent']]</code> <p>List of usage events in the range, ordered by timestamp.</p> Example <p>store = InMemoryMeteringStore() events = store.query(\"agent_01\", start, end)</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>def query(\n    self,\n    agent_id: str,\n    start: datetime,\n    end: datetime,\n    limit: int | None = None,\n    offset: int = 0,\n) -&gt; Awaitable[list[\"UsageEvent\"]]:\n    \"\"\"Query usage events for an agent in a time range.\n\n    Args:\n        agent_id: Agent identifier.\n        start: Start of the time range (inclusive).\n        end: End of the time range (inclusive).\n        limit: Maximum number of events to return (None = no limit).\n        offset: Number of events to skip (default 0).\n\n    Returns:\n        List of usage events in the range, ordered by timestamp.\n\n    Example:\n        &gt;&gt;&gt; store = InMemoryMeteringStore()\n        &gt;&gt;&gt; events = store.query(\"agent_01\", start, end)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.MeteringStore.record","title":"<code>record(event)</code>","text":"<p>Record a usage event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>'UsageEvent'</code> <p>The usage event to store.</p> required Example <p>store = InMemoryMeteringStore() event = UsageEvent(task_id=\"task_01\", agent_id=\"agent_01\", ...) store.record(event)</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>def record(self, event: \"UsageEvent\") -&gt; \"Awaitable[None]\":\n    \"\"\"Record a usage event.\n\n    Args:\n        event: The usage event to store.\n\n    Example:\n        &gt;&gt;&gt; store = InMemoryMeteringStore()\n        &gt;&gt;&gt; event = UsageEvent(task_id=\"task_01\", agent_id=\"agent_01\", ...)\n        &gt;&gt;&gt; store.record(event)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore","title":"<code>SQLiteMeteringStore</code>","text":"<p>SQLite-backed MeteringStore; usage events persist across restarts.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>class SQLiteMeteringStore:\n    \"\"\"SQLite-backed MeteringStore; usage events persist across restarts.\"\"\"\n\n    def __init__(self, db_path: str | Path = DEFAULT_DB_PATH) -&gt; None:\n        \"\"\"Share db_path with SQLiteSnapshotStore for a single DB file.\"\"\"\n        self._db_path = Path(db_path)\n\n    async def _ensure_usage_table(self, conn: aiosqlite.Connection) -&gt; None:\n        \"\"\"Create usage_events table and index if not exists.\"\"\"\n        await conn.execute(\n            f\"\"\"\n            CREATE TABLE IF NOT EXISTS {USAGE_EVENTS_TABLE} (\n                id TEXT PRIMARY KEY,\n                task_id TEXT NOT NULL,\n                agent_id TEXT NOT NULL,\n                consumer_id TEXT NOT NULL,\n                metrics TEXT NOT NULL,\n                timestamp TEXT NOT NULL\n            )\n            \"\"\"\n        )\n        await conn.execute(\n            f\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_usage_agent_timestamp\n            ON {USAGE_EVENTS_TABLE} (agent_id, timestamp)\n            \"\"\"\n        )\n        await conn.commit()\n\n    async def _record_impl(self, event: UsageEvent) -&gt; None:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_usage_table(conn)\n            event_id = f\"evt_{uuid.uuid4().hex}\"\n            row = _event_to_row(event, event_id)\n            await conn.execute(\n                f\"\"\"\n                INSERT INTO {USAGE_EVENTS_TABLE}\n                (id, task_id, agent_id, consumer_id, metrics, timestamp)\n                VALUES (?, ?, ?, ?, ?, ?)\n                \"\"\",  # nosec B608 - table name is module constant, values parameterized\n                row,\n            )\n            await conn.commit()\n\n    async def _query_impl(\n        self,\n        agent_id: str,\n        start: datetime,\n        end: datetime,\n        limit: int | None = None,\n        offset: int = 0,\n    ) -&gt; list[UsageEvent]:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_usage_table(conn)\n            start_s = start.isoformat()\n            end_s = end.isoformat()\n            query = f\"\"\"\n                SELECT id, task_id, agent_id, consumer_id, metrics, timestamp\n                FROM {USAGE_EVENTS_TABLE}\n                WHERE agent_id = ? AND timestamp &gt;= ? AND timestamp &lt;= ?\n                ORDER BY timestamp\n            \"\"\"  # nosec B608 - table name is module constant, values parameterized\n            params: list[Any] = [agent_id, start_s, end_s]\n            if limit is not None:\n                query += \" LIMIT ? OFFSET ?\"\n                params.extend([limit, offset])\n            elif offset &gt; 0:\n                query += \" LIMIT -1 OFFSET ?\"\n                params.append(offset)\n            cursor = await conn.execute(query, params)\n            rows = await cursor.fetchall()\n            return [_row_to_event(tuple(r)) for r in rows]\n\n    async def _aggregate_impl(self, agent_id: str, period: str) -&gt; UsageAggregate:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_usage_table(conn)\n            cursor = await conn.execute(\n                f\"\"\"\n                SELECT\n                    SUM(CAST(json_extract(metrics, '$.tokens_in') AS INTEGER) + CAST(json_extract(metrics, '$.tokens_out') AS INTEGER)),\n                    SUM(CAST(json_extract(metrics, '$.duration_ms') AS INTEGER)),\n                    COUNT(*),\n                    SUM(CAST(json_extract(metrics, '$.api_calls') AS INTEGER))\n                FROM {USAGE_EVENTS_TABLE}\n                WHERE agent_id = ?\n                \"\"\",  # nosec B608 - table name is module constant, values parameterized\n                (agent_id,),\n            )\n            row = await cursor.fetchone()\n            if row is None or (row[0] is None and row[1] is None):\n                return UsageAggregate(agent_id=agent_id, period=period)\n            total_tokens = row[0] or 0\n            total_duration = row[1] or 0\n            total_tasks = row[2] or 0\n            total_api_calls = row[3] or 0\n            return UsageAggregate(\n                agent_id=agent_id,\n                period=period,\n                total_tokens=total_tokens,\n                total_duration=total_duration,\n                total_tasks=total_tasks,\n                total_api_calls=total_api_calls,\n            )\n\n    async def record(self, event: UsageEvent) -&gt; None:\n        \"\"\"Record a usage event.\"\"\"\n        await self._record_impl(event)\n\n    async def query(\n        self,\n        agent_id: str,\n        start: datetime,\n        end: datetime,\n        limit: int | None = None,\n        offset: int = 0,\n    ) -&gt; list[UsageEvent]:\n        \"\"\"Query events in range.\"\"\"\n        if offset &lt; 0:\n            raise ValueError(\"offset must be non-negative\")\n        return await self._query_impl(agent_id, start, end, limit, offset)\n\n    async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate:\n        \"\"\"Aggregate usage for agent.\"\"\"\n        return await self._aggregate_impl(agent_id, period)\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Create usage_events table if not exists.\"\"\"\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_usage_table(conn)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore.__init__","title":"<code>__init__(db_path=DEFAULT_DB_PATH)</code>","text":"<p>Share db_path with SQLiteSnapshotStore for a single DB file.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def __init__(self, db_path: str | Path = DEFAULT_DB_PATH) -&gt; None:\n    \"\"\"Share db_path with SQLiteSnapshotStore for a single DB file.\"\"\"\n    self._db_path = Path(db_path)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore.aggregate","title":"<code>aggregate(agent_id, period)</code>  <code>async</code>","text":"<p>Aggregate usage for agent.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>async def aggregate(self, agent_id: str, period: str) -&gt; UsageAggregate:\n    \"\"\"Aggregate usage for agent.\"\"\"\n    return await self._aggregate_impl(agent_id, period)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore.initialize","title":"<code>initialize()</code>  <code>async</code>","text":"<p>Create usage_events table if not exists.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>async def initialize(self) -&gt; None:\n    \"\"\"Create usage_events table if not exists.\"\"\"\n    async with aiosqlite.connect(self._db_path) as conn:\n        await self._ensure_usage_table(conn)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore.query","title":"<code>query(agent_id, start, end, limit=None, offset=0)</code>  <code>async</code>","text":"<p>Query events in range.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>async def query(\n    self,\n    agent_id: str,\n    start: datetime,\n    end: datetime,\n    limit: int | None = None,\n    offset: int = 0,\n) -&gt; list[UsageEvent]:\n    \"\"\"Query events in range.\"\"\"\n    if offset &lt; 0:\n        raise ValueError(\"offset must be non-negative\")\n    return await self._query_impl(agent_id, start, end, limit, offset)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteMeteringStore.record","title":"<code>record(event)</code>  <code>async</code>","text":"<p>Record a usage event.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>async def record(self, event: UsageEvent) -&gt; None:\n    \"\"\"Record a usage event.\"\"\"\n    await self._record_impl(event)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore","title":"<code>SQLiteSnapshotStore</code>","text":"<p>SQLite-backed SnapshotStore; state persists across process restarts.</p> <p>Uses aiosqlite; sync methods wrap async calls so the store conforms to the sync SnapshotStore protocol. Call from sync code only (or use a dedicated thread if you must use from async context).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>class SQLiteSnapshotStore:\n    \"\"\"SQLite-backed SnapshotStore; state persists across process restarts.\n\n    Uses aiosqlite; sync methods wrap async calls so the store conforms to\n    the sync SnapshotStore protocol. Call from sync code only (or use\n    a dedicated thread if you must use from async context).\n    \"\"\"\n\n    def __init__(self, db_path: str | Path = DEFAULT_DB_PATH) -&gt; None:\n        \"\"\"Initialize with database file path.\"\"\"\n        self._db_path = Path(db_path)\n\n    async def _ensure_snapshots_table(self, conn: aiosqlite.Connection) -&gt; None:\n        \"\"\"Create snapshots table if not exists.\"\"\"\n        await conn.execute(\n            f\"\"\"\n            CREATE TABLE IF NOT EXISTS {SNAPSHOTS_TABLE} (\n                task_id TEXT NOT NULL,\n                id TEXT NOT NULL,\n                version INTEGER NOT NULL,\n                data TEXT NOT NULL,\n                checkpoint INTEGER NOT NULL,\n                created_at TEXT NOT NULL,\n                PRIMARY KEY (task_id, version)\n            )\n            \"\"\"\n        )\n        await conn.commit()\n\n    async def _save_impl(self, snapshot: StateSnapshot) -&gt; None:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_snapshots_table(conn)\n            row = _snapshot_to_row(snapshot)\n            await conn.execute(\n                f\"\"\"\n                INSERT OR REPLACE INTO {SNAPSHOTS_TABLE}\n                (task_id, id, version, data, checkpoint, created_at)\n                VALUES (?, ?, ?, ?, ?, ?)\n                \"\"\",\n                row,\n            )\n            await conn.commit()\n\n    async def _get_impl(\n        self,\n        task_id: TaskID,\n        version: int | None,\n    ) -&gt; StateSnapshot | None:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_snapshots_table(conn)\n            if version is not None:\n                cursor = await conn.execute(\n                    f\"\"\"\n                    SELECT task_id, id, version, data, checkpoint, created_at\n                    FROM {SNAPSHOTS_TABLE}\n                    WHERE task_id = ? AND version = ?\n                    \"\"\",  # nosec B608 - table name is module constant, values parameterized\n                    (task_id, version),\n                )\n                row = await cursor.fetchone()\n            else:\n                cursor = await conn.execute(\n                    f\"\"\"\n                    SELECT task_id, id, version, data, checkpoint, created_at\n                    FROM {SNAPSHOTS_TABLE}\n                    WHERE task_id = ?\n                    ORDER BY version DESC LIMIT 1\n                    \"\"\",  # nosec B608 - table name is module constant, values parameterized\n                    (task_id,),\n                )\n                row = await cursor.fetchone()\n            if row is None:\n                return None\n            return _row_to_snapshot(tuple(row))\n\n    async def _list_versions_impl(self, task_id: TaskID) -&gt; list[int]:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_snapshots_table(conn)\n            cursor = await conn.execute(\n                f\"\"\"\n                SELECT version FROM {SNAPSHOTS_TABLE}\n                WHERE task_id = ?\n                ORDER BY version\n                \"\"\",  # nosec B608 - table name is module constant, values parameterized\n                (task_id,),\n            )\n            rows = await cursor.fetchall()\n            return [r[0] for r in rows]\n\n    async def _delete_impl(\n        self,\n        task_id: TaskID,\n        version: int | None,\n    ) -&gt; bool:\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_snapshots_table(conn)\n            if version is not None:\n                cursor = await conn.execute(\n                    f\"DELETE FROM {SNAPSHOTS_TABLE} WHERE task_id = ? AND version = ?\",  # nosec B608\n                    (task_id, version),\n                )\n            else:\n                cursor = await conn.execute(\n                    f\"DELETE FROM {SNAPSHOTS_TABLE} WHERE task_id = ?\",  # nosec B608\n                    (task_id,),\n                )\n            await conn.commit()\n            return bool(cursor.rowcount) if cursor.rowcount is not None else False\n\n    def save(self, snapshot: StateSnapshot) -&gt; None:\n        \"\"\"Save a snapshot (sync wrapper).\"\"\"\n        _run_sync(self._save_impl(snapshot))\n\n    def get(\n        self,\n        task_id: TaskID,\n        version: int | None = None,\n    ) -&gt; StateSnapshot | None:\n        \"\"\"Get snapshot by task_id and optional version (sync wrapper).\"\"\"\n        return cast(StateSnapshot | None, _run_sync(self._get_impl(task_id, version)))\n\n    def list_versions(self, task_id: TaskID) -&gt; list[int]:\n        \"\"\"List versions for task (sync wrapper).\"\"\"\n        return cast(list[int], _run_sync(self._list_versions_impl(task_id)))\n\n    def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n        \"\"\"Delete snapshot(s) (sync wrapper).\"\"\"\n        return cast(bool, _run_sync(self._delete_impl(task_id, version)))\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Create tables if not exists (call from async context if needed).\"\"\"\n        async with aiosqlite.connect(self._db_path) as conn:\n            await self._ensure_snapshots_table(conn)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.__init__","title":"<code>__init__(db_path=DEFAULT_DB_PATH)</code>","text":"<p>Initialize with database file path.</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def __init__(self, db_path: str | Path = DEFAULT_DB_PATH) -&gt; None:\n    \"\"\"Initialize with database file path.\"\"\"\n    self._db_path = Path(db_path)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.delete","title":"<code>delete(task_id, version=None)</code>","text":"<p>Delete snapshot(s) (sync wrapper).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n    \"\"\"Delete snapshot(s) (sync wrapper).\"\"\"\n    return cast(bool, _run_sync(self._delete_impl(task_id, version)))\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.get","title":"<code>get(task_id, version=None)</code>","text":"<p>Get snapshot by task_id and optional version (sync wrapper).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def get(\n    self,\n    task_id: TaskID,\n    version: int | None = None,\n) -&gt; StateSnapshot | None:\n    \"\"\"Get snapshot by task_id and optional version (sync wrapper).\"\"\"\n    return cast(StateSnapshot | None, _run_sync(self._get_impl(task_id, version)))\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.initialize","title":"<code>initialize()</code>  <code>async</code>","text":"<p>Create tables if not exists (call from async context if needed).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>async def initialize(self) -&gt; None:\n    \"\"\"Create tables if not exists (call from async context if needed).\"\"\"\n    async with aiosqlite.connect(self._db_path) as conn:\n        await self._ensure_snapshots_table(conn)\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.list_versions","title":"<code>list_versions(task_id)</code>","text":"<p>List versions for task (sync wrapper).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def list_versions(self, task_id: TaskID) -&gt; list[int]:\n    \"\"\"List versions for task (sync wrapper).\"\"\"\n    return cast(list[int], _run_sync(self._list_versions_impl(task_id)))\n</code></pre>"},{"location":"api-reference/#asap.state.SQLiteSnapshotStore.save","title":"<code>save(snapshot)</code>","text":"<p>Save a snapshot (sync wrapper).</p> Source code in <code>src/asap/state/stores/sqlite.py</code> <pre><code>def save(self, snapshot: StateSnapshot) -&gt; None:\n    \"\"\"Save a snapshot (sync wrapper).\"\"\"\n    _run_sync(self._save_impl(snapshot))\n</code></pre>"},{"location":"api-reference/#asap.state.SnapshotStore","title":"<code>SnapshotStore</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for snapshot storage implementations.</p> <p>Provides the interface for storing and retrieving task state snapshots. Implementations can use various backends (memory, database, file system, etc.). This uses Protocol for duck typing, allowing any class that implements these methods to be used as a SnapshotStore.</p> Example <p>class CustomStore: ...     def save(self, snapshot: StateSnapshot) -&gt; None: ...         pass ...     def get(self, task_id: TaskID, version: int | None = None) -&gt; StateSnapshot | None: ...         return None ...     def list_versions(self, task_id: TaskID) -&gt; list[int]: ...         return [] ...     def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool: ...         return False isinstance(CustomStore(), SnapshotStore) True</p> Source code in <code>src/asap/state/snapshot.py</code> <pre><code>@runtime_checkable\nclass SnapshotStore(Protocol):\n    \"\"\"Protocol for snapshot storage implementations.\n\n    Provides the interface for storing and retrieving task state snapshots.\n    Implementations can use various backends (memory, database, file system, etc.).\n    This uses Protocol for duck typing, allowing any class that implements\n    these methods to be used as a SnapshotStore.\n\n    Example:\n        &gt;&gt;&gt; class CustomStore:\n        ...     def save(self, snapshot: StateSnapshot) -&gt; None:\n        ...         pass\n        ...     def get(self, task_id: TaskID, version: int | None = None) -&gt; StateSnapshot | None:\n        ...         return None\n        ...     def list_versions(self, task_id: TaskID) -&gt; list[int]:\n        ...         return []\n        ...     def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n        ...         return False\n        &gt;&gt;&gt; isinstance(CustomStore(), SnapshotStore)\n        True\n    \"\"\"\n\n    def save(self, snapshot: StateSnapshot) -&gt; None:\n        \"\"\"Save a snapshot to the store.\n\n        Args:\n            snapshot: The snapshot to save\n\n        Example:\n            &gt;&gt;&gt; from datetime import datetime, timezone\n            &gt;&gt;&gt; store = InMemorySnapshotStore()\n            &gt;&gt;&gt; snapshot = StateSnapshot(\n            ...     id=\"snap_01HX5K7R...\",\n            ...     task_id=\"task_01HX5K4N...\",\n            ...     version=1,\n            ...     data={\"status\": \"submitted\"},\n            ...     created_at=datetime.now(timezone.utc),\n            ... )\n            &gt;&gt;&gt; store.save(snapshot)\n        \"\"\"\n        ...\n\n    def get(self, task_id: TaskID, version: int | None = None) -&gt; StateSnapshot | None:\n        \"\"\"Retrieve a snapshot for the given task.\n\n        Args:\n            task_id: The task ID to retrieve snapshots for\n            version: Optional specific version to retrieve. If None, returns latest.\n\n        Returns:\n            The snapshot if found, None otherwise\n\n        Example:\n            &gt;&gt;&gt; store = InMemorySnapshotStore()\n            &gt;&gt;&gt; store.get(\"task_01HX5K4N...\")\n            None\n        \"\"\"\n        ...\n\n    def list_versions(self, task_id: TaskID) -&gt; list[int]:\n        \"\"\"List all available versions for a task.\n\n        Args:\n            task_id: The task ID to list versions for\n\n        Returns:\n            List of version numbers in ascending order\n\n        Example:\n            &gt;&gt;&gt; store = InMemorySnapshotStore()\n            &gt;&gt;&gt; store.list_versions(\"task_01HX5K4N...\")\n            []\n        \"\"\"\n        ...\n\n    def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n        \"\"\"Delete snapshot(s) for a task.\n\n        Args:\n            task_id: The task ID\n            version: If provided, delete only this version. Otherwise delete all.\n\n        Returns:\n            True if any snapshots were deleted, False otherwise\n\n        Example:\n            &gt;&gt;&gt; store = InMemorySnapshotStore()\n            &gt;&gt;&gt; store.delete(\"task_01HX5K4N...\")\n            False\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/#asap.state.SnapshotStore.delete","title":"<code>delete(task_id, version=None)</code>","text":"<p>Delete snapshot(s) for a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskID</code> <p>The task ID</p> required <code>version</code> <code>int | None</code> <p>If provided, delete only this version. Otherwise delete all.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if any snapshots were deleted, False otherwise</p> Example <p>store = InMemorySnapshotStore() store.delete(\"task_01HX5K4N...\") False</p> Source code in <code>src/asap/state/snapshot.py</code> <pre><code>def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n    \"\"\"Delete snapshot(s) for a task.\n\n    Args:\n        task_id: The task ID\n        version: If provided, delete only this version. Otherwise delete all.\n\n    Returns:\n        True if any snapshots were deleted, False otherwise\n\n    Example:\n        &gt;&gt;&gt; store = InMemorySnapshotStore()\n        &gt;&gt;&gt; store.delete(\"task_01HX5K4N...\")\n        False\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.SnapshotStore.get","title":"<code>get(task_id, version=None)</code>","text":"<p>Retrieve a snapshot for the given task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskID</code> <p>The task ID to retrieve snapshots for</p> required <code>version</code> <code>int | None</code> <p>Optional specific version to retrieve. If None, returns latest.</p> <code>None</code> <p>Returns:</p> Type Description <code>StateSnapshot | None</code> <p>The snapshot if found, None otherwise</p> Example <p>store = InMemorySnapshotStore() store.get(\"task_01HX5K4N...\") None</p> Source code in <code>src/asap/state/snapshot.py</code> <pre><code>def get(self, task_id: TaskID, version: int | None = None) -&gt; StateSnapshot | None:\n    \"\"\"Retrieve a snapshot for the given task.\n\n    Args:\n        task_id: The task ID to retrieve snapshots for\n        version: Optional specific version to retrieve. If None, returns latest.\n\n    Returns:\n        The snapshot if found, None otherwise\n\n    Example:\n        &gt;&gt;&gt; store = InMemorySnapshotStore()\n        &gt;&gt;&gt; store.get(\"task_01HX5K4N...\")\n        None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.SnapshotStore.list_versions","title":"<code>list_versions(task_id)</code>","text":"<p>List all available versions for a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskID</code> <p>The task ID to list versions for</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>List of version numbers in ascending order</p> Example <p>store = InMemorySnapshotStore() store.list_versions(\"task_01HX5K4N...\") []</p> Source code in <code>src/asap/state/snapshot.py</code> <pre><code>def list_versions(self, task_id: TaskID) -&gt; list[int]:\n    \"\"\"List all available versions for a task.\n\n    Args:\n        task_id: The task ID to list versions for\n\n    Returns:\n        List of version numbers in ascending order\n\n    Example:\n        &gt;&gt;&gt; store = InMemorySnapshotStore()\n        &gt;&gt;&gt; store.list_versions(\"task_01HX5K4N...\")\n        []\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.SnapshotStore.save","title":"<code>save(snapshot)</code>","text":"<p>Save a snapshot to the store.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>StateSnapshot</code> <p>The snapshot to save</p> required Example <p>from datetime import datetime, timezone store = InMemorySnapshotStore() snapshot = StateSnapshot( ...     id=\"snap_01HX5K7R...\", ...     task_id=\"task_01HX5K4N...\", ...     version=1, ...     data={\"status\": \"submitted\"}, ...     created_at=datetime.now(timezone.utc), ... ) store.save(snapshot)</p> Source code in <code>src/asap/state/snapshot.py</code> <pre><code>def save(self, snapshot: StateSnapshot) -&gt; None:\n    \"\"\"Save a snapshot to the store.\n\n    Args:\n        snapshot: The snapshot to save\n\n    Example:\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; store = InMemorySnapshotStore()\n        &gt;&gt;&gt; snapshot = StateSnapshot(\n        ...     id=\"snap_01HX5K7R...\",\n        ...     task_id=\"task_01HX5K4N...\",\n        ...     version=1,\n        ...     data={\"status\": \"submitted\"},\n        ...     created_at=datetime.now(timezone.utc),\n        ... )\n        &gt;&gt;&gt; store.save(snapshot)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#asap.state.TaskStatus","title":"<code>TaskStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Task lifecycle states.</p> <p>Tasks progress through these states during their lifecycle. Terminal states are: COMPLETED, FAILED, CANCELLED.</p> Example <p>TaskStatus.COMPLETED.is_terminal() True TaskStatus.WORKING.is_terminal() False</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>class TaskStatus(str, Enum):\n    \"\"\"Task lifecycle states.\n\n    Tasks progress through these states during their lifecycle.\n    Terminal states are: COMPLETED, FAILED, CANCELLED.\n\n    Example:\n        &gt;&gt;&gt; TaskStatus.COMPLETED.is_terminal()\n        True\n        &gt;&gt;&gt; TaskStatus.WORKING.is_terminal()\n        False\n    \"\"\"\n\n    SUBMITTED = \"submitted\"\n    WORKING = \"working\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    INPUT_REQUIRED = \"input_required\"\n\n    @classmethod\n    def terminal_states(cls) -&gt; frozenset[\"TaskStatus\"]:\n        \"\"\"Return all terminal states.\n\n        Returns:\n            Frozen set containing all terminal task states\n        \"\"\"\n        return frozenset({cls.COMPLETED, cls.FAILED, cls.CANCELLED})\n\n    def is_terminal(self) -&gt; bool:\n        \"\"\"Check if this status represents a terminal state.\"\"\"\n        return self in self.terminal_states()\n</code></pre>"},{"location":"api-reference/#asap.state.TaskStatus.is_terminal","title":"<code>is_terminal()</code>","text":"<p>Check if this status represents a terminal state.</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>def is_terminal(self) -&gt; bool:\n    \"\"\"Check if this status represents a terminal state.\"\"\"\n    return self in self.terminal_states()\n</code></pre>"},{"location":"api-reference/#asap.state.TaskStatus.terminal_states","title":"<code>terminal_states()</code>  <code>classmethod</code>","text":"<p>Return all terminal states.</p> <p>Returns:</p> Type Description <code>frozenset[TaskStatus]</code> <p>Frozen set containing all terminal task states</p> Source code in <code>src/asap/models/enums.py</code> <pre><code>@classmethod\ndef terminal_states(cls) -&gt; frozenset[\"TaskStatus\"]:\n    \"\"\"Return all terminal states.\n\n    Returns:\n        Frozen set containing all terminal task states\n    \"\"\"\n    return frozenset({cls.COMPLETED, cls.FAILED, cls.CANCELLED})\n</code></pre>"},{"location":"api-reference/#asap.state.UsageAggregate","title":"<code>UsageAggregate</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Aggregated usage for an agent over a period.</p> <p>Attributes:</p> Name Type Description <code>agent_id</code> <code>str</code> <p>Agent identifier.</p> <code>period</code> <code>str</code> <p>Aggregation period (e.g. 'hour', 'day').</p> <code>total_tokens</code> <code>int</code> <p>Sum of input + output tokens.</p> <code>total_duration</code> <code>int</code> <p>Total duration in milliseconds.</p> <code>total_tasks</code> <code>int</code> <p>Number of tasks.</p> <code>total_api_calls</code> <code>int</code> <p>Total API calls.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>class UsageAggregate(ASAPBaseModel):\n    \"\"\"Aggregated usage for an agent over a period.\n\n    Attributes:\n        agent_id: Agent identifier.\n        period: Aggregation period (e.g. 'hour', 'day').\n        total_tokens: Sum of input + output tokens.\n        total_duration: Total duration in milliseconds.\n        total_tasks: Number of tasks.\n        total_api_calls: Total API calls.\n    \"\"\"\n\n    agent_id: str = Field(..., description=\"Agent identifier\")\n    period: str = Field(..., description=\"Aggregation period (e.g. hour, day)\")\n    total_tokens: int = Field(default=0, ge=0, description=\"Sum of tokens (in + out)\")\n    total_duration: int = Field(default=0, ge=0, description=\"Total duration in ms\")\n    total_tasks: int = Field(default=0, ge=0, description=\"Number of tasks\")\n    total_api_calls: int = Field(default=0, ge=0, description=\"Total API calls\")\n</code></pre>"},{"location":"api-reference/#asap.state.UsageEvent","title":"<code>UsageEvent</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>A single usage event for metering (v1.3 foundation).</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>Task identifier.</p> <code>agent_id</code> <code>str</code> <p>Agent that produced the usage.</p> <code>consumer_id</code> <code>str</code> <p>Consumer (caller) identifier.</p> <code>metrics</code> <code>UsageMetrics</code> <p>Token, duration and API call metrics.</p> <code>timestamp</code> <code>datetime</code> <p>When the event occurred (UTC).</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>class UsageEvent(ASAPBaseModel):\n    \"\"\"A single usage event for metering (v1.3 foundation).\n\n    Attributes:\n        task_id: Task identifier.\n        agent_id: Agent that produced the usage.\n        consumer_id: Consumer (caller) identifier.\n        metrics: Token, duration and API call metrics.\n        timestamp: When the event occurred (UTC).\n    \"\"\"\n\n    task_id: str = Field(..., description=\"Task identifier\")\n    agent_id: str = Field(..., description=\"Agent that produced the usage\")\n    consumer_id: str = Field(..., description=\"Consumer (caller) identifier\")\n    metrics: UsageMetrics = Field(\n        default_factory=UsageMetrics,\n        description=\"Token, duration and API call metrics\",\n    )\n    timestamp: datetime = Field(..., description=\"Event timestamp (UTC)\")\n</code></pre>"},{"location":"api-reference/#asap.state.UsageMetrics","title":"<code>UsageMetrics</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>Metrics for a single usage event (tokens, duration, API calls).</p> <p>Attributes:</p> Name Type Description <code>tokens_in</code> <code>int</code> <p>Input token count.</p> <code>tokens_out</code> <code>int</code> <p>Output token count.</p> <code>duration_ms</code> <code>int</code> <p>Duration in milliseconds.</p> <code>api_calls</code> <code>int</code> <p>Number of API calls.</p> Source code in <code>src/asap/state/metering.py</code> <pre><code>class UsageMetrics(ASAPBaseModel):\n    \"\"\"Metrics for a single usage event (tokens, duration, API calls).\n\n    Attributes:\n        tokens_in: Input token count.\n        tokens_out: Output token count.\n        duration_ms: Duration in milliseconds.\n        api_calls: Number of API calls.\n    \"\"\"\n\n    tokens_in: int = Field(default=0, ge=0, description=\"Input token count\")\n    tokens_out: int = Field(default=0, ge=0, description=\"Output token count\")\n    duration_ms: int = Field(default=0, ge=0, description=\"Duration in milliseconds\")\n    api_calls: int = Field(default=0, ge=0, description=\"Number of API calls\")\n</code></pre>"},{"location":"api-reference/#asap.state.can_transition","title":"<code>can_transition(from_status, to_status)</code>","text":"<p>Check if a transition from one status to another is valid.</p> <p>Parameters:</p> Name Type Description Default <code>from_status</code> <code>TaskStatus</code> <p>Current task status</p> required <code>to_status</code> <code>TaskStatus</code> <p>Target task status</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the transition is valid, False otherwise</p> Example <p>can_transition(TaskStatus.SUBMITTED, TaskStatus.WORKING) True can_transition(TaskStatus.COMPLETED, TaskStatus.WORKING) False</p> Source code in <code>src/asap/state/machine.py</code> <pre><code>def can_transition(from_status: TaskStatus, to_status: TaskStatus) -&gt; bool:\n    \"\"\"Check if a transition from one status to another is valid.\n\n    Args:\n        from_status: Current task status\n        to_status: Target task status\n\n    Returns:\n        True if the transition is valid, False otherwise\n\n    Example:\n        &gt;&gt;&gt; can_transition(TaskStatus.SUBMITTED, TaskStatus.WORKING)\n        True\n        &gt;&gt;&gt; can_transition(TaskStatus.COMPLETED, TaskStatus.WORKING)\n        False\n    \"\"\"\n    valid_targets = VALID_TRANSITIONS.get(from_status, set())\n    return to_status in valid_targets\n</code></pre>"},{"location":"api-reference/#asap.state.create_snapshot_store","title":"<code>create_snapshot_store()</code>","text":"<p>Create a SnapshotStore from environment.</p> <p>Reads ASAP_STORAGE_BACKEND (default \"memory\") and ASAP_STORAGE_PATH (default \"asap_state.db\" for sqlite). Use \"memory\" for tests and \"sqlite\" for persistent state.</p> <p>Returns:</p> Type Description <code>SnapshotStore</code> <p>Configured SnapshotStore instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ASAP_STORAGE_BACKEND is not \"memory\" or \"sqlite\".</p> Source code in <code>src/asap/state/stores/__init__.py</code> <pre><code>def create_snapshot_store() -&gt; SnapshotStore:\n    \"\"\"Create a SnapshotStore from environment.\n\n    Reads ASAP_STORAGE_BACKEND (default \"memory\") and ASAP_STORAGE_PATH\n    (default \"asap_state.db\" for sqlite). Use \"memory\" for tests and\n    \"sqlite\" for persistent state.\n\n    Returns:\n        Configured SnapshotStore instance.\n\n    Raises:\n        ValueError: If ASAP_STORAGE_BACKEND is not \"memory\" or \"sqlite\".\n    \"\"\"\n    backend = os.environ.get(ASAP_STORAGE_BACKEND_ENV, \"memory\").strip().lower()\n    path = os.environ.get(ASAP_STORAGE_PATH_ENV, DEFAULT_DB_PATH).strip()\n\n    if backend == \"memory\":\n        return InMemorySnapshotStore()\n    if backend == \"sqlite\":\n        return SQLiteSnapshotStore(db_path=Path(path))\n    raise ValueError(f\"Unknown {ASAP_STORAGE_BACKEND_ENV}={backend!r}. Use 'memory' or 'sqlite'.\")\n</code></pre>"},{"location":"api-reference/#asap.state.transition","title":"<code>transition(task, new_status)</code>","text":"<p>Transition a task to a new status with validation.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>The task to transition</p> required <code>new_status</code> <code>TaskStatus</code> <p>The target status</p> required <p>Returns:</p> Type Description <code>Task</code> <p>New task instance with updated status and updated_at timestamp</p> <p>Raises:</p> Type Description <code>InvalidTransitionError</code> <p>If the transition is not valid</p> Example <p>task = Task( ...     id=\"task_01HX5K4N...\", ...     conversation_id=\"conv_01HX5K3M...\", ...     status=TaskStatus.SUBMITTED, ...     created_at=datetime.now(timezone.utc), ...     updated_at=datetime.now(timezone.utc), ... ) updated = transition(task, TaskStatus.WORKING) updated.status  Source code in <code>src/asap/state/machine.py</code> <pre><code>def transition(task: Task, new_status: TaskStatus) -&gt; Task:\n    \"\"\"Transition a task to a new status with validation.\n\n    Args:\n        task: The task to transition\n        new_status: The target status\n\n    Returns:\n        New task instance with updated status and updated_at timestamp\n\n    Raises:\n        InvalidTransitionError: If the transition is not valid\n\n    Example:\n        &gt;&gt;&gt; task = Task(\n        ...     id=\"task_01HX5K4N...\",\n        ...     conversation_id=\"conv_01HX5K3M...\",\n        ...     status=TaskStatus.SUBMITTED,\n        ...     created_at=datetime.now(timezone.utc),\n        ...     updated_at=datetime.now(timezone.utc),\n        ... )\n        &gt;&gt;&gt; updated = transition(task, TaskStatus.WORKING)\n        &gt;&gt;&gt; updated.status\n        &lt;TaskStatus.WORKING: 'working'&gt;\n    \"\"\"\n    if not can_transition(task.status, new_status):\n        raise InvalidTransitionError(\n            from_state=task.status.value, to_state=new_status.value, details={\"task_id\": task.id}\n        )\n\n    with state_transition_span_context(\n        from_status=task.status.value,\n        to_status=new_status.value,\n        task_id=task.id,\n    ):\n        get_metrics().increment_counter(\n            \"asap_state_transitions_total\",\n            {\"from_status\": task.status.value, \"to_status\": new_status.value},\n        )\n        return task.model_copy(\n            update={\"status\": new_status, \"updated_at\": datetime.now(timezone.utc)}\n        )\n</code></pre>"},{"location":"api-reference/#transport","title":"Transport","text":""},{"location":"api-reference/#asap.transport","title":"<code>asap.transport</code>","text":"<p>ASAP Protocol HTTP Transport Layer.</p> <p>This module provides HTTP-based transport for ASAP messages using: - JSON-RPC 2.0 for request/response wrapping - FastAPI for server implementation - httpx for async client implementation - Handler registry for payload dispatch</p> Public exports <p>JsonRpcRequest: JSON-RPC 2.0 request wrapper JsonRpcResponse: JSON-RPC 2.0 response wrapper JsonRpcError: JSON-RPC 2.0 error object JsonRpcErrorResponse: JSON-RPC 2.0 error response wrapper create_app: FastAPI application factory HandlerRegistry: Registry for payload handlers HandlerNotFoundError: Error for missing handlers Handler: Type alias for handler functions create_echo_handler: Factory for echo handler create_default_registry: Factory for default registry ASAPClient: Async HTTP client for agent communication RetryConfig: Configuration dataclass for retry logic and circuit breaker ASAPConnectionError: Connection error exception ASAPTimeoutError: Timeout error exception ASAPRemoteError: Remote error exception</p> Example <p>from asap.transport import ASAPClient, create_app from asap.models.entities import Manifest, Capability, Endpoint, Skill manifest = Manifest( ...     id=\"urn:asap:agent:demo\", ...     name=\"Demo Agent\", ...     version=\"1.0.0\", ...     description=\"Demo manifest\", ...     capabilities=Capability( ...         asap_version=\"0.1\", ...         skills=[Skill(id=\"echo\", description=\"Echo\")], ...         state_persistence=False, ...     ), ...     endpoints=Endpoint(asap=\"http://localhost:8000/asap\"), ... ) app = create_app(manifest)</p>"},{"location":"api-reference/#asap.transport.DEFAULT_MAX_RETRIES","title":"<code>DEFAULT_MAX_RETRIES = 5</code>  <code>module-attribute</code>","text":"<p>Maximum number of retry attempts before sending to the DLQ.</p>"},{"location":"api-reference/#asap.transport.DEFAULT_RETRY_BASE_DELAY","title":"<code>DEFAULT_RETRY_BASE_DELAY = 1.0</code>  <code>module-attribute</code>","text":"<p>Base delay in seconds for exponential backoff (1s \u2192 2s \u2192 4s \u2192 8s \u2192 16s).</p>"},{"location":"api-reference/#asap.transport.DEFAULT_RETRY_MAX_DELAY","title":"<code>DEFAULT_RETRY_MAX_DELAY = 16.0</code>  <code>module-attribute</code>","text":"<p>Maximum delay cap in seconds for exponential backoff.</p>"},{"location":"api-reference/#asap.transport.DEFAULT_WEBHOOK_RATE_PER_SECOND","title":"<code>DEFAULT_WEBHOOK_RATE_PER_SECOND = 10.0</code>  <code>module-attribute</code>","text":"<p>Default per-URL webhook delivery rate (token bucket).</p>"},{"location":"api-reference/#asap.transport.ASAPClient","title":"<code>ASAPClient</code>","text":"<p>Async HTTP client for ASAP protocol communication.</p> <p>ASAPClient manages HTTP connections to remote ASAP agents and provides methods for sending envelopes and receiving responses.</p> <p>Use as async context manager: Always use <code>async with ASAPClient(...) as client</code> to ensure the underlying HTTP client is started and closed properly. Using the client without the context manager may leave connections open.</p> Features <ul> <li>HTTP/2 multiplexing (enabled by default) for improved batch performance</li> <li>Connection pooling supporting 1000+ concurrent requests</li> <li>Automatic retry with exponential backoff</li> <li>Circuit breaker pattern for fault tolerance</li> <li>Batch operations via send_batch() method (HTTP only; WebSocket transport   raises NotImplementedError)</li> <li>Compression support (gzip/brotli) for bandwidth reduction</li> </ul> <p>Attributes:</p> Name Type Description <code>base_url</code> <p>Base URL of the remote agent</p> <code>timeout</code> <p>Request timeout in seconds</p> <code>max_retries</code> <p>Maximum retry attempts for transient failures</p> <code>require_https</code> <p>Whether HTTPS is required for non-localhost connections</p> <code>is_connected</code> <code>bool</code> <p>Whether the client has an active connection</p> <code>compression</code> <code>bool</code> <p>Whether compression is enabled for requests</p> <code>compression_threshold</code> <code>bool</code> <p>Minimum payload size to trigger compression</p> <code>_circuit_breaker</code> <code>Optional[CircuitBreaker]</code> <p>Optional circuit breaker instance</p> <p>Pool sizing (pool_connections / pool_maxsize):     Single-agent: 100 (default). Small cluster: 200\u2013500. Large cluster: 500\u20131000.     Supports 1000+ concurrent requests via connection reuse when pool_maxsize &lt; concurrency.</p> <p>HTTP/2 Multiplexing:     HTTP/2 is enabled by default (http2=True) and provides request multiplexing over     a single TCP connection, reducing latency for batch operations. If the server     doesn't support HTTP/2, the client automatically falls back to HTTP/1.1.</p> Compression <p>Compression is enabled by default (compression=True) for payloads exceeding 1KB. Supports gzip (standard) and brotli (optional, requires brotli package). Brotli provides ~20% better compression than gzip for JSON payloads.</p> Example <p>async with ASAPClient(\"http://localhost:8000\") as client: ...     response = await client.send(envelope)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>class ASAPClient:\n    \"\"\"Async HTTP client for ASAP protocol communication.\n\n    ASAPClient manages HTTP connections to remote ASAP agents and provides\n    methods for sending envelopes and receiving responses.\n\n    **Use as async context manager:** Always use ``async with ASAPClient(...) as client``\n    to ensure the underlying HTTP client is started and closed properly. Using the\n    client without the context manager may leave connections open.\n\n    Features:\n        - HTTP/2 multiplexing (enabled by default) for improved batch performance\n        - Connection pooling supporting 1000+ concurrent requests\n        - Automatic retry with exponential backoff\n        - Circuit breaker pattern for fault tolerance\n        - Batch operations via send_batch() method (HTTP only; WebSocket transport\n          raises NotImplementedError)\n        - Compression support (gzip/brotli) for bandwidth reduction\n\n    Attributes:\n        base_url: Base URL of the remote agent\n        timeout: Request timeout in seconds\n        max_retries: Maximum retry attempts for transient failures\n        require_https: Whether HTTPS is required for non-localhost connections\n        is_connected: Whether the client has an active connection\n        compression: Whether compression is enabled for requests\n        compression_threshold: Minimum payload size to trigger compression\n        _circuit_breaker: Optional circuit breaker instance\n\n    Pool sizing (pool_connections / pool_maxsize):\n        Single-agent: 100 (default). Small cluster: 200\u2013500. Large cluster: 500\u20131000.\n        Supports 1000+ concurrent requests via connection reuse when pool_maxsize &lt; concurrency.\n\n    HTTP/2 Multiplexing:\n        HTTP/2 is enabled by default (http2=True) and provides request multiplexing over\n        a single TCP connection, reducing latency for batch operations. If the server\n        doesn't support HTTP/2, the client automatically falls back to HTTP/1.1.\n\n    Compression:\n        Compression is enabled by default (compression=True) for payloads exceeding\n        1KB. Supports gzip (standard) and brotli (optional, requires brotli package).\n        Brotli provides ~20% better compression than gzip for JSON payloads.\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     response = await client.send(envelope)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Batch operations with HTTP/2 multiplexing\n        &gt;&gt;&gt; async with ASAPClient(\"https://agent.example.com\") as client:\n        ...     responses = await client.send_batch([env1, env2, env3])\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Disable compression for specific client\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\", compression=False) as client:\n        ...     response = await client.send(envelope)  # No compression\n    \"\"\"\n\n    _circuit_breaker: Optional[CircuitBreaker]\n\n    def __init__(\n        self,\n        base_url: str,\n        timeout: float = DEFAULT_TIMEOUT,\n        transport_mode: Literal[\"http\", \"websocket\", \"auto\"] = \"auto\",\n        transport: httpx.AsyncBaseTransport | None = None,\n        require_https: bool = True,\n        retry_config: Optional[RetryConfig] = None,\n        # Connection pool (httpx.Limits); enables 1000+ concurrent via reuse\n        pool_connections: int | None = None,\n        pool_maxsize: int | None = None,\n        pool_timeout: float | None = None,\n        # HTTP/2 multiplexing for improved batch performance\n        http2: bool = True,\n        # Compression settings for bandwidth reduction\n        compression: bool = True,\n        compression_threshold: int = COMPRESSION_THRESHOLD,\n        # Individual retry parameters (for backward compatibility)\n        # If retry_config is provided, these are ignored\n        max_retries: int | None = None,\n        base_delay: float | None = None,\n        max_delay: float | None = None,\n        jitter: bool | None = None,\n        circuit_breaker_enabled: bool | None = None,\n        circuit_breaker_threshold: int | None = None,\n        circuit_breaker_timeout: float | None = None,\n        manifest_cache_size: int | None = None,\n        verify_signatures: bool = False,\n        trusted_manifest_keys: Optional[Mapping[str, str]] = None,\n        on_message: Optional[OnMessageCallback] = None,\n        mtls_config: Optional[MTLSConfig] = None,\n    ) -&gt; None:\n        # Extract retry config values\n        if retry_config is not None:\n            # Use retry_config values\n            max_retries_val = retry_config.max_retries\n            base_delay_val = retry_config.base_delay\n            max_delay_val = retry_config.max_delay\n            jitter_val = retry_config.jitter\n            circuit_breaker_enabled_val = retry_config.circuit_breaker_enabled\n            circuit_breaker_threshold_val = retry_config.circuit_breaker_threshold\n            circuit_breaker_timeout_val = retry_config.circuit_breaker_timeout\n        else:\n            # Use individual parameters with defaults\n            max_retries_val = max_retries if max_retries is not None else DEFAULT_MAX_RETRIES\n            base_delay_val = base_delay if base_delay is not None else DEFAULT_BASE_DELAY\n            max_delay_val = max_delay if max_delay is not None else DEFAULT_MAX_DELAY\n            jitter_val = jitter if jitter is not None else True\n            circuit_breaker_enabled_val = (\n                circuit_breaker_enabled if circuit_breaker_enabled is not None else False\n            )\n            circuit_breaker_threshold_val = (\n                circuit_breaker_threshold\n                if circuit_breaker_threshold is not None\n                else DEFAULT_CIRCUIT_BREAKER_THRESHOLD\n            )\n            circuit_breaker_timeout_val = (\n                circuit_breaker_timeout\n                if circuit_breaker_timeout is not None\n                else DEFAULT_CIRCUIT_BREAKER_TIMEOUT\n            )\n        parsed = urlparse(base_url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\n                f\"Invalid base_url format: {base_url}. Must be a valid URL (e.g., http://localhost:8000)\"\n            )\n\n        scheme_lower = parsed.scheme.lower()\n        allowed_schemes = (\n            (\"http\", \"https\", \"ws\", \"wss\")\n            if transport_mode in (\"websocket\", \"auto\")\n            else (\"http\", \"https\")\n        )\n        if scheme_lower not in allowed_schemes:\n            raise ValueError(\n                f\"Invalid URL scheme: {parsed.scheme}. Allowed: {', '.join(allowed_schemes)}. \"\n                f\"Received: {base_url}\"\n            )\n\n        use_websocket = transport_mode == \"websocket\" or (\n            transport_mode == \"auto\" and scheme_lower in (\"ws\", \"wss\")\n        )\n        if use_websocket:\n            ws_url = base_url.rstrip(\"/\")\n            if scheme_lower in (\"http\", \"https\"):\n                ws_scheme = \"wss\" if scheme_lower == \"https\" else \"ws\"\n                ws_netloc = parsed.netloc\n                ws_path = (parsed.path or \"/\").rstrip(\"/\") + \"/asap/ws\"\n                ws_url = urlunparse((ws_scheme, ws_netloc, ws_path, \"\", \"\", \"\"))\n            elif not ws_url.endswith(\"/asap/ws\"):\n                ws_url = ws_url.rstrip(\"/\") + \"/asap/ws\"\n        else:\n            ws_url = \"\"\n\n        is_https = scheme_lower in (\"https\", \"wss\")\n        is_local = self._is_localhost(parsed)\n\n        if require_https and not is_https:\n            if is_local:\n                # Allow unencrypted transport for localhost with warning\n                logger.warning(\n                    \"asap.client.http_localhost\",\n                    url=base_url,\n                    message=(\n                        \"Using unencrypted transport for localhost connection. \"\n                        \"For production, use HTTPS. \"\n                        \"To disable this warning, set require_https=False.\"\n                    ),\n                )\n            else:\n                # Reject unencrypted transport for non-localhost\n                raise ValueError(\n                    f\"Encrypted transport (https/wss) is required for non-localhost connections. \"\n                    f\"Received: {base_url}. \"\n                    f\"Please use HTTPS/WSS or set require_https=False to override \"\n                    f\"(not recommended for production).\"\n                )\n\n        self.base_url = base_url.rstrip(\"/\")\n        self._use_websocket = use_websocket\n        self._ws_url = ws_url\n        if use_websocket:\n            if scheme_lower in (\"ws\", \"wss\"):\n                http_scheme = \"https\" if scheme_lower == \"wss\" else \"http\"\n                path = (parsed.path or \"/\").replace(\"/asap/ws\", \"\").rstrip(\"/\") or \"/\"\n                self._http_base_url = urlunparse((http_scheme, parsed.netloc, path, \"\", \"\", \"\"))\n            else:\n                self._http_base_url = self.base_url\n        else:\n            self._http_base_url = self.base_url\n        self.timeout = timeout\n        self._pool_connections = (\n            pool_connections if pool_connections is not None else DEFAULT_POOL_CONNECTIONS\n        )\n        self._pool_maxsize = pool_maxsize if pool_maxsize is not None else DEFAULT_POOL_MAXSIZE\n        self._pool_timeout = pool_timeout if pool_timeout is not None else DEFAULT_POOL_TIMEOUT\n        self.max_retries = max_retries_val\n        self.require_https = require_https\n        self.base_delay = base_delay_val\n        self.max_delay = max_delay_val\n        self.jitter = jitter_val\n        self.circuit_breaker_enabled = circuit_breaker_enabled_val\n        self._transport = transport\n        self._http2 = http2\n        self._compression = compression\n        self._compression_threshold = compression_threshold\n        self._on_message = on_message\n        self._client: httpx.AsyncClient | None = None\n        self._ws_transport: WebSocketTransport | None = None\n        # Thread-safe counter using itertools.count\n        self._request_counter = itertools.count(1)\n\n        # Initialize circuit breaker if enabled\n        # Use registry to ensure state is shared across multiple client instances\n        # for the same base_url\n        if circuit_breaker_enabled_val:\n            registry = get_registry()\n            self._circuit_breaker = registry.get_or_create(\n                base_url=sanitize_url(self.base_url),\n                threshold=circuit_breaker_threshold_val,\n                timeout=circuit_breaker_timeout_val,\n            )\n        else:\n            self._circuit_breaker = None\n\n        # Per-client manifest cache (not shared like circuit breaker).\n        cache_max = manifest_cache_size if manifest_cache_size is not None else DEFAULT_MAX_SIZE\n        self._manifest_cache = ManifestCache(max_size=cache_max)\n        self._manifest_fetch_locks: dict[str, asyncio.Lock] = {}\n        self._manifest_fetch_locks_guard = threading.Lock()\n        self._verify_signatures = verify_signatures\n        self._trusted_manifest_keys = dict(trusted_manifest_keys) if trusted_manifest_keys else {}\n        self._mtls_config = mtls_config\n\n    @staticmethod\n    def _is_localhost(parsed_url: ParseResult) -&gt; bool:\n        hostname = parsed_url.hostname\n        if not hostname:\n            return False\n\n        hostname_lower = hostname.lower()\n        # Handle both ::1 and [::1] (bracket notation from URL parsing)\n        return hostname_lower in (\"localhost\", \"127.0.0.1\", \"::1\", \"[::1]\")\n\n    def _calculate_backoff(self, attempt: int) -&gt; float:\n        # Calculate exponential delay: base_delay * (2 ** attempt)\n        delay = self.base_delay * (2**attempt)\n\n        # Cap at max_delay\n        delay = min(delay, self.max_delay)\n\n        if self.jitter:\n            jitter_amount: float = random.uniform(0, delay * 0.1)  # nosec B311\n            delay += jitter_amount\n\n        return float(delay)\n\n    async def _validate_connection(self) -&gt; bool:\n        \"\"\"Validate that the agent endpoint is accessible.\n\n        Performs a pre-flight check by attempting to access the agent's\n        manifest endpoint. This can be used to detect connection issues\n        before sending actual requests.\n\n        Note: This is an optional validation step that can be disabled\n        for performance reasons in production environments.\n\n        Returns:\n            True if connection is valid, False otherwise\n\n        Raises:\n            ASAPConnectionError: If connection validation fails\n        \"\"\"\n        if not self._client:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(self.base_url),\n            )\n\n        try:\n            # Try to access a lightweight endpoint (manifest or health check)\n            # Using HEAD request to minimize bandwidth\n            response = await self._client.head(\n                f\"{self._http_base_url}/.well-known/asap/manifest.json\",\n                timeout=min(self.timeout, 5.0),  # Shorter timeout for validation\n            )\n            # Any 2xx or 3xx response indicates the server is reachable\n            is_valid = 200 &lt;= response.status_code &lt; 400\n            if not is_valid:\n                logger.warning(\n                    \"asap.client.connection_validation_failed\",\n                    target_url=sanitize_url(self.base_url),\n                    status_code=response.status_code,\n                    message=(\n                        f\"Connection validation failed for {self.base_url}. \"\n                        f\"Server returned status {response.status_code}. \"\n                        f\"Verify the agent is running and the URL is correct.\"\n                    ),\n                )\n            return is_valid\n        except httpx.ConnectError as e:\n            logger.warning(\n                \"asap.client.connection_validation_failed\",\n                target_url=sanitize_url(self.base_url),\n                error=str(e),\n                message=(\n                    f\"Connection validation failed for {self.base_url}. \"\n                    f\"Cannot reach the agent. Verify the agent is running and accessible. \"\n                    f\"Error: {str(e)[:200]}\"\n                ),\n            )\n            return False\n        except httpx.TimeoutException:\n            logger.warning(\n                \"asap.client.connection_validation_timeout\",\n                target_url=sanitize_url(self.base_url),\n                timeout=self.timeout,\n                message=(\n                    f\"Connection validation timed out for {self.base_url}. \"\n                    f\"Check network connectivity and firewall settings.\"\n                ),\n            )\n            return False\n        except Exception as e:\n            logger.warning(\n                \"asap.client.connection_validation_error\",\n                target_url=sanitize_url(self.base_url),\n                error=str(e),\n                error_type=type(e).__name__,\n                message=(\n                    f\"Connection validation encountered an error for {self.base_url}: {e}. \"\n                    f\"Verify the agent is running and accessible.\"\n                ),\n            )\n            return False\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if client has an active connection.\"\"\"\n        return self._client is not None or self._ws_transport is not None\n\n    def _httpx_mtls_kwargs(\n        self,\n    ) -&gt; tuple[tuple[str, str] | tuple[str, str, str] | None, bool | str]:\n        if self._mtls_config is None:\n            return (None, True)\n        cfg = self._mtls_config\n        cert: tuple[str, str] | tuple[str, str, str] = (\n            str(cfg.cert_file),\n            str(cfg.key_file),\n        )\n        if cfg.key_password:\n            cert = (str(cfg.cert_file), str(cfg.key_file), cfg.key_password)\n        verify: bool | str = str(cfg.ca_certs) if cfg.ca_certs else True\n        return (cert, verify)\n\n    async def __aenter__(self) -&gt; \"ASAPClient\":\n        cert, verify = self._httpx_mtls_kwargs()\n        ws_ssl_context = None\n        if self._mtls_config is not None:\n            ws_ssl_context = create_ssl_context(self._mtls_config, purpose=\"client\")\n        if self._use_websocket:\n            self._ws_transport = WebSocketTransport(\n                receive_timeout=self.timeout,\n                on_message=self._on_message,\n                ack_timeout_seconds=DEFAULT_ACK_TIMEOUT,\n                max_ack_retries=DEFAULT_MAX_ACK_RETRIES,\n                circuit_breaker=self._circuit_breaker,\n                ssl_context=ws_ssl_context,\n            )\n            await self._ws_transport.connect(self._ws_url)\n            # WebSocket mode still uses HTTP client for manifest fetches; small pool is enough.\n            limits = httpx.Limits(max_connections=2, max_keepalive_connections=1)\n            timeout_config = httpx.Timeout(self.timeout, pool=self._pool_timeout)\n            self._client = httpx.AsyncClient(\n                timeout=timeout_config,\n                limits=limits,\n                cert=cert,\n                verify=verify,\n            )\n        else:\n            limits = httpx.Limits(\n                max_keepalive_connections=self._pool_connections,\n                max_connections=self._pool_maxsize,\n                keepalive_expiry=DEFAULT_POOL_TIMEOUT,\n            )\n            timeout_config = httpx.Timeout(self.timeout, pool=self._pool_timeout)\n            if self._transport:\n                self._client = httpx.AsyncClient(\n                    transport=self._transport,\n                    timeout=timeout_config,\n                    limits=limits,\n                    cert=cert,\n                    verify=verify,\n                )\n            else:\n                self._client = httpx.AsyncClient(\n                    timeout=timeout_config,\n                    limits=limits,\n                    http2=self._http2,\n                    cert=cert,\n                    verify=verify,\n                )\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: object,\n    ) -&gt; None:\n        if self._ws_transport:\n            await self._ws_transport.close()\n            self._ws_transport = None\n        if self._client:\n            await self._client.aclose()\n            self._client = None\n\n    async def send(self, envelope: Envelope) -&gt; Envelope:\n        \"\"\"Send an envelope to the remote agent and receive response.\n\n        Wraps the envelope in a JSON-RPC 2.0 request, sends it to the\n        remote agent's /asap endpoint, and unwraps the response.\n\n        Args:\n            envelope: ASAP envelope to send\n\n        Returns:\n            Response envelope from the remote agent\n\n        Raises:\n            ValueError: If envelope is None\n            ASAPConnectionError: If connection fails or HTTP error occurs\n            ASAPTimeoutError: If request times out\n            ASAPRemoteError: If remote agent returns JSON-RPC error\n            CircuitOpenError: If circuit breaker is open and request is rejected\n\n        Example:\n            &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n            ...     response = await client.send(envelope)\n            ...     response.payload_type\n        \"\"\"\n        if envelope is None:\n            raise ValueError(\"envelope cannot be None\")\n\n        if not self._client and not self._ws_transport:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(self.base_url),\n            )\n\n        if self._ws_transport:\n            if self._circuit_breaker is not None and not self._circuit_breaker.can_attempt():\n                consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                raise CircuitOpenError(\n                    base_url=sanitize_url(self.base_url),\n                    consecutive_failures=consecutive_failures,\n                )\n            try:\n                return await self._ws_transport.send_and_receive(envelope)\n            except WebSocketRemoteError as e:\n                raise ASAPRemoteError(e.code, e.message, e.data) from e\n            except asyncio.TimeoutError as e:\n                raise ASAPTimeoutError(\n                    f\"WebSocket receive timed out after {self.timeout}s\",\n                    timeout=self.timeout,\n                ) from e\n\n        if self._circuit_breaker is not None and not self._circuit_breaker.can_attempt():\n            consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n            raise CircuitOpenError(\n                base_url=sanitize_url(self.base_url),\n                consecutive_failures=consecutive_failures,\n            )\n\n        start_time = time.perf_counter()\n\n        # Generate idempotency key for retries\n        idempotency_key = generate_id()\n\n        # Get next request counter value (thread-safe)\n        request_id = f\"req-{next(self._request_counter)}\"\n\n        # Log send attempt with context (sanitize URL to hide credentials)\n        sanitized_url = sanitize_url(self.base_url)\n        logger.info(\n            \"asap.client.send\",\n            target_url=sanitized_url,\n            envelope_id=envelope.id,\n            trace_id=envelope.trace_id,\n            payload_type=envelope.payload_type,\n            idempotency_key=idempotency_key,\n            max_retries=self.max_retries,\n            message=(\n                f\"Sending envelope {envelope.id} to {sanitized_url} \"\n                f\"(payload: {envelope.payload_type}, max_retries: {self.max_retries})\"\n            ),\n        )\n\n        # Build JSON-RPC request\n        json_rpc_request = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": ASAP_METHOD,\n            \"params\": {\n                \"envelope\": envelope.model_dump(mode=\"json\"),\n                \"idempotency_key\": idempotency_key,\n            },\n            \"id\": request_id,\n        }\n\n        # Serialize to bytes for compression\n        request_body = json.dumps(json_rpc_request).encode(\"utf-8\")\n\n        # Apply compression if enabled and payload exceeds threshold\n        content_encoding: str | None = None\n        if self._compression:\n            compressed_body, algorithm = compress_payload(\n                request_body,\n                threshold=self._compression_threshold,\n            )\n            if algorithm != CompressionAlgorithm.IDENTITY:\n                request_body = compressed_body\n                content_encoding = algorithm.value\n                logger.debug(\n                    \"asap.client.compression_applied\",\n                    target_url=sanitized_url,\n                    envelope_id=envelope.id,\n                    algorithm=content_encoding,\n                    original_size=len(json.dumps(json_rpc_request).encode(\"utf-8\")),\n                    compressed_size=len(request_body),\n                )\n\n        # Attempt with retries\n        last_exception: Exception | None = None\n        for attempt in range(self.max_retries):\n            if attempt &gt; 0:\n                get_metrics().increment_counter(\"asap_transport_retries_total\")\n            try:\n                # Build headers\n                headers = {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Idempotency-Key\": idempotency_key,\n                    \"Accept-Encoding\": get_accept_encoding_header(),\n                }\n                if content_encoding:\n                    headers[\"Content-Encoding\"] = content_encoding\n\n                assert self._client is not None  # HTTP path: __aenter__ set it\n                response = await self._client.post(\n                    f\"{self.base_url}/asap\",\n                    headers=headers,\n                    content=request_body,\n                )\n\n                # Log HTTP protocol version for debugging fallback behavior\n                if self._http2 and response.http_version != \"HTTP/2\":\n                    logger.debug(\n                        \"asap.client.http_fallback\",\n                        target_url=sanitize_url(self.base_url),\n                        requested=\"HTTP/2\",\n                        actual=response.http_version,\n                        message=f\"HTTP/2 requested but used {response.http_version}\",\n                    )\n\n                if response.status_code &gt;= 500:\n                    # Server errors (5xx) are retriable\n                    error_msg = (\n                        f\"HTTP server error {response.status_code} from {self.base_url}. \"\n                        f\"Server returned: {response.text[:200]}\"\n                    )\n                    if attempt &lt; self.max_retries - 1:\n                        delay = self._calculate_backoff(attempt)\n                        logger.warning(\n                            \"asap.client.retry_server_error\",\n                            status_code=response.status_code,\n                            attempt=attempt + 1,\n                            max_retries=self.max_retries,\n                            delay_seconds=round(delay, 2),\n                            target_url=sanitize_url(self.base_url),\n                            envelope_id=envelope.id,\n                            message=(\n                                f\"Server error {response.status_code}, \"\n                                f\"retrying in {delay:.2f}s \"\n                                f\"(attempt {attempt + 1}/{self.max_retries})\"\n                            ),\n                        )\n                        await asyncio.sleep(delay)\n                        last_exception = ASAPConnectionError(error_msg, url=self.base_url)\n                        continue\n                    # All retries exhausted, record failure in circuit breaker\n                    if self._circuit_breaker is not None:\n                        previous_state = self._circuit_breaker.get_state()\n                        self._circuit_breaker.record_failure()\n                        current_state = self._circuit_breaker.get_state()\n                        consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                        # Log state change if circuit opened\n                        if previous_state != current_state and current_state == CircuitState.OPEN:\n                            logger.warning(\n                                \"asap.client.circuit_opened\",\n                                target_url=sanitize_url(self.base_url),\n                                consecutive_failures=consecutive_failures,\n                                threshold=self._circuit_breaker.threshold,\n                                message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                            )\n                    raise ASAPConnectionError(error_msg, url=self.base_url)\n                if response.status_code == 429:\n                    if attempt &lt; self.max_retries - 1:\n                        retry_after = response.headers.get(\"Retry-After\")\n                        if retry_after:\n                            retry_delay: Optional[float] = None\n                            # Retry-After can be seconds (int/float) or HTTP date\n                            # First, try to parse as seconds (numeric)\n                            if retry_after.replace(\".\", \"\", 1).isdigit():\n                                try:\n                                    retry_delay = float(retry_after)\n                                    logger.info(\n                                        \"asap.client.retry_after\",\n                                        target_url=sanitize_url(self.base_url),\n                                        envelope_id=envelope.id,\n                                        attempt=attempt + 1,\n                                        retry_after_seconds=retry_delay,\n                                        message=f\"Respecting server Retry-After: {retry_delay}s\",\n                                    )\n                                except ValueError:\n                                    pass  # Fall through to date parsing\n                            else:\n                                # Try to parse as HTTP date\n                                try:\n                                    retry_date = parsedate_to_datetime(retry_after)\n                                    if retry_date:\n                                        # Calculate delay in seconds from now until retry_date\n                                        now_timestamp = time.time()\n                                        retry_timestamp = retry_date.timestamp()\n                                        calculated_delay = retry_timestamp - now_timestamp\n                                        # If date is in the past or delay is invalid, fall back to calculated backoff\n                                        if calculated_delay &lt;= 0:\n                                            retry_delay = None  # Will trigger fallback\n                                        else:\n                                            retry_delay = calculated_delay\n                                            logger.info(\n                                                \"asap.client.retry_after\",\n                                                target_url=sanitize_url(self.base_url),\n                                                envelope_id=envelope.id,\n                                                attempt=attempt + 1,\n                                                retry_after_seconds=round(retry_delay, 2),\n                                                retry_after_date=retry_after,\n                                                message=f\"Respecting server Retry-After date: {retry_after} ({retry_delay:.2f}s)\",\n                                            )\n                                except (ValueError, TypeError, AttributeError, OSError):\n                                    # Invalid date format or timestamp conversion error, fall back to calculated backoff\n                                    pass\n\n                            # If parsing failed or delay is invalid (None or &lt;= 0), use calculated backoff\n                            if retry_delay is None or retry_delay &lt;= 0:\n                                retry_delay = self._calculate_backoff(attempt)\n                                logger.warning(\n                                    \"asap.client.retry_after_invalid\",\n                                    target_url=sanitize_url(self.base_url),\n                                    envelope_id=envelope.id,\n                                    retry_after_header=retry_after,\n                                    fallback_delay=round(retry_delay, 2),\n                                    message=\"Invalid Retry-After format, using calculated backoff\",\n                                )\n                            delay = retry_delay\n                        else:\n                            # No Retry-After header, use calculated backoff\n                            delay = self._calculate_backoff(attempt)\n                        logger.warning(\n                            \"asap.client.rate_limited\",\n                            status_code=429,\n                            attempt=attempt + 1,\n                            max_retries=self.max_retries,\n                            delay_seconds=round(delay, 2),\n                        )\n                        logger.info(\n                            \"asap.client.retry\",\n                            target_url=sanitize_url(self.base_url),\n                            envelope_id=envelope.id,\n                            attempt=attempt + 1,\n                            max_retries=self.max_retries,\n                            delay_seconds=round(delay, 2),\n                        )\n                        await asyncio.sleep(delay)\n                        last_exception = ASAPConnectionError(\n                            f\"HTTP rate limit error 429 from {self.base_url}. \"\n                            f\"Server response: {response.text[:200]}\",\n                            url=sanitize_url(self.base_url),\n                        )\n                        continue\n                    # All retries exhausted, record failure in circuit breaker\n                    if self._circuit_breaker is not None:\n                        previous_state = self._circuit_breaker.get_state()\n                        self._circuit_breaker.record_failure()\n                        current_state = self._circuit_breaker.get_state()\n                        consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                        # Log state change if circuit opened\n                        if previous_state != current_state and current_state == CircuitState.OPEN:\n                            logger.warning(\n                                \"asap.client.circuit_opened\",\n                                target_url=sanitize_url(self.base_url),\n                                consecutive_failures=consecutive_failures,\n                                threshold=self._circuit_breaker.threshold,\n                                message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures (rate limited)\",\n                            )\n                    raise ASAPConnectionError(\n                        f\"HTTP rate limit error 429 from {self.base_url} after {self.max_retries} attempts. \"\n                        f\"Server response: {response.text[:200]}\",\n                        url=sanitize_url(self.base_url),\n                    )\n                if response.status_code &gt;= 400:\n                    # Client errors (4xx) are not retriable (except 429 handled above)\n                    # We record a failure in the circuit breaker here because persistent 4xx\n                    # (like 401/403) can indicate an unhealthy configuration or system state.\n                    if self._circuit_breaker is not None:\n                        self._circuit_breaker.record_failure()\n\n                    raise ASAPConnectionError(\n                        f\"HTTP client error {response.status_code} from {self.base_url}. \"\n                        f\"This indicates a problem with the request. \"\n                        f\"Server response: {response.text[:200]}\",\n                        url=sanitize_url(self.base_url),\n                    )\n\n                # Parse JSON response\n                try:\n                    json_response = response.json()\n                except Exception as e:\n                    raise ASAPRemoteError(-32700, f\"Invalid JSON response: {e}\") from e\n\n                if \"error\" in json_response:\n                    if self._circuit_breaker is not None:\n                        self._circuit_breaker.record_success()\n\n                    error = json_response[\"error\"]\n                    raise ASAPRemoteError(\n                        error.get(\"code\", -32603),\n                        error.get(\"message\", \"Unknown error\"),\n                        error.get(\"data\"),\n                    )\n\n                # Extract envelope from result\n                result = json_response.get(\"result\", {})\n                envelope_data = result.get(\"envelope\")\n                if not envelope_data:\n                    raise ASAPRemoteError(-32603, \"Missing envelope in response\")\n\n                response_envelope = Envelope(**envelope_data)\n\n                # Record success in circuit breaker\n                if self._circuit_breaker is not None:\n                    previous_state = self._circuit_breaker.get_state()\n                    self._circuit_breaker.record_success()\n                    current_state = self._circuit_breaker.get_state()\n                    # Log state change if circuit was closed\n                    if previous_state != current_state and current_state == CircuitState.CLOSED:\n                        logger.info(\n                            \"asap.client.circuit_closed\",\n                            target_url=sanitize_url(self.base_url),\n                            message=\"Circuit breaker closed after successful request\",\n                        )\n\n                # Calculate duration and log success\n                duration_seconds = time.perf_counter() - start_time\n                duration_ms = duration_seconds * 1000\n                logger.info(\n                    \"asap.client.response\",\n                    target_url=sanitize_url(self.base_url),\n                    envelope_id=envelope.id,\n                    response_id=response_envelope.id,\n                    trace_id=envelope.trace_id,\n                    duration_ms=round(duration_ms, 2),\n                    attempts=attempt + 1,\n                )\n                metrics = get_metrics()\n                metrics.increment_counter(\"asap_transport_send_total\", {\"status\": \"success\"})\n                metrics.observe_histogram(\n                    \"asap_transport_send_duration_seconds\",\n                    duration_seconds,\n                    {\"status\": \"success\"},\n                )\n                return response_envelope\n\n            except (httpx.ConnectError, httpx.TimeoutException) as e:\n                is_timeout = isinstance(e, httpx.TimeoutException)\n                error_type = \"Timeout\" if is_timeout else \"Connection error\"\n                error_msg = (\n                    f\"{error_type} to {self.base_url}: {e}. \"\n                    f\"Verify the agent is running and accessible.\"\n                )\n                if is_timeout:\n                    last_exception = ASAPTimeoutError(\n                        f\"Request timeout after {self.timeout}s\", timeout=self.timeout\n                    )\n                else:\n                    last_exception = ASAPConnectionError(error_msg, cause=e, url=self.base_url)\n\n                # Log retry attempt\n                if attempt &lt; self.max_retries - 1:\n                    delay = self._calculate_backoff(attempt)\n                    logger.warning(\n                        \"asap.client.retry\",\n                        target_url=sanitize_url(self.base_url),\n                        envelope_id=envelope.id,\n                        attempt=attempt + 1,\n                        max_retries=self.max_retries,\n                        error=str(e),\n                        delay_seconds=round(delay, 2),\n                        message=(\n                            f\"{error_type} to {self.base_url} (attempt {attempt + 1}/{self.max_retries}). \"\n                            f\"Retrying in {delay:.2f}s. \"\n                            f\"Error: {str(e)[:100]}\"\n                        ),\n                    )\n                    await asyncio.sleep(delay)\n                    continue\n\n                # All retries exhausted, record failure in circuit breaker\n                if self._circuit_breaker is not None:\n                    previous_state = self._circuit_breaker.get_state()\n                    self._circuit_breaker.record_failure()\n                    current_state = self._circuit_breaker.get_state()\n                    consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                    # Log state change if circuit opened\n                    if previous_state != current_state and current_state == CircuitState.OPEN:\n                        logger.warning(\n                            \"asap.client.circuit_opened\",\n                            target_url=sanitize_url(self.base_url),\n                            consecutive_failures=consecutive_failures,\n                            threshold=self._circuit_breaker.threshold,\n                            message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                        )\n\n                # Log final failure with detailed context\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                error_type_name = \"ASAPTimeoutError\" if is_timeout else \"ASAPConnectionError\"\n                logger.error(\n                    \"asap.client.error\",\n                    target_url=sanitize_url(self.base_url),\n                    envelope_id=envelope.id,\n                    error=f\"{error_type} after retries\",\n                    error_type=error_type_name,\n                    duration_ms=round(duration_ms, 2),\n                    attempts=attempt + 1,\n                    max_retries=self.max_retries,\n                    timeout=self.timeout if is_timeout else None,\n                    message=(\n                        f\"{error_type} to {self.base_url} failed after {attempt + 1} attempts. \"\n                        f\"Total duration: {duration_ms:.2f}ms. \"\n                        f\"Troubleshooting: Verify the agent is running, check network connectivity, \"\n                        f\"and ensure the URL is correct. Original error: {str(e)[:200]}\"\n                    ),\n                )\n                raise last_exception from e\n\n            except (ASAPConnectionError, ASAPRemoteError, ASAPTimeoutError):\n                # Re-raise our custom errors without recording failure again\n                # (failures are already recorded before these exceptions are raised)\n                raise\n\n            except Exception as e:\n                # Record failure in circuit breaker\n                if self._circuit_breaker is not None:\n                    previous_state = self._circuit_breaker.get_state()\n                    self._circuit_breaker.record_failure()\n                    current_state = self._circuit_breaker.get_state()\n                    consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                    # Log state change if circuit opened\n                    if previous_state != current_state and current_state == CircuitState.OPEN:\n                        logger.warning(\n                            \"asap.client.circuit_opened\",\n                            target_url=sanitize_url(self.base_url),\n                            consecutive_failures=consecutive_failures,\n                            threshold=self._circuit_breaker.threshold,\n                            message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                        )\n                # Log unexpected error\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                logger.exception(\n                    \"asap.client.error\",\n                    target_url=sanitize_url(self.base_url),\n                    envelope_id=envelope.id,\n                    error=str(e),\n                    error_type=type(e).__name__,\n                    duration_ms=round(duration_ms, 2),\n                )\n                _record_send_error_metrics(start_time, e)\n                # Wrap unexpected errors\n                raise ASAPConnectionError(\n                    f\"Unexpected error connecting to {self.base_url}: {e}. \"\n                    f\"Verify the agent is running and accessible.\",\n                    cause=e,\n                    url=sanitize_url(self.base_url),\n                ) from e\n\n        if last_exception:  # pragma: no cover\n            _record_send_error_metrics(start_time, last_exception)\n            raise last_exception\n        raise ASAPConnectionError(\n            f\"Max retries ({self.max_retries}) exceeded for {self.base_url}. \"\n            f\"Verify the agent is running and accessible.\",\n            url=sanitize_url(self.base_url),\n        )  # pragma: no cover\n\n    async def get_manifest(self, url: str | None = None) -&gt; Manifest:\n        \"\"\"Get agent manifest from cache or HTTP endpoint.\n\n        Checks cache first, then fetches from HTTP if not cached or expired.\n        Caches successful responses with TTL (default: 5 minutes).\n        Invalidates cache entry on error.\n\n        Args:\n            url: Manifest URL (defaults to {base_url}/.well-known/asap/manifest.json)\n\n        Returns:\n            Manifest object\n\n        Raises:\n            ASAPConnectionError: If HTTP request fails\n            ASAPTimeoutError: If request times out\n            ValueError: If manifest JSON is invalid\n\n        Example:\n            &gt;&gt;&gt; async with ASAPClient(\"http://agent.example.com\") as client:\n            ...     manifest = await client.get_manifest()\n            ...     print(manifest.id, manifest.name)\n        \"\"\"\n        if url is None:\n            url = f\"{self._http_base_url}/.well-known/asap/manifest.json\"\n\n        if not self._client:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(url),\n            )\n\n        with self._manifest_fetch_locks_guard:\n            if url not in self._manifest_fetch_locks:\n                self._manifest_fetch_locks[url] = asyncio.Lock()\n            url_lock = self._manifest_fetch_locks[url]\n        async with url_lock:\n            cached = self._manifest_cache.get(url)\n            if cached is not None:\n                logger.debug(\n                    \"asap.client.manifest_cache_hit\",\n                    url=sanitize_url(url),\n                    manifest_id=cached.id,\n                    message=f\"Manifest cache hit for {sanitize_url(url)}\",\n                )\n                return cached\n\n            logger.debug(\n                \"asap.client.manifest_cache_miss\",\n                url=sanitize_url(url),\n                message=f\"Manifest cache miss for {sanitize_url(url)}, fetching from HTTP\",\n            )\n\n            try:\n                response = await self._client.get(\n                    url,\n                    timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),  # Cap timeout for manifest\n                )\n\n                if response.status_code &gt;= 400:\n                    self._manifest_cache.invalidate(url)\n                    raise ASAPConnectionError(\n                        f\"HTTP error {response.status_code} fetching manifest from {url}. \"\n                        f\"Server response: {response.text[:200]}\",\n                        url=sanitize_url(url),\n                    )\n\n                try:\n                    manifest_data = response.json()\n                except Exception as e:\n                    self._manifest_cache.invalidate(url)\n                    raise ValueError(f\"Invalid JSON in manifest response: {e}\") from e\n\n                try:\n                    if \"manifest\" in manifest_data and \"signature\" in manifest_data:\n                        signed = SignedManifest.model_validate(manifest_data)\n                        if self._verify_signatures:\n                            trusted_b64 = self._trusted_manifest_keys.get(url)\n                            if not trusted_b64:\n                                raise SignatureVerificationError(\n                                    f\"Cannot verify signed manifest from {sanitize_url(url)}: \"\n                                    \"no trusted public key provided. Pass trusted_manifest_keys \"\n                                    \"to ASAPClient (or disable verify_signatures).\",\n                                    details={\"url\": sanitize_url(url)},\n                                )\n                            trusted_key = load_public_key_from_base64(trusted_b64)\n                            await asyncio.to_thread(verify_manifest, signed, trusted_key)\n                        manifest = signed.manifest\n                        trust_level = signed.signature.trust_level.value\n                    else:\n                        manifest = Manifest.model_validate(manifest_data)\n                        trust_level = None\n                except SignatureVerificationError:\n                    self._manifest_cache.invalidate(url)\n                    raise\n                except Exception as e:\n                    self._manifest_cache.invalidate(url)\n                    raise ValueError(f\"Invalid manifest format: {e}\") from e\n\n                self._manifest_cache.set(url, manifest)\n                logger.info(\n                    \"asap.client.manifest_fetched\",\n                    url=sanitize_url(url),\n                    manifest_id=manifest.id,\n                    trust_level=trust_level,\n                    message=f\"Manifest fetched and cached for {sanitize_url(url)}\"\n                    + (f\" (trust: {trust_level})\" if trust_level else \"\"),\n                )\n                return manifest\n\n            except httpx.TimeoutException as e:\n                self._manifest_cache.invalidate(url)\n                raise ASAPTimeoutError(\n                    f\"Manifest request timeout after {self.timeout}s\", timeout=self.timeout\n                ) from e\n            except httpx.ConnectError as e:\n                self._manifest_cache.invalidate(url)\n                raise ASAPConnectionError(\n                    f\"Connection error fetching manifest from {url}: {e}. \"\n                    f\"Verify the agent is running and accessible.\",\n                    cause=e,\n                    url=sanitize_url(url),\n                ) from e\n            except (ASAPConnectionError, ASAPTimeoutError, ValueError, SignatureVerificationError):\n                raise\n            except Exception as e:\n                self._manifest_cache.invalidate(url)\n                logger.exception(\n                    \"asap.client.manifest_error\",\n                    url=sanitize_url(url),\n                    error=str(e),\n                    error_type=type(e).__name__,\n                    message=f\"Unexpected error fetching manifest from {url}: {e}\",\n                )\n                raise ASAPConnectionError(\n                    f\"Unexpected error fetching manifest from {url}: {e}. \"\n                    f\"Verify the agent is running and accessible.\",\n                    cause=e,\n                    url=sanitize_url(url),\n                ) from e\n\n    async def discover(self, base_url: str) -&gt; Manifest:\n        \"\"\"Discover agent manifest from its base URL (well-known URI).\n\n        Fetches GET {base_url}/.well-known/asap/manifest.json, parses the\n        response into a Manifest, and caches it by manifest URL. When the\n        manifest is already in cache and not expired, returns it without\n        making a new request. Respects Cache-Control max-age when provided\n        for cache TTL.\n\n        Args:\n            base_url: Agent base URL (e.g. \"https://agent.example.com\").\n\n        Returns:\n            Manifest for the agent at base_url.\n\n        Raises:\n            ASAPConnectionError: If client not connected or HTTP request fails.\n            ASAPTimeoutError: If request times out.\n            ValueError: If manifest response is not valid JSON.\n            ManifestValidationError: If manifest schema or required fields are invalid.\n\n        Example:\n            &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n            ...     manifest = await client.discover(\"https://other-agent.example.com\")\n            ...     print(manifest.id, manifest.capabilities.asap_version)\n        \"\"\"\n        manifest_url = base_url.rstrip(\"/\") + WELLKNOWN_MANIFEST_PATH\n        if not self._client:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(manifest_url),\n            )\n\n        with self._manifest_fetch_locks_guard:\n            if manifest_url not in self._manifest_fetch_locks:\n                self._manifest_fetch_locks[manifest_url] = asyncio.Lock()\n            url_lock = self._manifest_fetch_locks[manifest_url]\n        async with url_lock:\n            cached = self._manifest_cache.get(manifest_url)\n            if cached is not None:\n                logger.debug(\n                    \"asap.client.discover_cache_hit\",\n                    url=sanitize_url(manifest_url),\n                    manifest_id=cached.id,\n                    message=f\"Discovery cache hit for {sanitize_url(manifest_url)}\",\n                )\n                return cached\n\n            try:\n                response = await self._client.get(\n                    manifest_url,\n                    timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),\n                )\n\n                if response.status_code &gt;= 400:\n                    self._manifest_cache.invalidate(manifest_url)\n                    raise ASAPConnectionError(\n                        f\"HTTP error {response.status_code} fetching manifest from {manifest_url}. \"\n                        f\"Server response: {response.text[:200]}\",\n                        url=sanitize_url(manifest_url),\n                    )\n\n                try:\n                    manifest_data = response.json()\n                except Exception as e:\n                    self._manifest_cache.invalidate(manifest_url)\n                    raise ValueError(f\"Invalid JSON in manifest response: {e}\") from e\n\n                try:\n                    manifest = validate_manifest_schema(manifest_data)\n                except ManifestValidationError:\n                    self._manifest_cache.invalidate(manifest_url)\n                    raise\n\n                ttl = _parse_max_age_from_cache_control(response.headers.get(\"Cache-Control\"))\n                self._manifest_cache.set(manifest_url, manifest, ttl=ttl)\n                logger.info(\n                    \"asap.client.discover\",\n                    url=sanitize_url(manifest_url),\n                    manifest_id=manifest.id,\n                    message=f\"Discovered and cached manifest for {sanitize_url(manifest_url)}\",\n                )\n                return manifest\n\n            except httpx.TimeoutException as e:\n                self._manifest_cache.invalidate(manifest_url)\n                raise ASAPTimeoutError(\n                    f\"Manifest request timeout after {self.timeout}s\", timeout=self.timeout\n                ) from e\n            except httpx.ConnectError as e:\n                self._manifest_cache.invalidate(manifest_url)\n                raise ASAPConnectionError(\n                    f\"Connection error fetching manifest from {manifest_url}: {e}. \"\n                    \"Verify the agent is running and accessible.\",\n                    cause=e,\n                    url=sanitize_url(manifest_url),\n                ) from e\n            except (ASAPConnectionError, ASAPTimeoutError, ValueError, ManifestValidationError):\n                raise\n            except Exception as e:\n                self._manifest_cache.invalidate(manifest_url)\n                logger.exception(\n                    \"asap.client.discover_error\",\n                    url=sanitize_url(manifest_url),\n                    error=str(e),\n                    error_type=type(e).__name__,\n                )\n                raise ASAPConnectionError(\n                    f\"Unexpected error discovering manifest from {manifest_url}: {e}. \"\n                    \"Verify the agent is running and accessible.\",\n                    cause=e,\n                    url=sanitize_url(manifest_url),\n                ) from e\n\n    async def health_check(self, base_url: str) -&gt; HealthStatus:\n        \"\"\"Check agent health/liveness at the given base URL.\n\n        Fetches GET {base_url}/.well-known/asap/health and parses the\n        response into a HealthStatus model.\n\n        Args:\n            base_url: Agent base URL (e.g. \"https://agent.example.com\").\n\n        Returns:\n            HealthStatus with status, agent_id, version, uptime_seconds, etc.\n\n        Raises:\n            ASAPConnectionError: If client not connected or HTTP request fails.\n            ASAPTimeoutError: If request times out.\n            ValueError: If health response is not valid JSON or schema invalid.\n\n        Example:\n            &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n            ...     health = await client.health_check(\"https://other-agent.example.com\")\n            ...     print(health.status, health.uptime_seconds)\n        \"\"\"\n        health_url = base_url.rstrip(\"/\") + WELLKNOWN_HEALTH_PATH\n        if not self._client:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(health_url),\n            )\n\n        try:\n            response = await self._client.get(\n                health_url,\n                timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),\n            )\n\n            if response.status_code &gt;= 400:\n                raise ASAPConnectionError(\n                    f\"HTTP error {response.status_code} fetching health from {health_url}. \"\n                    f\"Server response: {response.text[:200]}\",\n                    url=sanitize_url(health_url),\n                )\n\n            try:\n                data = response.json()\n            except Exception as e:\n                raise ValueError(f\"Invalid JSON in health response: {e}\") from e\n\n            try:\n                return HealthStatus.model_validate(data)\n            except Exception as e:\n                raise ValueError(f\"Invalid health response schema: {e}\") from e\n\n        except httpx.TimeoutException as e:\n            raise ASAPTimeoutError(\n                f\"Health request timeout after {self.timeout}s\", timeout=self.timeout\n            ) from e\n        except httpx.ConnectError as e:\n            raise ASAPConnectionError(\n                f\"Connection error fetching health from {health_url}: {e}. \"\n                \"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(health_url),\n            ) from e\n        except (ASAPConnectionError, ASAPTimeoutError, ValueError):\n            raise\n        except Exception as e:\n            logger.exception(\n                \"asap.client.health_check_error\",\n                url=sanitize_url(health_url),\n                error=str(e),\n                error_type=type(e).__name__,\n            )\n            raise ASAPConnectionError(\n                f\"Unexpected error checking health at {health_url}: {e}. \"\n                \"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(health_url),\n            ) from e\n\n    async def send_batch(\n        self,\n        envelopes: list[Envelope],\n        return_exceptions: bool = False,\n    ) -&gt; list[Envelope | BaseException]:\n        \"\"\"Send multiple envelopes in parallel using asyncio.gather.\n\n        Uses asyncio.gather to send all envelopes concurrently, leveraging\n        connection pooling and HTTP/2 multiplexing for optimal throughput.\n\n        Args:\n            envelopes: List of ASAP envelopes to send\n            return_exceptions: If True, exceptions are returned in the result list\n                instead of being raised. If False (default), the first exception\n                encountered will be raised.\n\n        Returns:\n            List of response envelopes in the same order as input envelopes.\n            If return_exceptions=True, failed sends will have the exception\n            in their position instead of an Envelope.\n\n        Raises:\n            ValueError: If envelopes list is empty\n            ASAPConnectionError: If any send fails (when return_exceptions=False)\n            ASAPTimeoutError: If any send times out (when return_exceptions=False)\n            ASAPRemoteError: If any remote agent returns error (when return_exceptions=False)\n            CircuitOpenError: If circuit breaker is open (when return_exceptions=False)\n\n        Example:\n            &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n            ...     responses = await client.send_batch([env1, env2, env3])\n            ...     for response in responses:\n            ...         print(response.payload_type)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # With error handling\n            &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n            ...     results = await client.send_batch(envelopes, return_exceptions=True)\n            ...     for i, result in enumerate(results):\n            ...         if isinstance(result, BaseException):\n            ...             print(f\"Envelope {i} failed: {result}\")\n            ...         else:\n            ...             print(f\"Envelope {i} succeeded: {result.id}\")\n        \"\"\"\n        if not envelopes:\n            raise ValueError(\"envelopes list cannot be empty\")\n\n        if self._ws_transport:\n            raise NotImplementedError(\n                \"send_batch is not supported with WebSocket transport; use send() in a loop.\"\n            )\n\n        if not self._client:\n            raise ASAPConnectionError(\n                \"Client not connected. Use 'async with' context.\",\n                url=sanitize_url(self.base_url),\n            )\n\n        batch_size = len(envelopes)\n        logger.info(\n            \"asap.client.send_batch\",\n            target_url=sanitize_url(self.base_url),\n            batch_size=batch_size,\n            message=f\"Sending batch of {batch_size} envelopes to {sanitize_url(self.base_url)}\",\n        )\n\n        start_time = time.perf_counter()\n\n        # Create send tasks for all envelopes\n        tasks = [self.send(envelope) for envelope in envelopes]\n\n        # Execute all tasks concurrently\n        results = await asyncio.gather(*tasks, return_exceptions=return_exceptions)\n\n        duration_ms = (time.perf_counter() - start_time) * 1000\n\n        # Count successes and failures\n        if return_exceptions:\n            success_count = sum(1 for r in results if isinstance(r, Envelope))\n            failure_count = batch_size - success_count\n        else:\n            success_count = batch_size\n            failure_count = 0\n\n        logger.info(\n            \"asap.client.send_batch_complete\",\n            target_url=sanitize_url(self.base_url),\n            batch_size=batch_size,\n            success_count=success_count,\n            failure_count=failure_count,\n            duration_ms=round(duration_ms, 2),\n            throughput_per_second=round(batch_size / (duration_ms / 1000), 2)\n            if duration_ms &gt; 0\n            else 0,\n            message=(\n                f\"Batch of {batch_size} envelopes completed in {duration_ms:.2f}ms \"\n                f\"({success_count} succeeded, {failure_count} failed)\"\n            ),\n        )\n\n        return results\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient--batch-operations-with-http2-multiplexing","title":"Batch operations with HTTP/2 multiplexing","text":"<p>async with ASAPClient(\"https://agent.example.com\") as client: ...     responses = await client.send_batch([env1, env2, env3])</p>"},{"location":"api-reference/#asap.transport.ASAPClient--disable-compression-for-specific-client","title":"Disable compression for specific client","text":"<p>async with ASAPClient(\"http://localhost:8000\", compression=False) as client: ...     response = await client.send(envelope)  # No compression</p>"},{"location":"api-reference/#asap.transport.ASAPClient.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if client has an active connection.</p>"},{"location":"api-reference/#asap.transport.ASAPClient.discover","title":"<code>discover(base_url)</code>  <code>async</code>","text":"<p>Discover agent manifest from its base URL (well-known URI).</p> <p>Fetches GET {base_url}/.well-known/asap/manifest.json, parses the response into a Manifest, and caches it by manifest URL. When the manifest is already in cache and not expired, returns it without making a new request. Respects Cache-Control max-age when provided for cache TTL.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Agent base URL (e.g. \"https://agent.example.com\").</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>Manifest for the agent at base_url.</p> <p>Raises:</p> Type Description <code>ASAPConnectionError</code> <p>If client not connected or HTTP request fails.</p> <code>ASAPTimeoutError</code> <p>If request times out.</p> <code>ValueError</code> <p>If manifest response is not valid JSON.</p> <code>ManifestValidationError</code> <p>If manifest schema or required fields are invalid.</p> Example <p>async with ASAPClient(\"http://localhost:8000\") as client: ...     manifest = await client.discover(\"https://other-agent.example.com\") ...     print(manifest.id, manifest.capabilities.asap_version)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>async def discover(self, base_url: str) -&gt; Manifest:\n    \"\"\"Discover agent manifest from its base URL (well-known URI).\n\n    Fetches GET {base_url}/.well-known/asap/manifest.json, parses the\n    response into a Manifest, and caches it by manifest URL. When the\n    manifest is already in cache and not expired, returns it without\n    making a new request. Respects Cache-Control max-age when provided\n    for cache TTL.\n\n    Args:\n        base_url: Agent base URL (e.g. \"https://agent.example.com\").\n\n    Returns:\n        Manifest for the agent at base_url.\n\n    Raises:\n        ASAPConnectionError: If client not connected or HTTP request fails.\n        ASAPTimeoutError: If request times out.\n        ValueError: If manifest response is not valid JSON.\n        ManifestValidationError: If manifest schema or required fields are invalid.\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     manifest = await client.discover(\"https://other-agent.example.com\")\n        ...     print(manifest.id, manifest.capabilities.asap_version)\n    \"\"\"\n    manifest_url = base_url.rstrip(\"/\") + WELLKNOWN_MANIFEST_PATH\n    if not self._client:\n        raise ASAPConnectionError(\n            \"Client not connected. Use 'async with' context.\",\n            url=sanitize_url(manifest_url),\n        )\n\n    with self._manifest_fetch_locks_guard:\n        if manifest_url not in self._manifest_fetch_locks:\n            self._manifest_fetch_locks[manifest_url] = asyncio.Lock()\n        url_lock = self._manifest_fetch_locks[manifest_url]\n    async with url_lock:\n        cached = self._manifest_cache.get(manifest_url)\n        if cached is not None:\n            logger.debug(\n                \"asap.client.discover_cache_hit\",\n                url=sanitize_url(manifest_url),\n                manifest_id=cached.id,\n                message=f\"Discovery cache hit for {sanitize_url(manifest_url)}\",\n            )\n            return cached\n\n        try:\n            response = await self._client.get(\n                manifest_url,\n                timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),\n            )\n\n            if response.status_code &gt;= 400:\n                self._manifest_cache.invalidate(manifest_url)\n                raise ASAPConnectionError(\n                    f\"HTTP error {response.status_code} fetching manifest from {manifest_url}. \"\n                    f\"Server response: {response.text[:200]}\",\n                    url=sanitize_url(manifest_url),\n                )\n\n            try:\n                manifest_data = response.json()\n            except Exception as e:\n                self._manifest_cache.invalidate(manifest_url)\n                raise ValueError(f\"Invalid JSON in manifest response: {e}\") from e\n\n            try:\n                manifest = validate_manifest_schema(manifest_data)\n            except ManifestValidationError:\n                self._manifest_cache.invalidate(manifest_url)\n                raise\n\n            ttl = _parse_max_age_from_cache_control(response.headers.get(\"Cache-Control\"))\n            self._manifest_cache.set(manifest_url, manifest, ttl=ttl)\n            logger.info(\n                \"asap.client.discover\",\n                url=sanitize_url(manifest_url),\n                manifest_id=manifest.id,\n                message=f\"Discovered and cached manifest for {sanitize_url(manifest_url)}\",\n            )\n            return manifest\n\n        except httpx.TimeoutException as e:\n            self._manifest_cache.invalidate(manifest_url)\n            raise ASAPTimeoutError(\n                f\"Manifest request timeout after {self.timeout}s\", timeout=self.timeout\n            ) from e\n        except httpx.ConnectError as e:\n            self._manifest_cache.invalidate(manifest_url)\n            raise ASAPConnectionError(\n                f\"Connection error fetching manifest from {manifest_url}: {e}. \"\n                \"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(manifest_url),\n            ) from e\n        except (ASAPConnectionError, ASAPTimeoutError, ValueError, ManifestValidationError):\n            raise\n        except Exception as e:\n            self._manifest_cache.invalidate(manifest_url)\n            logger.exception(\n                \"asap.client.discover_error\",\n                url=sanitize_url(manifest_url),\n                error=str(e),\n                error_type=type(e).__name__,\n            )\n            raise ASAPConnectionError(\n                f\"Unexpected error discovering manifest from {manifest_url}: {e}. \"\n                \"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(manifest_url),\n            ) from e\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient.get_manifest","title":"<code>get_manifest(url=None)</code>  <code>async</code>","text":"<p>Get agent manifest from cache or HTTP endpoint.</p> <p>Checks cache first, then fetches from HTTP if not cached or expired. Caches successful responses with TTL (default: 5 minutes). Invalidates cache entry on error.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>Manifest URL (defaults to {base_url}/.well-known/asap/manifest.json)</p> <code>None</code> <p>Returns:</p> Type Description <code>Manifest</code> <p>Manifest object</p> <p>Raises:</p> Type Description <code>ASAPConnectionError</code> <p>If HTTP request fails</p> <code>ASAPTimeoutError</code> <p>If request times out</p> <code>ValueError</code> <p>If manifest JSON is invalid</p> Example <p>async with ASAPClient(\"http://agent.example.com\") as client: ...     manifest = await client.get_manifest() ...     print(manifest.id, manifest.name)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>async def get_manifest(self, url: str | None = None) -&gt; Manifest:\n    \"\"\"Get agent manifest from cache or HTTP endpoint.\n\n    Checks cache first, then fetches from HTTP if not cached or expired.\n    Caches successful responses with TTL (default: 5 minutes).\n    Invalidates cache entry on error.\n\n    Args:\n        url: Manifest URL (defaults to {base_url}/.well-known/asap/manifest.json)\n\n    Returns:\n        Manifest object\n\n    Raises:\n        ASAPConnectionError: If HTTP request fails\n        ASAPTimeoutError: If request times out\n        ValueError: If manifest JSON is invalid\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://agent.example.com\") as client:\n        ...     manifest = await client.get_manifest()\n        ...     print(manifest.id, manifest.name)\n    \"\"\"\n    if url is None:\n        url = f\"{self._http_base_url}/.well-known/asap/manifest.json\"\n\n    if not self._client:\n        raise ASAPConnectionError(\n            \"Client not connected. Use 'async with' context.\",\n            url=sanitize_url(url),\n        )\n\n    with self._manifest_fetch_locks_guard:\n        if url not in self._manifest_fetch_locks:\n            self._manifest_fetch_locks[url] = asyncio.Lock()\n        url_lock = self._manifest_fetch_locks[url]\n    async with url_lock:\n        cached = self._manifest_cache.get(url)\n        if cached is not None:\n            logger.debug(\n                \"asap.client.manifest_cache_hit\",\n                url=sanitize_url(url),\n                manifest_id=cached.id,\n                message=f\"Manifest cache hit for {sanitize_url(url)}\",\n            )\n            return cached\n\n        logger.debug(\n            \"asap.client.manifest_cache_miss\",\n            url=sanitize_url(url),\n            message=f\"Manifest cache miss for {sanitize_url(url)}, fetching from HTTP\",\n        )\n\n        try:\n            response = await self._client.get(\n                url,\n                timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),  # Cap timeout for manifest\n            )\n\n            if response.status_code &gt;= 400:\n                self._manifest_cache.invalidate(url)\n                raise ASAPConnectionError(\n                    f\"HTTP error {response.status_code} fetching manifest from {url}. \"\n                    f\"Server response: {response.text[:200]}\",\n                    url=sanitize_url(url),\n                )\n\n            try:\n                manifest_data = response.json()\n            except Exception as e:\n                self._manifest_cache.invalidate(url)\n                raise ValueError(f\"Invalid JSON in manifest response: {e}\") from e\n\n            try:\n                if \"manifest\" in manifest_data and \"signature\" in manifest_data:\n                    signed = SignedManifest.model_validate(manifest_data)\n                    if self._verify_signatures:\n                        trusted_b64 = self._trusted_manifest_keys.get(url)\n                        if not trusted_b64:\n                            raise SignatureVerificationError(\n                                f\"Cannot verify signed manifest from {sanitize_url(url)}: \"\n                                \"no trusted public key provided. Pass trusted_manifest_keys \"\n                                \"to ASAPClient (or disable verify_signatures).\",\n                                details={\"url\": sanitize_url(url)},\n                            )\n                        trusted_key = load_public_key_from_base64(trusted_b64)\n                        await asyncio.to_thread(verify_manifest, signed, trusted_key)\n                    manifest = signed.manifest\n                    trust_level = signed.signature.trust_level.value\n                else:\n                    manifest = Manifest.model_validate(manifest_data)\n                    trust_level = None\n            except SignatureVerificationError:\n                self._manifest_cache.invalidate(url)\n                raise\n            except Exception as e:\n                self._manifest_cache.invalidate(url)\n                raise ValueError(f\"Invalid manifest format: {e}\") from e\n\n            self._manifest_cache.set(url, manifest)\n            logger.info(\n                \"asap.client.manifest_fetched\",\n                url=sanitize_url(url),\n                manifest_id=manifest.id,\n                trust_level=trust_level,\n                message=f\"Manifest fetched and cached for {sanitize_url(url)}\"\n                + (f\" (trust: {trust_level})\" if trust_level else \"\"),\n            )\n            return manifest\n\n        except httpx.TimeoutException as e:\n            self._manifest_cache.invalidate(url)\n            raise ASAPTimeoutError(\n                f\"Manifest request timeout after {self.timeout}s\", timeout=self.timeout\n            ) from e\n        except httpx.ConnectError as e:\n            self._manifest_cache.invalidate(url)\n            raise ASAPConnectionError(\n                f\"Connection error fetching manifest from {url}: {e}. \"\n                f\"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(url),\n            ) from e\n        except (ASAPConnectionError, ASAPTimeoutError, ValueError, SignatureVerificationError):\n            raise\n        except Exception as e:\n            self._manifest_cache.invalidate(url)\n            logger.exception(\n                \"asap.client.manifest_error\",\n                url=sanitize_url(url),\n                error=str(e),\n                error_type=type(e).__name__,\n                message=f\"Unexpected error fetching manifest from {url}: {e}\",\n            )\n            raise ASAPConnectionError(\n                f\"Unexpected error fetching manifest from {url}: {e}. \"\n                f\"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(url),\n            ) from e\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient.health_check","title":"<code>health_check(base_url)</code>  <code>async</code>","text":"<p>Check agent health/liveness at the given base URL.</p> <p>Fetches GET {base_url}/.well-known/asap/health and parses the response into a HealthStatus model.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Agent base URL (e.g. \"https://agent.example.com\").</p> required <p>Returns:</p> Type Description <code>HealthStatus</code> <p>HealthStatus with status, agent_id, version, uptime_seconds, etc.</p> <p>Raises:</p> Type Description <code>ASAPConnectionError</code> <p>If client not connected or HTTP request fails.</p> <code>ASAPTimeoutError</code> <p>If request times out.</p> <code>ValueError</code> <p>If health response is not valid JSON or schema invalid.</p> Example <p>async with ASAPClient(\"http://localhost:8000\") as client: ...     health = await client.health_check(\"https://other-agent.example.com\") ...     print(health.status, health.uptime_seconds)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>async def health_check(self, base_url: str) -&gt; HealthStatus:\n    \"\"\"Check agent health/liveness at the given base URL.\n\n    Fetches GET {base_url}/.well-known/asap/health and parses the\n    response into a HealthStatus model.\n\n    Args:\n        base_url: Agent base URL (e.g. \"https://agent.example.com\").\n\n    Returns:\n        HealthStatus with status, agent_id, version, uptime_seconds, etc.\n\n    Raises:\n        ASAPConnectionError: If client not connected or HTTP request fails.\n        ASAPTimeoutError: If request times out.\n        ValueError: If health response is not valid JSON or schema invalid.\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     health = await client.health_check(\"https://other-agent.example.com\")\n        ...     print(health.status, health.uptime_seconds)\n    \"\"\"\n    health_url = base_url.rstrip(\"/\") + WELLKNOWN_HEALTH_PATH\n    if not self._client:\n        raise ASAPConnectionError(\n            \"Client not connected. Use 'async with' context.\",\n            url=sanitize_url(health_url),\n        )\n\n    try:\n        response = await self._client.get(\n            health_url,\n            timeout=min(self.timeout, MANIFEST_REQUEST_TIMEOUT),\n        )\n\n        if response.status_code &gt;= 400:\n            raise ASAPConnectionError(\n                f\"HTTP error {response.status_code} fetching health from {health_url}. \"\n                f\"Server response: {response.text[:200]}\",\n                url=sanitize_url(health_url),\n            )\n\n        try:\n            data = response.json()\n        except Exception as e:\n            raise ValueError(f\"Invalid JSON in health response: {e}\") from e\n\n        try:\n            return HealthStatus.model_validate(data)\n        except Exception as e:\n            raise ValueError(f\"Invalid health response schema: {e}\") from e\n\n    except httpx.TimeoutException as e:\n        raise ASAPTimeoutError(\n            f\"Health request timeout after {self.timeout}s\", timeout=self.timeout\n        ) from e\n    except httpx.ConnectError as e:\n        raise ASAPConnectionError(\n            f\"Connection error fetching health from {health_url}: {e}. \"\n            \"Verify the agent is running and accessible.\",\n            cause=e,\n            url=sanitize_url(health_url),\n        ) from e\n    except (ASAPConnectionError, ASAPTimeoutError, ValueError):\n        raise\n    except Exception as e:\n        logger.exception(\n            \"asap.client.health_check_error\",\n            url=sanitize_url(health_url),\n            error=str(e),\n            error_type=type(e).__name__,\n        )\n        raise ASAPConnectionError(\n            f\"Unexpected error checking health at {health_url}: {e}. \"\n            \"Verify the agent is running and accessible.\",\n            cause=e,\n            url=sanitize_url(health_url),\n        ) from e\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient.send","title":"<code>send(envelope)</code>  <code>async</code>","text":"<p>Send an envelope to the remote agent and receive response.</p> <p>Wraps the envelope in a JSON-RPC 2.0 request, sends it to the remote agent's /asap endpoint, and unwraps the response.</p> <p>Parameters:</p> Name Type Description Default <code>envelope</code> <code>Envelope</code> <p>ASAP envelope to send</p> required <p>Returns:</p> Type Description <code>Envelope</code> <p>Response envelope from the remote agent</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If envelope is None</p> <code>ASAPConnectionError</code> <p>If connection fails or HTTP error occurs</p> <code>ASAPTimeoutError</code> <p>If request times out</p> <code>ASAPRemoteError</code> <p>If remote agent returns JSON-RPC error</p> <code>CircuitOpenError</code> <p>If circuit breaker is open and request is rejected</p> Example <p>async with ASAPClient(\"http://localhost:8000\") as client: ...     response = await client.send(envelope) ...     response.payload_type</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>async def send(self, envelope: Envelope) -&gt; Envelope:\n    \"\"\"Send an envelope to the remote agent and receive response.\n\n    Wraps the envelope in a JSON-RPC 2.0 request, sends it to the\n    remote agent's /asap endpoint, and unwraps the response.\n\n    Args:\n        envelope: ASAP envelope to send\n\n    Returns:\n        Response envelope from the remote agent\n\n    Raises:\n        ValueError: If envelope is None\n        ASAPConnectionError: If connection fails or HTTP error occurs\n        ASAPTimeoutError: If request times out\n        ASAPRemoteError: If remote agent returns JSON-RPC error\n        CircuitOpenError: If circuit breaker is open and request is rejected\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     response = await client.send(envelope)\n        ...     response.payload_type\n    \"\"\"\n    if envelope is None:\n        raise ValueError(\"envelope cannot be None\")\n\n    if not self._client and not self._ws_transport:\n        raise ASAPConnectionError(\n            \"Client not connected. Use 'async with' context.\",\n            url=sanitize_url(self.base_url),\n        )\n\n    if self._ws_transport:\n        if self._circuit_breaker is not None and not self._circuit_breaker.can_attempt():\n            consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n            raise CircuitOpenError(\n                base_url=sanitize_url(self.base_url),\n                consecutive_failures=consecutive_failures,\n            )\n        try:\n            return await self._ws_transport.send_and_receive(envelope)\n        except WebSocketRemoteError as e:\n            raise ASAPRemoteError(e.code, e.message, e.data) from e\n        except asyncio.TimeoutError as e:\n            raise ASAPTimeoutError(\n                f\"WebSocket receive timed out after {self.timeout}s\",\n                timeout=self.timeout,\n            ) from e\n\n    if self._circuit_breaker is not None and not self._circuit_breaker.can_attempt():\n        consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n        raise CircuitOpenError(\n            base_url=sanitize_url(self.base_url),\n            consecutive_failures=consecutive_failures,\n        )\n\n    start_time = time.perf_counter()\n\n    # Generate idempotency key for retries\n    idempotency_key = generate_id()\n\n    # Get next request counter value (thread-safe)\n    request_id = f\"req-{next(self._request_counter)}\"\n\n    # Log send attempt with context (sanitize URL to hide credentials)\n    sanitized_url = sanitize_url(self.base_url)\n    logger.info(\n        \"asap.client.send\",\n        target_url=sanitized_url,\n        envelope_id=envelope.id,\n        trace_id=envelope.trace_id,\n        payload_type=envelope.payload_type,\n        idempotency_key=idempotency_key,\n        max_retries=self.max_retries,\n        message=(\n            f\"Sending envelope {envelope.id} to {sanitized_url} \"\n            f\"(payload: {envelope.payload_type}, max_retries: {self.max_retries})\"\n        ),\n    )\n\n    # Build JSON-RPC request\n    json_rpc_request = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": ASAP_METHOD,\n        \"params\": {\n            \"envelope\": envelope.model_dump(mode=\"json\"),\n            \"idempotency_key\": idempotency_key,\n        },\n        \"id\": request_id,\n    }\n\n    # Serialize to bytes for compression\n    request_body = json.dumps(json_rpc_request).encode(\"utf-8\")\n\n    # Apply compression if enabled and payload exceeds threshold\n    content_encoding: str | None = None\n    if self._compression:\n        compressed_body, algorithm = compress_payload(\n            request_body,\n            threshold=self._compression_threshold,\n        )\n        if algorithm != CompressionAlgorithm.IDENTITY:\n            request_body = compressed_body\n            content_encoding = algorithm.value\n            logger.debug(\n                \"asap.client.compression_applied\",\n                target_url=sanitized_url,\n                envelope_id=envelope.id,\n                algorithm=content_encoding,\n                original_size=len(json.dumps(json_rpc_request).encode(\"utf-8\")),\n                compressed_size=len(request_body),\n            )\n\n    # Attempt with retries\n    last_exception: Exception | None = None\n    for attempt in range(self.max_retries):\n        if attempt &gt; 0:\n            get_metrics().increment_counter(\"asap_transport_retries_total\")\n        try:\n            # Build headers\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"X-Idempotency-Key\": idempotency_key,\n                \"Accept-Encoding\": get_accept_encoding_header(),\n            }\n            if content_encoding:\n                headers[\"Content-Encoding\"] = content_encoding\n\n            assert self._client is not None  # HTTP path: __aenter__ set it\n            response = await self._client.post(\n                f\"{self.base_url}/asap\",\n                headers=headers,\n                content=request_body,\n            )\n\n            # Log HTTP protocol version for debugging fallback behavior\n            if self._http2 and response.http_version != \"HTTP/2\":\n                logger.debug(\n                    \"asap.client.http_fallback\",\n                    target_url=sanitize_url(self.base_url),\n                    requested=\"HTTP/2\",\n                    actual=response.http_version,\n                    message=f\"HTTP/2 requested but used {response.http_version}\",\n                )\n\n            if response.status_code &gt;= 500:\n                # Server errors (5xx) are retriable\n                error_msg = (\n                    f\"HTTP server error {response.status_code} from {self.base_url}. \"\n                    f\"Server returned: {response.text[:200]}\"\n                )\n                if attempt &lt; self.max_retries - 1:\n                    delay = self._calculate_backoff(attempt)\n                    logger.warning(\n                        \"asap.client.retry_server_error\",\n                        status_code=response.status_code,\n                        attempt=attempt + 1,\n                        max_retries=self.max_retries,\n                        delay_seconds=round(delay, 2),\n                        target_url=sanitize_url(self.base_url),\n                        envelope_id=envelope.id,\n                        message=(\n                            f\"Server error {response.status_code}, \"\n                            f\"retrying in {delay:.2f}s \"\n                            f\"(attempt {attempt + 1}/{self.max_retries})\"\n                        ),\n                    )\n                    await asyncio.sleep(delay)\n                    last_exception = ASAPConnectionError(error_msg, url=self.base_url)\n                    continue\n                # All retries exhausted, record failure in circuit breaker\n                if self._circuit_breaker is not None:\n                    previous_state = self._circuit_breaker.get_state()\n                    self._circuit_breaker.record_failure()\n                    current_state = self._circuit_breaker.get_state()\n                    consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                    # Log state change if circuit opened\n                    if previous_state != current_state and current_state == CircuitState.OPEN:\n                        logger.warning(\n                            \"asap.client.circuit_opened\",\n                            target_url=sanitize_url(self.base_url),\n                            consecutive_failures=consecutive_failures,\n                            threshold=self._circuit_breaker.threshold,\n                            message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                        )\n                raise ASAPConnectionError(error_msg, url=self.base_url)\n            if response.status_code == 429:\n                if attempt &lt; self.max_retries - 1:\n                    retry_after = response.headers.get(\"Retry-After\")\n                    if retry_after:\n                        retry_delay: Optional[float] = None\n                        # Retry-After can be seconds (int/float) or HTTP date\n                        # First, try to parse as seconds (numeric)\n                        if retry_after.replace(\".\", \"\", 1).isdigit():\n                            try:\n                                retry_delay = float(retry_after)\n                                logger.info(\n                                    \"asap.client.retry_after\",\n                                    target_url=sanitize_url(self.base_url),\n                                    envelope_id=envelope.id,\n                                    attempt=attempt + 1,\n                                    retry_after_seconds=retry_delay,\n                                    message=f\"Respecting server Retry-After: {retry_delay}s\",\n                                )\n                            except ValueError:\n                                pass  # Fall through to date parsing\n                        else:\n                            # Try to parse as HTTP date\n                            try:\n                                retry_date = parsedate_to_datetime(retry_after)\n                                if retry_date:\n                                    # Calculate delay in seconds from now until retry_date\n                                    now_timestamp = time.time()\n                                    retry_timestamp = retry_date.timestamp()\n                                    calculated_delay = retry_timestamp - now_timestamp\n                                    # If date is in the past or delay is invalid, fall back to calculated backoff\n                                    if calculated_delay &lt;= 0:\n                                        retry_delay = None  # Will trigger fallback\n                                    else:\n                                        retry_delay = calculated_delay\n                                        logger.info(\n                                            \"asap.client.retry_after\",\n                                            target_url=sanitize_url(self.base_url),\n                                            envelope_id=envelope.id,\n                                            attempt=attempt + 1,\n                                            retry_after_seconds=round(retry_delay, 2),\n                                            retry_after_date=retry_after,\n                                            message=f\"Respecting server Retry-After date: {retry_after} ({retry_delay:.2f}s)\",\n                                        )\n                            except (ValueError, TypeError, AttributeError, OSError):\n                                # Invalid date format or timestamp conversion error, fall back to calculated backoff\n                                pass\n\n                        # If parsing failed or delay is invalid (None or &lt;= 0), use calculated backoff\n                        if retry_delay is None or retry_delay &lt;= 0:\n                            retry_delay = self._calculate_backoff(attempt)\n                            logger.warning(\n                                \"asap.client.retry_after_invalid\",\n                                target_url=sanitize_url(self.base_url),\n                                envelope_id=envelope.id,\n                                retry_after_header=retry_after,\n                                fallback_delay=round(retry_delay, 2),\n                                message=\"Invalid Retry-After format, using calculated backoff\",\n                            )\n                        delay = retry_delay\n                    else:\n                        # No Retry-After header, use calculated backoff\n                        delay = self._calculate_backoff(attempt)\n                    logger.warning(\n                        \"asap.client.rate_limited\",\n                        status_code=429,\n                        attempt=attempt + 1,\n                        max_retries=self.max_retries,\n                        delay_seconds=round(delay, 2),\n                    )\n                    logger.info(\n                        \"asap.client.retry\",\n                        target_url=sanitize_url(self.base_url),\n                        envelope_id=envelope.id,\n                        attempt=attempt + 1,\n                        max_retries=self.max_retries,\n                        delay_seconds=round(delay, 2),\n                    )\n                    await asyncio.sleep(delay)\n                    last_exception = ASAPConnectionError(\n                        f\"HTTP rate limit error 429 from {self.base_url}. \"\n                        f\"Server response: {response.text[:200]}\",\n                        url=sanitize_url(self.base_url),\n                    )\n                    continue\n                # All retries exhausted, record failure in circuit breaker\n                if self._circuit_breaker is not None:\n                    previous_state = self._circuit_breaker.get_state()\n                    self._circuit_breaker.record_failure()\n                    current_state = self._circuit_breaker.get_state()\n                    consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                    # Log state change if circuit opened\n                    if previous_state != current_state and current_state == CircuitState.OPEN:\n                        logger.warning(\n                            \"asap.client.circuit_opened\",\n                            target_url=sanitize_url(self.base_url),\n                            consecutive_failures=consecutive_failures,\n                            threshold=self._circuit_breaker.threshold,\n                            message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures (rate limited)\",\n                        )\n                raise ASAPConnectionError(\n                    f\"HTTP rate limit error 429 from {self.base_url} after {self.max_retries} attempts. \"\n                    f\"Server response: {response.text[:200]}\",\n                    url=sanitize_url(self.base_url),\n                )\n            if response.status_code &gt;= 400:\n                # Client errors (4xx) are not retriable (except 429 handled above)\n                # We record a failure in the circuit breaker here because persistent 4xx\n                # (like 401/403) can indicate an unhealthy configuration or system state.\n                if self._circuit_breaker is not None:\n                    self._circuit_breaker.record_failure()\n\n                raise ASAPConnectionError(\n                    f\"HTTP client error {response.status_code} from {self.base_url}. \"\n                    f\"This indicates a problem with the request. \"\n                    f\"Server response: {response.text[:200]}\",\n                    url=sanitize_url(self.base_url),\n                )\n\n            # Parse JSON response\n            try:\n                json_response = response.json()\n            except Exception as e:\n                raise ASAPRemoteError(-32700, f\"Invalid JSON response: {e}\") from e\n\n            if \"error\" in json_response:\n                if self._circuit_breaker is not None:\n                    self._circuit_breaker.record_success()\n\n                error = json_response[\"error\"]\n                raise ASAPRemoteError(\n                    error.get(\"code\", -32603),\n                    error.get(\"message\", \"Unknown error\"),\n                    error.get(\"data\"),\n                )\n\n            # Extract envelope from result\n            result = json_response.get(\"result\", {})\n            envelope_data = result.get(\"envelope\")\n            if not envelope_data:\n                raise ASAPRemoteError(-32603, \"Missing envelope in response\")\n\n            response_envelope = Envelope(**envelope_data)\n\n            # Record success in circuit breaker\n            if self._circuit_breaker is not None:\n                previous_state = self._circuit_breaker.get_state()\n                self._circuit_breaker.record_success()\n                current_state = self._circuit_breaker.get_state()\n                # Log state change if circuit was closed\n                if previous_state != current_state and current_state == CircuitState.CLOSED:\n                    logger.info(\n                        \"asap.client.circuit_closed\",\n                        target_url=sanitize_url(self.base_url),\n                        message=\"Circuit breaker closed after successful request\",\n                    )\n\n            # Calculate duration and log success\n            duration_seconds = time.perf_counter() - start_time\n            duration_ms = duration_seconds * 1000\n            logger.info(\n                \"asap.client.response\",\n                target_url=sanitize_url(self.base_url),\n                envelope_id=envelope.id,\n                response_id=response_envelope.id,\n                trace_id=envelope.trace_id,\n                duration_ms=round(duration_ms, 2),\n                attempts=attempt + 1,\n            )\n            metrics = get_metrics()\n            metrics.increment_counter(\"asap_transport_send_total\", {\"status\": \"success\"})\n            metrics.observe_histogram(\n                \"asap_transport_send_duration_seconds\",\n                duration_seconds,\n                {\"status\": \"success\"},\n            )\n            return response_envelope\n\n        except (httpx.ConnectError, httpx.TimeoutException) as e:\n            is_timeout = isinstance(e, httpx.TimeoutException)\n            error_type = \"Timeout\" if is_timeout else \"Connection error\"\n            error_msg = (\n                f\"{error_type} to {self.base_url}: {e}. \"\n                f\"Verify the agent is running and accessible.\"\n            )\n            if is_timeout:\n                last_exception = ASAPTimeoutError(\n                    f\"Request timeout after {self.timeout}s\", timeout=self.timeout\n                )\n            else:\n                last_exception = ASAPConnectionError(error_msg, cause=e, url=self.base_url)\n\n            # Log retry attempt\n            if attempt &lt; self.max_retries - 1:\n                delay = self._calculate_backoff(attempt)\n                logger.warning(\n                    \"asap.client.retry\",\n                    target_url=sanitize_url(self.base_url),\n                    envelope_id=envelope.id,\n                    attempt=attempt + 1,\n                    max_retries=self.max_retries,\n                    error=str(e),\n                    delay_seconds=round(delay, 2),\n                    message=(\n                        f\"{error_type} to {self.base_url} (attempt {attempt + 1}/{self.max_retries}). \"\n                        f\"Retrying in {delay:.2f}s. \"\n                        f\"Error: {str(e)[:100]}\"\n                    ),\n                )\n                await asyncio.sleep(delay)\n                continue\n\n            # All retries exhausted, record failure in circuit breaker\n            if self._circuit_breaker is not None:\n                previous_state = self._circuit_breaker.get_state()\n                self._circuit_breaker.record_failure()\n                current_state = self._circuit_breaker.get_state()\n                consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                # Log state change if circuit opened\n                if previous_state != current_state and current_state == CircuitState.OPEN:\n                    logger.warning(\n                        \"asap.client.circuit_opened\",\n                        target_url=sanitize_url(self.base_url),\n                        consecutive_failures=consecutive_failures,\n                        threshold=self._circuit_breaker.threshold,\n                        message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                    )\n\n            # Log final failure with detailed context\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            error_type_name = \"ASAPTimeoutError\" if is_timeout else \"ASAPConnectionError\"\n            logger.error(\n                \"asap.client.error\",\n                target_url=sanitize_url(self.base_url),\n                envelope_id=envelope.id,\n                error=f\"{error_type} after retries\",\n                error_type=error_type_name,\n                duration_ms=round(duration_ms, 2),\n                attempts=attempt + 1,\n                max_retries=self.max_retries,\n                timeout=self.timeout if is_timeout else None,\n                message=(\n                    f\"{error_type} to {self.base_url} failed after {attempt + 1} attempts. \"\n                    f\"Total duration: {duration_ms:.2f}ms. \"\n                    f\"Troubleshooting: Verify the agent is running, check network connectivity, \"\n                    f\"and ensure the URL is correct. Original error: {str(e)[:200]}\"\n                ),\n            )\n            raise last_exception from e\n\n        except (ASAPConnectionError, ASAPRemoteError, ASAPTimeoutError):\n            # Re-raise our custom errors without recording failure again\n            # (failures are already recorded before these exceptions are raised)\n            raise\n\n        except Exception as e:\n            # Record failure in circuit breaker\n            if self._circuit_breaker is not None:\n                previous_state = self._circuit_breaker.get_state()\n                self._circuit_breaker.record_failure()\n                current_state = self._circuit_breaker.get_state()\n                consecutive_failures = self._circuit_breaker.get_consecutive_failures()\n                # Log state change if circuit opened\n                if previous_state != current_state and current_state == CircuitState.OPEN:\n                    logger.warning(\n                        \"asap.client.circuit_opened\",\n                        target_url=sanitize_url(self.base_url),\n                        consecutive_failures=consecutive_failures,\n                        threshold=self._circuit_breaker.threshold,\n                        message=f\"Circuit breaker opened after {consecutive_failures} consecutive failures\",\n                    )\n            # Log unexpected error\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            logger.exception(\n                \"asap.client.error\",\n                target_url=sanitize_url(self.base_url),\n                envelope_id=envelope.id,\n                error=str(e),\n                error_type=type(e).__name__,\n                duration_ms=round(duration_ms, 2),\n            )\n            _record_send_error_metrics(start_time, e)\n            # Wrap unexpected errors\n            raise ASAPConnectionError(\n                f\"Unexpected error connecting to {self.base_url}: {e}. \"\n                f\"Verify the agent is running and accessible.\",\n                cause=e,\n                url=sanitize_url(self.base_url),\n            ) from e\n\n    if last_exception:  # pragma: no cover\n        _record_send_error_metrics(start_time, last_exception)\n        raise last_exception\n    raise ASAPConnectionError(\n        f\"Max retries ({self.max_retries}) exceeded for {self.base_url}. \"\n        f\"Verify the agent is running and accessible.\",\n        url=sanitize_url(self.base_url),\n    )  # pragma: no cover\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient.send_batch","title":"<code>send_batch(envelopes, return_exceptions=False)</code>  <code>async</code>","text":"<p>Send multiple envelopes in parallel using asyncio.gather.</p> <p>Uses asyncio.gather to send all envelopes concurrently, leveraging connection pooling and HTTP/2 multiplexing for optimal throughput.</p> <p>Parameters:</p> Name Type Description Default <code>envelopes</code> <code>list[Envelope]</code> <p>List of ASAP envelopes to send</p> required <code>return_exceptions</code> <code>bool</code> <p>If True, exceptions are returned in the result list instead of being raised. If False (default), the first exception encountered will be raised.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Envelope | BaseException]</code> <p>List of response envelopes in the same order as input envelopes.</p> <code>list[Envelope | BaseException]</code> <p>If return_exceptions=True, failed sends will have the exception</p> <code>list[Envelope | BaseException]</code> <p>in their position instead of an Envelope.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If envelopes list is empty</p> <code>ASAPConnectionError</code> <p>If any send fails (when return_exceptions=False)</p> <code>ASAPTimeoutError</code> <p>If any send times out (when return_exceptions=False)</p> <code>ASAPRemoteError</code> <p>If any remote agent returns error (when return_exceptions=False)</p> <code>CircuitOpenError</code> <p>If circuit breaker is open (when return_exceptions=False)</p> Example <p>async with ASAPClient(\"http://localhost:8000\") as client: ...     responses = await client.send_batch([env1, env2, env3]) ...     for response in responses: ...         print(response.payload_type)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>async def send_batch(\n    self,\n    envelopes: list[Envelope],\n    return_exceptions: bool = False,\n) -&gt; list[Envelope | BaseException]:\n    \"\"\"Send multiple envelopes in parallel using asyncio.gather.\n\n    Uses asyncio.gather to send all envelopes concurrently, leveraging\n    connection pooling and HTTP/2 multiplexing for optimal throughput.\n\n    Args:\n        envelopes: List of ASAP envelopes to send\n        return_exceptions: If True, exceptions are returned in the result list\n            instead of being raised. If False (default), the first exception\n            encountered will be raised.\n\n    Returns:\n        List of response envelopes in the same order as input envelopes.\n        If return_exceptions=True, failed sends will have the exception\n        in their position instead of an Envelope.\n\n    Raises:\n        ValueError: If envelopes list is empty\n        ASAPConnectionError: If any send fails (when return_exceptions=False)\n        ASAPTimeoutError: If any send times out (when return_exceptions=False)\n        ASAPRemoteError: If any remote agent returns error (when return_exceptions=False)\n        CircuitOpenError: If circuit breaker is open (when return_exceptions=False)\n\n    Example:\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     responses = await client.send_batch([env1, env2, env3])\n        ...     for response in responses:\n        ...         print(response.payload_type)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With error handling\n        &gt;&gt;&gt; async with ASAPClient(\"http://localhost:8000\") as client:\n        ...     results = await client.send_batch(envelopes, return_exceptions=True)\n        ...     for i, result in enumerate(results):\n        ...         if isinstance(result, BaseException):\n        ...             print(f\"Envelope {i} failed: {result}\")\n        ...         else:\n        ...             print(f\"Envelope {i} succeeded: {result.id}\")\n    \"\"\"\n    if not envelopes:\n        raise ValueError(\"envelopes list cannot be empty\")\n\n    if self._ws_transport:\n        raise NotImplementedError(\n            \"send_batch is not supported with WebSocket transport; use send() in a loop.\"\n        )\n\n    if not self._client:\n        raise ASAPConnectionError(\n            \"Client not connected. Use 'async with' context.\",\n            url=sanitize_url(self.base_url),\n        )\n\n    batch_size = len(envelopes)\n    logger.info(\n        \"asap.client.send_batch\",\n        target_url=sanitize_url(self.base_url),\n        batch_size=batch_size,\n        message=f\"Sending batch of {batch_size} envelopes to {sanitize_url(self.base_url)}\",\n    )\n\n    start_time = time.perf_counter()\n\n    # Create send tasks for all envelopes\n    tasks = [self.send(envelope) for envelope in envelopes]\n\n    # Execute all tasks concurrently\n    results = await asyncio.gather(*tasks, return_exceptions=return_exceptions)\n\n    duration_ms = (time.perf_counter() - start_time) * 1000\n\n    # Count successes and failures\n    if return_exceptions:\n        success_count = sum(1 for r in results if isinstance(r, Envelope))\n        failure_count = batch_size - success_count\n    else:\n        success_count = batch_size\n        failure_count = 0\n\n    logger.info(\n        \"asap.client.send_batch_complete\",\n        target_url=sanitize_url(self.base_url),\n        batch_size=batch_size,\n        success_count=success_count,\n        failure_count=failure_count,\n        duration_ms=round(duration_ms, 2),\n        throughput_per_second=round(batch_size / (duration_ms / 1000), 2)\n        if duration_ms &gt; 0\n        else 0,\n        message=(\n            f\"Batch of {batch_size} envelopes completed in {duration_ms:.2f}ms \"\n            f\"({success_count} succeeded, {failure_count} failed)\"\n        ),\n    )\n\n    return results\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPClient.send_batch--with-error-handling","title":"With error handling","text":"<p>async with ASAPClient(\"http://localhost:8000\") as client: ...     results = await client.send_batch(envelopes, return_exceptions=True) ...     for i, result in enumerate(results): ...         if isinstance(result, BaseException): ...             print(f\"Envelope {i} failed: {result}\") ...         else: ...             print(f\"Envelope {i} succeeded: {result.id}\")</p>"},{"location":"api-reference/#asap.transport.ASAPConnectionError","title":"<code>ASAPConnectionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when connection to remote agent fails.</p> <p>This error occurs when the HTTP connection cannot be established or when the remote server returns an HTTP error status.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Error description with troubleshooting suggestions</p> <code>cause</code> <p>Original exception that caused this error</p> <code>url</code> <p>URL that failed to connect (if available)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>class ASAPConnectionError(Exception):\n    \"\"\"Raised when connection to remote agent fails.\n\n    This error occurs when the HTTP connection cannot be established\n    or when the remote server returns an HTTP error status.\n\n    Attributes:\n        message: Error description with troubleshooting suggestions\n        cause: Original exception that caused this error\n        url: URL that failed to connect (if available)\n    \"\"\"\n\n    def __init__(\n        self, message: str, cause: Exception | None = None, url: str | None = None\n    ) -&gt; None:\n        # Enhance message with troubleshooting suggestions if URL is provided\n        if url and \"Verify\" not in message and \"troubleshooting\" not in message.lower():\n            enhanced_message = (\n                f\"{message}\\n\"\n                f\"Troubleshooting: Connection failed to {url}. \"\n                \"Verify the agent is running and accessible. \"\n                \"Check the URL format, network connectivity, and firewall settings.\"\n            )\n        else:\n            enhanced_message = message\n\n        super().__init__(enhanced_message)\n        self.message = enhanced_message\n        self.cause = cause\n        self.url = url\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPRemoteError","title":"<code>ASAPRemoteError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when remote agent returns an error response.</p> <p>This error occurs when the JSON-RPC response contains an error object, indicating the remote agent could not process the request.</p> <p>Attributes:</p> Name Type Description <code>code</code> <p>JSON-RPC error code</p> <code>message</code> <p>Error message from remote</p> <code>data</code> <p>Optional additional error data</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>class ASAPRemoteError(Exception):\n    \"\"\"Raised when remote agent returns an error response.\n\n    This error occurs when the JSON-RPC response contains an error\n    object, indicating the remote agent could not process the request.\n\n    Attributes:\n        code: JSON-RPC error code\n        message: Error message from remote\n        data: Optional additional error data\n    \"\"\"\n\n    def __init__(self, code: int, message: str, data: dict[str, Any] | None = None) -&gt; None:\n        super().__init__(f\"Remote error {code}: {message}\")\n        self.code = code\n        self.message = message\n        self.data = data or {}\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPRequestHandler","title":"<code>ASAPRequestHandler</code>","text":"<p>Handler for processing ASAP protocol requests.</p> <p>Encapsulates the logic for: - Parsing and validating JSON-RPC requests - Authenticating requests based on manifest configuration - Validating sender identity - Dispatching to registered handlers - Building error responses - Recording metrics</p> <p>This class is instantiated by create_app() and used to handle incoming requests on the /asap endpoint.</p> <p>Attributes:</p> Name Type Description <code>registry</code> <p>Handler registry for payload dispatch</p> <code>manifest</code> <p>Agent manifest for context</p> <code>auth_middleware</code> <p>Optional authentication middleware</p> Example <p>handler = ASAPRequestHandler(RegistryHolder(registry), manifest, auth_middleware) response = await handler.handle_message(request)</p> Source code in <code>src/asap/transport/server.py</code> <pre><code>class ASAPRequestHandler:\n    \"\"\"Handler for processing ASAP protocol requests.\n\n    Encapsulates the logic for:\n    - Parsing and validating JSON-RPC requests\n    - Authenticating requests based on manifest configuration\n    - Validating sender identity\n    - Dispatching to registered handlers\n    - Building error responses\n    - Recording metrics\n\n    This class is instantiated by create_app() and used to handle\n    incoming requests on the /asap endpoint.\n\n    Attributes:\n        registry: Handler registry for payload dispatch\n        manifest: Agent manifest for context\n        auth_middleware: Optional authentication middleware\n\n    Example:\n        &gt;&gt;&gt; handler = ASAPRequestHandler(RegistryHolder(registry), manifest, auth_middleware)\n        &gt;&gt;&gt; response = await handler.handle_message(request)\n    \"\"\"\n\n    def __init__(\n        self,\n        registry_holder: RegistryHolder,\n        manifest: Manifest,\n        auth_middleware: AuthenticationMiddleware | None = None,\n        max_request_size: int = MAX_REQUEST_SIZE,\n        nonce_store: NonceStore | None = None,\n    ) -&gt; None:\n        self.registry_holder = registry_holder\n        self.manifest = manifest\n        self.auth_middleware = auth_middleware\n        self.max_request_size = max_request_size\n        self.nonce_store = nonce_store\n\n    def _normalize_payload_type_for_metrics(self, payload_type: str) -&gt; str:\n        if self.registry_holder.registry.has_handler(payload_type):\n            return payload_type\n        return \"other\"\n\n    def build_error_response(\n        self,\n        code: int,\n        data: dict[str, Any] | None = None,\n        request_id: str | int | None = None,\n    ) -&gt; JSONResponse:\n        error_response = JsonRpcErrorResponse(\n            error=JsonRpcError.from_code(code, data=data),\n            id=request_id,\n        )\n        return JSONResponse(status_code=200, content=error_response.model_dump())\n\n    def record_error_metrics(\n        self,\n        metrics: MetricsCollector,\n        payload_type: str,\n        error_type: str,\n        duration_seconds: float,\n    ) -&gt; None:\n        # Normalize payload_type to prevent cardinality explosion\n        normalized_payload_type = self._normalize_payload_type_for_metrics(payload_type)\n        metrics.increment_counter(\n            \"asap_requests_total\",\n            {\"payload_type\": normalized_payload_type, \"status\": \"error\"},\n        )\n        metrics.increment_counter(\n            \"asap_requests_error_total\",\n            {\"payload_type\": normalized_payload_type, \"error_type\": error_type},\n        )\n        metrics.observe_histogram(\n            \"asap_request_duration_seconds\",\n            duration_seconds,\n            {\"payload_type\": normalized_payload_type, \"status\": \"error\"},\n        )\n        # Specific error counters for observability\n        if error_type == \"parse_error\":\n            metrics.increment_counter(\"asap_parse_errors_total\")\n        elif error_type == \"auth_failed\":\n            metrics.increment_counter(\"asap_auth_failures_total\")\n        elif error_type == \"invalid_timestamp\":\n            metrics.increment_counter(\"asap_invalid_timestamp_total\")\n        elif error_type == \"invalid_nonce\":\n            metrics.increment_counter(\"asap_invalid_nonce_total\")\n        elif error_type == \"sender_mismatch\":\n            metrics.increment_counter(\"asap_sender_mismatch_total\")\n        elif error_type in (\n            \"invalid_envelope\",\n            \"missing_envelope\",\n            \"invalid_params\",\n        ):\n            metrics.increment_counter(\"asap_validation_errors_total\", {\"reason\": error_type})\n\n    def _validate_envelope(\n        self,\n        ctx: RequestContext,\n    ) -&gt; tuple[Envelope | None, JSONResponse | str]:\n        rpc_request = ctx.rpc_request\n        if not isinstance(rpc_request.params, dict):\n            logger.warning(\n                \"asap.request.invalid_params_type\",\n                params_type=type(rpc_request.params).__name__,\n            )\n            error_response = self.build_error_response(\n                INVALID_PARAMS,\n                data={\n                    \"error\": \"JSON-RPC 'params' must be an object\",\n                    \"received_type\": type(rpc_request.params).__name__,\n                },\n                request_id=ctx.request_id,\n            )\n            self.record_error_metrics(\n                ctx.metrics,\n                \"unknown\",\n                \"invalid_params\",\n                time.perf_counter() - ctx.start_time,\n            )\n            return None, error_response\n\n        # Extract envelope from params\n        envelope_data = rpc_request.params.get(\"envelope\")\n        if envelope_data is None:\n            logger.warning(\"asap.request.missing_envelope\")\n            error_response = self.build_error_response(\n                INVALID_PARAMS,\n                data={\"error\": \"Missing 'envelope' in params\"},\n                request_id=ctx.request_id,\n            )\n            self.record_error_metrics(\n                ctx.metrics,\n                \"unknown\",\n                \"missing_envelope\",\n                time.perf_counter() - ctx.start_time,\n            )\n            return None, error_response\n\n        if not isinstance(envelope_data, dict):\n            logger.warning(\n                \"asap.request.invalid_envelope_type\",\n                type=type(envelope_data).__name__,\n            )\n            error_response = self.build_error_response(\n                INVALID_PARAMS,\n                data={\"error\": \"'envelope' must be a JSON object\"},\n                request_id=ctx.request_id,\n            )\n            self.record_error_metrics(\n                ctx.metrics,\n                \"unknown\",\n                \"invalid_envelope\",\n                time.perf_counter() - ctx.start_time,\n            )\n            return None, error_response\n\n        try:\n            envelope = Envelope(**envelope_data)\n            payload_type = envelope.payload_type\n            return envelope, payload_type\n        except ValidationError as e:\n            log_data: dict[str, Any] = {\n                \"error\": \"Invalid envelope structure\",\n                \"validation_errors\": e.errors(),\n            }\n            if not is_debug_mode():\n                log_data = sanitize_for_logging(log_data)\n            logger.warning(\"asap.request.invalid_envelope\", **log_data)\n            duration_seconds = time.perf_counter() - ctx.start_time\n            self.record_error_metrics(ctx.metrics, \"unknown\", \"invalid_envelope\", duration_seconds)\n            error_response = self.build_error_response(\n                INVALID_PARAMS,\n                data={\n                    \"error\": \"Invalid envelope structure\",\n                    \"validation_errors\": e.errors(),\n                },\n                request_id=ctx.request_id,\n            )\n            return None, error_response\n\n    async def _dispatch_to_handler(\n        self,\n        envelope: Envelope,\n        ctx: RequestContext,\n    ) -&gt; tuple[Envelope | None, JSONResponse | str]:\n        \"\"\"Dispatch envelope to registered handler.\n\n        Looks up and executes the handler for the envelope's payload type.\n        Handles HandlerNotFoundError and converts it to JSON-RPC error response.\n\n        Args:\n            envelope: Validated ASAP envelope\n            ctx: Request context with rpc_request, start_time, and metrics\n\n        Returns:\n            Tuple of (response_envelope, payload_type) if successful,\n            or (None, error_response) if handler not found\n        \"\"\"\n        payload_type = envelope.payload_type\n        try:\n            response_envelope = await self.registry_holder.registry.dispatch_async(\n                envelope, self.manifest\n            )\n            return response_envelope, payload_type\n        except ThreadPoolExhaustedError as e:\n            # Thread pool exhausted - service temporarily unavailable\n            logger.warning(\n                \"asap.request.thread_pool_exhausted\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n                max_threads=e.max_threads,\n                active_threads=e.active_threads,\n            )\n            # Record error metric\n            duration_seconds = time.perf_counter() - ctx.start_time\n            self.record_error_metrics(\n                ctx.metrics, payload_type, \"thread_pool_exhausted\", duration_seconds\n            )\n            # Return HTTP 503 Service Unavailable (not JSON-RPC error)\n            error_response = JSONResponse(\n                status_code=503,\n                content={\n                    \"error\": \"Service Temporarily Unavailable\",\n                    \"code\": e.code,\n                    \"message\": e.message,\n                    \"details\": e.details,\n                },\n            )\n            return None, error_response\n        except HandlerNotFoundError as e:\n            # No handler registered for this payload type\n            logger.warning(\n                \"asap.request.handler_not_found\",\n                payload_type=e.payload_type,\n                envelope_id=envelope.id,\n            )\n            # Record error metric\n            duration_seconds = time.perf_counter() - ctx.start_time\n            self.record_error_metrics(\n                ctx.metrics, payload_type, \"handler_not_found\", duration_seconds\n            )\n            handler_error = JsonRpcErrorResponse(\n                error=JsonRpcError.from_code(\n                    METHOD_NOT_FOUND,\n                    data={\n                        \"payload_type\": e.payload_type,\n                        \"error\": str(e),\n                    },\n                ),\n                id=ctx.request_id,\n            )\n            error_response = JSONResponse(\n                status_code=200,\n                content=handler_error.model_dump(),\n            )\n            return None, error_response\n\n    async def _authenticate_request(\n        self,\n        request: Request,\n        ctx: RequestContext,\n    ) -&gt; HandlerResult[str]:\n        if self.auth_middleware is None:\n            return None, None\n\n        try:\n            authenticated_agent_id = await self.auth_middleware.verify_authentication(request)\n            return authenticated_agent_id, None\n        except HTTPException as e:\n            # Authentication failed - return JSON-RPC error\n            logger.warning(\n                \"asap.request.auth_failed\",\n                status_code=e.status_code,\n                detail=e.detail,\n            )\n            # Map HTTP status to JSON-RPC error code\n            error_code = INVALID_REQUEST if e.status_code == 401 else INVALID_PARAMS\n            error_response = self.build_error_response(\n                error_code,\n                data={\"error\": str(e.detail), \"status_code\": e.status_code},\n                request_id=ctx.request_id,\n            )\n            self.record_error_metrics(\n                ctx.metrics,\n                \"unknown\",\n                \"auth_failed\",\n                time.perf_counter() - ctx.start_time,\n            )\n            return None, error_response\n\n    def _verify_sender_matches_auth(\n        self,\n        authenticated_agent_id: str | None,\n        envelope: Envelope,\n        ctx: RequestContext,\n        payload_type: str,\n    ) -&gt; JSONResponse | None:\n        if self.auth_middleware is None:\n            return None\n\n        try:\n            self.auth_middleware.verify_sender_matches_auth(authenticated_agent_id, envelope.sender)\n            return None\n        except HTTPException as e:\n            # Sender mismatch - return JSON-RPC error\n            logger.warning(\n                \"asap.request.sender_mismatch\",\n                authenticated_agent=authenticated_agent_id,\n                envelope_sender=envelope.sender,\n            )\n            error_response = self.build_error_response(\n                INVALID_PARAMS,\n                data={\"error\": str(e.detail), \"status_code\": e.status_code},\n                request_id=ctx.request_id,\n            )\n            duration_seconds = time.perf_counter() - ctx.start_time\n            self.record_error_metrics(\n                ctx.metrics, payload_type, \"sender_mismatch\", duration_seconds\n            )\n            return error_response\n\n    def _build_success_response(\n        self,\n        response_envelope: Envelope,\n        ctx: RequestContext,\n        payload_type: str,\n    ) -&gt; JSONResponse:\n        response_envelope = inject_envelope_trace_context(response_envelope)\n        duration_seconds = time.perf_counter() - ctx.start_time\n        duration_ms = duration_seconds * 1000\n\n        # Normalize payload_type to prevent cardinality explosion\n        normalized_payload_type = self._normalize_payload_type_for_metrics(payload_type)\n\n        # Record success metrics\n        ctx.metrics.increment_counter(\n            \"asap_requests_total\",\n            {\"payload_type\": normalized_payload_type, \"status\": \"success\"},\n        )\n        ctx.metrics.increment_counter(\n            \"asap_requests_success_total\",\n            {\"payload_type\": normalized_payload_type},\n        )\n        ctx.metrics.observe_histogram(\n            \"asap_request_duration_seconds\",\n            duration_seconds,\n            {\"payload_type\": normalized_payload_type, \"status\": \"success\"},\n        )\n\n        # Log successful processing\n        logger.info(\n            \"asap.request.processed\",\n            envelope_id=response_envelope.id,\n            response_id=response_envelope.id,\n            trace_id=response_envelope.trace_id,\n            payload_type=payload_type,\n            duration_ms=round(duration_ms, 2),\n        )\n\n        # Wrap response in JSON-RPC\n        # JsonRpcResponse requires id to be str | int, not None\n        response_id: str | int = ctx.request_id if ctx.request_id is not None else \"\"\n        rpc_response = JsonRpcResponse(\n            result={\"envelope\": response_envelope.model_dump(mode=\"json\")},\n            id=response_id,\n        )\n\n        return JSONResponse(\n            status_code=200,\n            content=rpc_response.model_dump(),\n        )\n\n    def _handle_internal_error(\n        self,\n        error: Exception,\n        ctx: RequestContext,\n        payload_type: str,\n    ) -&gt; JSONResponse:\n        duration_seconds = time.perf_counter() - ctx.start_time\n        duration_ms = duration_seconds * 1000\n\n        # Record error metrics (normalized to prevent cardinality explosion)\n        self.record_error_metrics(ctx.metrics, payload_type, \"internal_error\", duration_seconds)\n\n        # Always log full error server-side for diagnostics\n        logger.exception(\n            \"asap.request.error\",\n            error=str(error),\n            error_type=type(error).__name__,\n            duration_ms=round(duration_ms, 2),\n        )\n\n        # Production: generic error to client; debug: full error and stack trace\n        if is_debug_mode():\n            error_data: dict[str, Any] = {\n                \"error\": str(error),\n                \"type\": type(error).__name__,\n                \"traceback\": traceback.format_exc(),\n            }\n        else:\n            error_data = {\"error\": \"Internal server error\"}\n\n        internal_error = JsonRpcErrorResponse(\n            error=JsonRpcError.from_code(INTERNAL_ERROR, data=error_data),\n            id=ctx.request_id,\n        )\n        return JSONResponse(\n            status_code=200,\n            content=internal_error.model_dump(),\n        )\n\n    def _log_request_debug(self, rpc_request: JsonRpcRequest) -&gt; None:\n        \"\"\"Log full JSON-RPC request when ASAP_DEBUG_LOG is enabled (structured JSON).\"\"\"\n        if not is_debug_log_mode():\n            return\n        request_dict: dict[str, Any] = rpc_request.model_dump()\n        if not is_debug_mode():\n            request_dict = sanitize_for_logging(request_dict)\n        logger.info(\"asap.request.debug_request\", request_json=request_dict)\n\n    def _log_response_debug(self, response: JSONResponse) -&gt; None:\n        \"\"\"Log full response when ASAP_DEBUG_LOG is enabled (structured JSON).\"\"\"\n        if not is_debug_log_mode():\n            return\n        try:\n            body_bytes = response.body\n            # Handle both bytes and memoryview\n            if isinstance(body_bytes, memoryview):\n                body_bytes = body_bytes.tobytes()\n            response_dict: dict[str, Any] = json.loads(body_bytes.decode(\"utf-8\"))\n        except (ValueError, AttributeError):\n            response_dict = {\"_raw\": \"(unable to decode response body)\"}\n        if not is_debug_mode():\n            response_dict = sanitize_for_logging(response_dict)\n        logger.info(\n            \"asap.request.debug_response\",\n            status_code=response.status_code,\n            response_json=response_dict,\n        )\n\n    async def _parse_and_validate_request(\n        self,\n        request: Request,\n    ) -&gt; HandlerResult[JsonRpcRequest]:\n        # Parse JSON body\n        try:\n            body = await self.parse_json_body(request)\n        except HTTPException as e:\n            # HTTPException (e.g., 413 Payload Too Large) should be returned directly\n            # Don't convert to JSON-RPC error response\n            from fastapi.responses import JSONResponse\n\n            return None, JSONResponse(\n                status_code=e.status_code,\n                content={\"detail\": e.detail},\n                headers=e.headers if hasattr(e, \"headers\") else None,\n            )\n        except ValueError as e:\n            # Invalid JSON - return parse error\n            error_response = self.build_error_response(\n                PARSE_ERROR,\n                data={\"error\": str(e)},\n                request_id=None,\n            )\n            # Create temporary context for metrics (before we have rpc_request)\n            temp_metrics = get_metrics()\n            self.record_error_metrics(temp_metrics, \"unknown\", \"parse_error\", 0.0)\n            return None, error_response\n\n        if not isinstance(body, dict):\n            error_response = self.build_error_response(\n                INVALID_REQUEST,\n                data={\n                    \"error\": \"JSON-RPC request must be an object\",\n                    \"received_type\": type(body).__name__,\n                },\n                request_id=None,\n            )\n            temp_metrics = get_metrics()\n            self.record_error_metrics(temp_metrics, \"unknown\", \"invalid_request\", 0.0)\n            return None, error_response\n\n        rpc_request, validation_error = self.validate_jsonrpc_request(body)\n        if validation_error is not None:\n            temp_metrics = get_metrics()\n            self.record_error_metrics(temp_metrics, \"unknown\", \"invalid_request\", 0.0)\n            return None, validation_error\n\n        if rpc_request is None:\n            error_response = self.build_error_response(\n                INTERNAL_ERROR,\n                data={\"error\": \"Internal validation error\"},\n                request_id=None,\n            )\n            temp_metrics = get_metrics()\n            self.record_error_metrics(\n                temp_metrics, \"unknown\", \"internal_error\", time.perf_counter()\n            )\n            return None, error_response\n\n        return rpc_request, None\n\n    def _validate_request_size(self, request: Request, max_size: int) -&gt; None:\n        \"\"\"Validate that request size does not exceed maximum.\n\n        Checks Content-Length header first, then validates actual body size\n        if available. Raises HTTPException(413) if request is too large.\n\n        Args:\n            request: FastAPI request object\n            max_size: Maximum allowed request size in bytes\n\n        Raises:\n            HTTPException: If request size exceeds maximum (413 Payload Too Large)\n        \"\"\"\n        content_length = request.headers.get(\"content-length\")\n        if content_length:\n            try:\n                size = int(content_length)\n                if size &gt; max_size:\n                    logger.warning(\n                        \"asap.request.size_exceeded\",\n                        content_length=size,\n                        max_size=max_size,\n                    )\n                    raise HTTPException(\n                        status_code=413,\n                        detail=f\"Request size ({size} bytes) exceeds maximum ({max_size} bytes)\",\n                    )\n            except ValueError:\n                logger.debug(\"asap.request.invalid_content_length\", content_length=content_length)\n\n    async def parse_json_body(self, request: Request) -&gt; dict[str, Any]:\n        \"\"\"Parse JSON body from request with size validation and decompression.\n\n        Validates request size before parsing to prevent DoS attacks.\n        Checks both Content-Length header and actual body size.\n        Automatically decompresses gzip/brotli encoded requests.\n\n        Args:\n            request: FastAPI request object\n\n        Returns:\n            Parsed JSON body\n\n        Raises:\n            HTTPException: If request size exceeds maximum (413)\n            HTTPException: If Content-Encoding is unsupported (415)\n            ValueError: If JSON is invalid\n        \"\"\"\n        content_encoding = request.headers.get(\"content-encoding\", \"\").lower().strip()\n        supported_encodings = get_supported_encodings() + [\"identity\", \"\"]\n        if content_encoding and content_encoding not in supported_encodings:\n            logger.warning(\n                \"asap.request.unsupported_encoding\",\n                content_encoding=content_encoding,\n                supported=supported_encodings,\n            )\n            raise HTTPException(\n                status_code=415,\n                detail=f\"Unsupported Content-Encoding: {content_encoding}. Supported: {', '.join(get_supported_encodings())}\",\n            )\n\n        try:\n            body_bytes = bytearray()\n            async for chunk in request.stream():\n                body_bytes.extend(chunk)\n                if len(body_bytes) &gt; self.max_request_size:\n                    logger.warning(\n                        \"asap.request.size_exceeded\",\n                        actual_size=len(body_bytes),\n                        max_size=self.max_request_size,\n                    )\n                    raise HTTPException(\n                        status_code=413,\n                        detail=f\"Request size ({len(body_bytes)} bytes) exceeds maximum ({self.max_request_size} bytes)\",\n                    )\n\n            # Decompress if Content-Encoding is specified\n            if content_encoding and content_encoding not in (\"identity\", \"\"):\n                try:\n                    compressed_size = len(body_bytes)\n                    body_bytes = bytearray(decompress_payload(bytes(body_bytes), content_encoding))\n                    decompressed_size = len(body_bytes)\n\n                    logger.debug(\n                        \"asap.request.decompressed\",\n                        content_encoding=content_encoding,\n                        compressed_size=compressed_size,\n                        decompressed_size=decompressed_size,\n                    )\n\n                    if decompressed_size &gt; self.max_request_size:\n                        compression_ratio = (\n                            decompressed_size / compressed_size if compressed_size &gt; 0 else 0\n                        )\n                        logger.warning(\n                            \"asap.request.decompressed_size_exceeded\",\n                            decompressed_size=decompressed_size,\n                            original_compressed_size=compressed_size,\n                            compression_ratio=round(compression_ratio, 2),\n                            max_size=self.max_request_size,\n                        )\n                        raise HTTPException(\n                            status_code=413,\n                            detail=f\"Decompressed request size ({decompressed_size} bytes) exceeds maximum ({self.max_request_size} bytes)\",\n                        )\n                except ValueError as e:\n                    # Decompression failed (invalid compressed data or unsupported encoding)\n                    logger.warning(\n                        \"asap.request.decompression_failed\",\n                        content_encoding=content_encoding,\n                        error=str(e),\n                    )\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Failed to decompress request: {e}\",\n                    ) from e\n                except (OSError, EOFError) as e:\n                    # Invalid gzip/brotli data (OSError) or truncated data (EOFError)\n                    logger.warning(\n                        \"asap.request.invalid_compressed_data\",\n                        content_encoding=content_encoding,\n                        error=str(e),\n                    )\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Invalid compressed data: {e}\",\n                    ) from e\n\n            # Parse JSON from bytes\n            body: dict[str, Any] = json.loads(body_bytes.decode(\"utf-8\"))\n            return body\n        except UnicodeDecodeError as e:\n            logger.warning(\"asap.request.invalid_encoding\", error=str(e))\n            raise ValueError(f\"Invalid UTF-8 encoding: {e}\") from e\n        except json.JSONDecodeError as e:\n            logger.warning(\"asap.request.invalid_json\", error=str(e))\n            raise ValueError(f\"Invalid JSON: {e}\") from e\n\n    def validate_jsonrpc_request(\n        self, body: dict[str, Any]\n    ) -&gt; tuple[JsonRpcRequest | None, JSONResponse | None]:\n        \"\"\"Validate JSON-RPC request structure and method.\n\n        Args:\n            body: Parsed JSON body\n\n        Returns:\n            Tuple of (JsonRpcRequest, None) if valid, or (None, error_response) if invalid\n        \"\"\"\n        try:\n            rpc_request = JsonRpcRequest(**body)\n        except (ValidationError, TypeError) as e:\n            error_code = INVALID_REQUEST\n            error_message = \"Invalid JSON-RPC structure\"\n            if isinstance(e, ValidationError):\n                errors = e.errors()\n                # If params validation failed with dict_type error, use INVALID_PARAMS\n                for error in errors:\n                    if error.get(\"loc\") == (\"params\",) and error.get(\"type\") == \"dict_type\":\n                        error_code = INVALID_PARAMS\n                        error_message = \"JSON-RPC 'params' must be an object\"\n                        break\n\n            log_struct: dict[str, Any] = {\n                \"error\": error_message,\n                \"error_type\": type(e).__name__,\n                \"validation_errors\": (\n                    e.errors()\n                    if isinstance(e, ValidationError)\n                    else [{\"type\": \"type_error\", \"loc\": (), \"msg\": str(e), \"input\": None}]\n                ),\n            }\n            if not is_debug_mode():\n                log_struct = sanitize_for_logging(log_struct)\n            logger.warning(\"asap.request.invalid_structure\", **log_struct)\n            error_response = self.build_error_response(\n                error_code,\n                data={\n                    \"error\": error_message,\n                    \"validation_errors\": (\n                        e.errors()\n                        if isinstance(e, ValidationError)\n                        else [{\"type\": \"type_error\", \"loc\": (), \"msg\": str(e), \"input\": None}]\n                    ),\n                },\n                request_id=body.get(\"id\") if isinstance(body, dict) else None,\n            )\n            return None, error_response\n\n        if rpc_request.method != ASAP_METHOD:\n            logger.warning(\"asap.request.unknown_method\", method=rpc_request.method)\n            error_response = self.build_error_response(\n                METHOD_NOT_FOUND,\n                data={\"method\": rpc_request.method},\n                request_id=rpc_request.id,\n            )\n            return None, error_response\n\n        return rpc_request, None\n\n    async def handle_message(self, request: Request) -&gt; JSONResponse:\n        \"\"\"Handle ASAP messages wrapped in JSON-RPC 2.0.\n\n        This method:\n        1. Receives JSON-RPC wrapped ASAP envelopes\n        2. Validates the request structure\n        3. Extracts and processes the ASAP envelope\n        4. Returns response wrapped in JSON-RPC\n        5. Records metrics for observability\n\n        Args:\n            request: FastAPI request object with JSON body\n\n        Returns:\n            JSON-RPC response or error response\n\n        Example:\n            &gt;&gt;&gt; response = await handler.handle_message(request)\n        \"\"\"\n        start_time = time.perf_counter()\n        metrics = get_metrics()\n        payload_type = \"unknown\"\n\n        try:\n            parse_result = await self._parse_and_validate_request(request)\n            rpc_request, parse_error = parse_result\n            if parse_error is not None:\n                self._log_response_debug(parse_error)\n                return parse_error\n            if rpc_request is None:\n                raise RuntimeError(\"Internal error: rpc_request is None after validation\")\n\n            self._log_request_debug(rpc_request)\n\n            ctx = RequestContext(\n                request_id=rpc_request.id,\n                start_time=start_time,\n                metrics=metrics,\n                rpc_request=rpc_request,\n            )\n\n            auth_result = await self._authenticate_request(request, ctx)\n            authenticated_agent_id, auth_error = auth_result\n            if auth_error is not None:\n                self._log_response_debug(auth_error)\n                return auth_error\n\n            envelope_result = self._validate_envelope(ctx)\n            envelope_or_none, result = envelope_result\n            if envelope_or_none is None:\n                error_resp = cast(JSONResponse, result)\n                self._log_response_debug(error_resp)\n                return error_resp\n            envelope = envelope_or_none\n            payload_type = cast(str, result)\n\n            trace_token = extract_and_activate_envelope_trace_context(envelope)\n            try:\n                sender_error = self._verify_sender_matches_auth(\n                    authenticated_agent_id,\n                    envelope,\n                    ctx,\n                    payload_type,\n                )\n                if sender_error is not None:\n                    self._log_response_debug(sender_error)\n                    return sender_error\n\n                try:\n                    validate_envelope_timestamp(envelope)\n                except InvalidTimestampError as e:\n                    log_ts: dict[str, Any] = {\n                        \"envelope_id\": envelope.id,\n                        \"error\": e.message,\n                        \"details\": e.details,\n                    }\n                    if not is_debug_mode() and isinstance(e.details, dict):\n                        log_ts[\"details\"] = sanitize_for_logging(e.details)\n                    logger.warning(\"asap.request.invalid_timestamp\", **log_ts)\n                    duration_seconds = time.perf_counter() - ctx.start_time\n                    self.record_error_metrics(\n                        ctx.metrics, payload_type, \"invalid_timestamp\", duration_seconds\n                    )\n                    err_resp = self.build_error_response(\n                        INVALID_PARAMS,\n                        data={\n                            \"error\": \"Invalid envelope timestamp\",\n                            \"code\": e.code,\n                            \"message\": e.message,\n                            \"details\": e.details,\n                        },\n                        request_id=ctx.request_id,\n                    )\n                    self._log_response_debug(err_resp)\n                    return err_resp\n\n                try:\n                    validate_envelope_nonce(envelope, self.nonce_store)\n                except InvalidNonceError as e:\n                    # Sanitize nonce in logs to prevent full value exposure\n                    nonce_sanitized = sanitize_nonce(e.nonce)\n                    error_msg = e.message if is_debug_mode() else \"Duplicate nonce detected\"\n                    logger.warning(\n                        \"asap.request.invalid_nonce\",\n                        envelope_id=envelope.id,\n                        nonce=nonce_sanitized,\n                        error=error_msg,\n                    )\n                    duration_seconds = time.perf_counter() - ctx.start_time\n                    self.record_error_metrics(\n                        ctx.metrics, payload_type, \"invalid_nonce\", duration_seconds\n                    )\n                    err_resp = self.build_error_response(\n                        INVALID_PARAMS,\n                        data={\n                            \"error\": \"Invalid envelope nonce\",\n                            \"code\": e.code,\n                            \"message\": e.message,\n                            \"details\": e.details,\n                        },\n                        request_id=ctx.request_id,\n                    )\n                    self._log_response_debug(err_resp)\n                    return err_resp\n\n                logger.info(\n                    \"asap.request.received\",\n                    envelope_id=envelope.id,\n                    trace_id=envelope.trace_id,\n                    payload_type=envelope.payload_type,\n                    sender=envelope.sender,\n                    recipient=envelope.recipient,\n                    authenticated=authenticated_agent_id is not None,\n                )\n\n                dispatch_result = await self._dispatch_to_handler(envelope, ctx)\n                response_or_none, result = dispatch_result\n                if response_or_none is None:\n                    error_resp = cast(JSONResponse, result)\n                    self._log_response_debug(error_resp)\n                    return error_resp\n                response_envelope = response_or_none\n                payload_type = cast(str, result)\n\n                success_resp = self._build_success_response(response_envelope, ctx, payload_type)\n                self._log_response_debug(success_resp)\n                return success_resp\n            finally:\n                if trace_token is not None:\n                    context.detach(trace_token)\n\n        except Exception as e:\n            # Create minimal context for error handling if we don't have rpc_request yet\n            if \"ctx\" not in locals():\n                # Fallback: create context with minimal info\n                temp_metrics = get_metrics()\n                # JsonRpcRequest requires id to be str | int, use empty string as fallback\n                temp_rpc_request = JsonRpcRequest(\n                    jsonrpc=\"2.0\", method=ASAP_METHOD, params={}, id=\"\"\n                )\n                ctx = RequestContext(\n                    request_id=\"\",\n                    start_time=start_time,\n                    metrics=temp_metrics,\n                    rpc_request=temp_rpc_request,\n                )\n            err_resp = self._handle_internal_error(e, ctx, payload_type)\n            self._log_response_debug(err_resp)\n            return err_resp\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPRequestHandler.handle_message","title":"<code>handle_message(request)</code>  <code>async</code>","text":"<p>Handle ASAP messages wrapped in JSON-RPC 2.0.</p> <p>This method: 1. Receives JSON-RPC wrapped ASAP envelopes 2. Validates the request structure 3. Extracts and processes the ASAP envelope 4. Returns response wrapped in JSON-RPC 5. Records metrics for observability</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>FastAPI request object with JSON body</p> required <p>Returns:</p> Type Description <code>JSONResponse</code> <p>JSON-RPC response or error response</p> Example <p>response = await handler.handle_message(request)</p> Source code in <code>src/asap/transport/server.py</code> <pre><code>async def handle_message(self, request: Request) -&gt; JSONResponse:\n    \"\"\"Handle ASAP messages wrapped in JSON-RPC 2.0.\n\n    This method:\n    1. Receives JSON-RPC wrapped ASAP envelopes\n    2. Validates the request structure\n    3. Extracts and processes the ASAP envelope\n    4. Returns response wrapped in JSON-RPC\n    5. Records metrics for observability\n\n    Args:\n        request: FastAPI request object with JSON body\n\n    Returns:\n        JSON-RPC response or error response\n\n    Example:\n        &gt;&gt;&gt; response = await handler.handle_message(request)\n    \"\"\"\n    start_time = time.perf_counter()\n    metrics = get_metrics()\n    payload_type = \"unknown\"\n\n    try:\n        parse_result = await self._parse_and_validate_request(request)\n        rpc_request, parse_error = parse_result\n        if parse_error is not None:\n            self._log_response_debug(parse_error)\n            return parse_error\n        if rpc_request is None:\n            raise RuntimeError(\"Internal error: rpc_request is None after validation\")\n\n        self._log_request_debug(rpc_request)\n\n        ctx = RequestContext(\n            request_id=rpc_request.id,\n            start_time=start_time,\n            metrics=metrics,\n            rpc_request=rpc_request,\n        )\n\n        auth_result = await self._authenticate_request(request, ctx)\n        authenticated_agent_id, auth_error = auth_result\n        if auth_error is not None:\n            self._log_response_debug(auth_error)\n            return auth_error\n\n        envelope_result = self._validate_envelope(ctx)\n        envelope_or_none, result = envelope_result\n        if envelope_or_none is None:\n            error_resp = cast(JSONResponse, result)\n            self._log_response_debug(error_resp)\n            return error_resp\n        envelope = envelope_or_none\n        payload_type = cast(str, result)\n\n        trace_token = extract_and_activate_envelope_trace_context(envelope)\n        try:\n            sender_error = self._verify_sender_matches_auth(\n                authenticated_agent_id,\n                envelope,\n                ctx,\n                payload_type,\n            )\n            if sender_error is not None:\n                self._log_response_debug(sender_error)\n                return sender_error\n\n            try:\n                validate_envelope_timestamp(envelope)\n            except InvalidTimestampError as e:\n                log_ts: dict[str, Any] = {\n                    \"envelope_id\": envelope.id,\n                    \"error\": e.message,\n                    \"details\": e.details,\n                }\n                if not is_debug_mode() and isinstance(e.details, dict):\n                    log_ts[\"details\"] = sanitize_for_logging(e.details)\n                logger.warning(\"asap.request.invalid_timestamp\", **log_ts)\n                duration_seconds = time.perf_counter() - ctx.start_time\n                self.record_error_metrics(\n                    ctx.metrics, payload_type, \"invalid_timestamp\", duration_seconds\n                )\n                err_resp = self.build_error_response(\n                    INVALID_PARAMS,\n                    data={\n                        \"error\": \"Invalid envelope timestamp\",\n                        \"code\": e.code,\n                        \"message\": e.message,\n                        \"details\": e.details,\n                    },\n                    request_id=ctx.request_id,\n                )\n                self._log_response_debug(err_resp)\n                return err_resp\n\n            try:\n                validate_envelope_nonce(envelope, self.nonce_store)\n            except InvalidNonceError as e:\n                # Sanitize nonce in logs to prevent full value exposure\n                nonce_sanitized = sanitize_nonce(e.nonce)\n                error_msg = e.message if is_debug_mode() else \"Duplicate nonce detected\"\n                logger.warning(\n                    \"asap.request.invalid_nonce\",\n                    envelope_id=envelope.id,\n                    nonce=nonce_sanitized,\n                    error=error_msg,\n                )\n                duration_seconds = time.perf_counter() - ctx.start_time\n                self.record_error_metrics(\n                    ctx.metrics, payload_type, \"invalid_nonce\", duration_seconds\n                )\n                err_resp = self.build_error_response(\n                    INVALID_PARAMS,\n                    data={\n                        \"error\": \"Invalid envelope nonce\",\n                        \"code\": e.code,\n                        \"message\": e.message,\n                        \"details\": e.details,\n                    },\n                    request_id=ctx.request_id,\n                )\n                self._log_response_debug(err_resp)\n                return err_resp\n\n            logger.info(\n                \"asap.request.received\",\n                envelope_id=envelope.id,\n                trace_id=envelope.trace_id,\n                payload_type=envelope.payload_type,\n                sender=envelope.sender,\n                recipient=envelope.recipient,\n                authenticated=authenticated_agent_id is not None,\n            )\n\n            dispatch_result = await self._dispatch_to_handler(envelope, ctx)\n            response_or_none, result = dispatch_result\n            if response_or_none is None:\n                error_resp = cast(JSONResponse, result)\n                self._log_response_debug(error_resp)\n                return error_resp\n            response_envelope = response_or_none\n            payload_type = cast(str, result)\n\n            success_resp = self._build_success_response(response_envelope, ctx, payload_type)\n            self._log_response_debug(success_resp)\n            return success_resp\n        finally:\n            if trace_token is not None:\n                context.detach(trace_token)\n\n    except Exception as e:\n        # Create minimal context for error handling if we don't have rpc_request yet\n        if \"ctx\" not in locals():\n            # Fallback: create context with minimal info\n            temp_metrics = get_metrics()\n            # JsonRpcRequest requires id to be str | int, use empty string as fallback\n            temp_rpc_request = JsonRpcRequest(\n                jsonrpc=\"2.0\", method=ASAP_METHOD, params={}, id=\"\"\n            )\n            ctx = RequestContext(\n                request_id=\"\",\n                start_time=start_time,\n                metrics=temp_metrics,\n                rpc_request=temp_rpc_request,\n            )\n        err_resp = self._handle_internal_error(e, ctx, payload_type)\n        self._log_response_debug(err_resp)\n        return err_resp\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPRequestHandler.parse_json_body","title":"<code>parse_json_body(request)</code>  <code>async</code>","text":"<p>Parse JSON body from request with size validation and decompression.</p> <p>Validates request size before parsing to prevent DoS attacks. Checks both Content-Length header and actual body size. Automatically decompresses gzip/brotli encoded requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>FastAPI request object</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Parsed JSON body</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If request size exceeds maximum (413)</p> <code>HTTPException</code> <p>If Content-Encoding is unsupported (415)</p> <code>ValueError</code> <p>If JSON is invalid</p> Source code in <code>src/asap/transport/server.py</code> <pre><code>async def parse_json_body(self, request: Request) -&gt; dict[str, Any]:\n    \"\"\"Parse JSON body from request with size validation and decompression.\n\n    Validates request size before parsing to prevent DoS attacks.\n    Checks both Content-Length header and actual body size.\n    Automatically decompresses gzip/brotli encoded requests.\n\n    Args:\n        request: FastAPI request object\n\n    Returns:\n        Parsed JSON body\n\n    Raises:\n        HTTPException: If request size exceeds maximum (413)\n        HTTPException: If Content-Encoding is unsupported (415)\n        ValueError: If JSON is invalid\n    \"\"\"\n    content_encoding = request.headers.get(\"content-encoding\", \"\").lower().strip()\n    supported_encodings = get_supported_encodings() + [\"identity\", \"\"]\n    if content_encoding and content_encoding not in supported_encodings:\n        logger.warning(\n            \"asap.request.unsupported_encoding\",\n            content_encoding=content_encoding,\n            supported=supported_encodings,\n        )\n        raise HTTPException(\n            status_code=415,\n            detail=f\"Unsupported Content-Encoding: {content_encoding}. Supported: {', '.join(get_supported_encodings())}\",\n        )\n\n    try:\n        body_bytes = bytearray()\n        async for chunk in request.stream():\n            body_bytes.extend(chunk)\n            if len(body_bytes) &gt; self.max_request_size:\n                logger.warning(\n                    \"asap.request.size_exceeded\",\n                    actual_size=len(body_bytes),\n                    max_size=self.max_request_size,\n                )\n                raise HTTPException(\n                    status_code=413,\n                    detail=f\"Request size ({len(body_bytes)} bytes) exceeds maximum ({self.max_request_size} bytes)\",\n                )\n\n        # Decompress if Content-Encoding is specified\n        if content_encoding and content_encoding not in (\"identity\", \"\"):\n            try:\n                compressed_size = len(body_bytes)\n                body_bytes = bytearray(decompress_payload(bytes(body_bytes), content_encoding))\n                decompressed_size = len(body_bytes)\n\n                logger.debug(\n                    \"asap.request.decompressed\",\n                    content_encoding=content_encoding,\n                    compressed_size=compressed_size,\n                    decompressed_size=decompressed_size,\n                )\n\n                if decompressed_size &gt; self.max_request_size:\n                    compression_ratio = (\n                        decompressed_size / compressed_size if compressed_size &gt; 0 else 0\n                    )\n                    logger.warning(\n                        \"asap.request.decompressed_size_exceeded\",\n                        decompressed_size=decompressed_size,\n                        original_compressed_size=compressed_size,\n                        compression_ratio=round(compression_ratio, 2),\n                        max_size=self.max_request_size,\n                    )\n                    raise HTTPException(\n                        status_code=413,\n                        detail=f\"Decompressed request size ({decompressed_size} bytes) exceeds maximum ({self.max_request_size} bytes)\",\n                    )\n            except ValueError as e:\n                # Decompression failed (invalid compressed data or unsupported encoding)\n                logger.warning(\n                    \"asap.request.decompression_failed\",\n                    content_encoding=content_encoding,\n                    error=str(e),\n                )\n                raise HTTPException(\n                    status_code=400,\n                    detail=f\"Failed to decompress request: {e}\",\n                ) from e\n            except (OSError, EOFError) as e:\n                # Invalid gzip/brotli data (OSError) or truncated data (EOFError)\n                logger.warning(\n                    \"asap.request.invalid_compressed_data\",\n                    content_encoding=content_encoding,\n                    error=str(e),\n                )\n                raise HTTPException(\n                    status_code=400,\n                    detail=f\"Invalid compressed data: {e}\",\n                ) from e\n\n        # Parse JSON from bytes\n        body: dict[str, Any] = json.loads(body_bytes.decode(\"utf-8\"))\n        return body\n    except UnicodeDecodeError as e:\n        logger.warning(\"asap.request.invalid_encoding\", error=str(e))\n        raise ValueError(f\"Invalid UTF-8 encoding: {e}\") from e\n    except json.JSONDecodeError as e:\n        logger.warning(\"asap.request.invalid_json\", error=str(e))\n        raise ValueError(f\"Invalid JSON: {e}\") from e\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPRequestHandler.validate_jsonrpc_request","title":"<code>validate_jsonrpc_request(body)</code>","text":"<p>Validate JSON-RPC request structure and method.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>dict[str, Any]</code> <p>Parsed JSON body</p> required <p>Returns:</p> Type Description <code>tuple[JsonRpcRequest | None, JSONResponse | None]</code> <p>Tuple of (JsonRpcRequest, None) if valid, or (None, error_response) if invalid</p> Source code in <code>src/asap/transport/server.py</code> <pre><code>def validate_jsonrpc_request(\n    self, body: dict[str, Any]\n) -&gt; tuple[JsonRpcRequest | None, JSONResponse | None]:\n    \"\"\"Validate JSON-RPC request structure and method.\n\n    Args:\n        body: Parsed JSON body\n\n    Returns:\n        Tuple of (JsonRpcRequest, None) if valid, or (None, error_response) if invalid\n    \"\"\"\n    try:\n        rpc_request = JsonRpcRequest(**body)\n    except (ValidationError, TypeError) as e:\n        error_code = INVALID_REQUEST\n        error_message = \"Invalid JSON-RPC structure\"\n        if isinstance(e, ValidationError):\n            errors = e.errors()\n            # If params validation failed with dict_type error, use INVALID_PARAMS\n            for error in errors:\n                if error.get(\"loc\") == (\"params\",) and error.get(\"type\") == \"dict_type\":\n                    error_code = INVALID_PARAMS\n                    error_message = \"JSON-RPC 'params' must be an object\"\n                    break\n\n        log_struct: dict[str, Any] = {\n            \"error\": error_message,\n            \"error_type\": type(e).__name__,\n            \"validation_errors\": (\n                e.errors()\n                if isinstance(e, ValidationError)\n                else [{\"type\": \"type_error\", \"loc\": (), \"msg\": str(e), \"input\": None}]\n            ),\n        }\n        if not is_debug_mode():\n            log_struct = sanitize_for_logging(log_struct)\n        logger.warning(\"asap.request.invalid_structure\", **log_struct)\n        error_response = self.build_error_response(\n            error_code,\n            data={\n                \"error\": error_message,\n                \"validation_errors\": (\n                    e.errors()\n                    if isinstance(e, ValidationError)\n                    else [{\"type\": \"type_error\", \"loc\": (), \"msg\": str(e), \"input\": None}]\n                ),\n            },\n            request_id=body.get(\"id\") if isinstance(body, dict) else None,\n        )\n        return None, error_response\n\n    if rpc_request.method != ASAP_METHOD:\n        logger.warning(\"asap.request.unknown_method\", method=rpc_request.method)\n        error_response = self.build_error_response(\n            METHOD_NOT_FOUND,\n            data={\"method\": rpc_request.method},\n            request_id=rpc_request.id,\n        )\n        return None, error_response\n\n    return rpc_request, None\n</code></pre>"},{"location":"api-reference/#asap.transport.ASAPTimeoutError","title":"<code>ASAPTimeoutError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when request to remote agent times out.</p> <p>This error occurs when the HTTP request exceeds the configured timeout duration.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Error description</p> <code>timeout</code> <p>Timeout value in seconds</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>class ASAPTimeoutError(Exception):\n    \"\"\"Raised when request to remote agent times out.\n\n    This error occurs when the HTTP request exceeds the configured\n    timeout duration.\n\n    Attributes:\n        message: Error description\n        timeout: Timeout value in seconds\n    \"\"\"\n\n    def __init__(self, message: str, timeout: float | None = None) -&gt; None:\n        super().__init__(message)\n        self.message = message\n        self.timeout = timeout\n</code></pre>"},{"location":"api-reference/#asap.transport.CompressionAlgorithm","title":"<code>CompressionAlgorithm</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported compression algorithms.</p> Source code in <code>src/asap/transport/compression.py</code> <pre><code>class CompressionAlgorithm(str, Enum):\n    \"\"\"Supported compression algorithms.\"\"\"\n\n    GZIP = \"gzip\"\n    BROTLI = \"br\"\n    IDENTITY = \"identity\"  # No compression\n</code></pre>"},{"location":"api-reference/#asap.transport.DeadLetterEntry","title":"<code>DeadLetterEntry</code>  <code>dataclass</code>","text":"<p>Permanently failed webhook: url, payload, last_result, attempts, created_at.</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass DeadLetterEntry:\n    \"\"\"Permanently failed webhook: url, payload, last_result, attempts, created_at.\"\"\"\n\n    url: str\n    payload: dict[str, Any]\n    last_result: WebhookResult\n    attempts: int\n    created_at: float = field(default_factory=time.time)\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerNotFoundError","title":"<code>HandlerNotFoundError</code>","text":"<p>               Bases: <code>ASAPError</code></p> <p>Raised when no handler is registered for a payload type.</p> <p>This error occurs when attempting to dispatch an envelope with a payload_type that has no registered handler.</p> <p>Attributes:</p> Name Type Description <code>payload_type</code> <p>The payload type that has no handler</p> Example <p>try: ...     raise HandlerNotFoundError(\"task.request\") ... except HandlerNotFoundError as exc: ...     exc.payload_type 'task.request'</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>class HandlerNotFoundError(ASAPError):\n    \"\"\"Raised when no handler is registered for a payload type.\n\n    This error occurs when attempting to dispatch an envelope with\n    a payload_type that has no registered handler.\n\n    Attributes:\n        payload_type: The payload type that has no handler\n\n    Example:\n        &gt;&gt;&gt; try:\n        ...     raise HandlerNotFoundError(\"task.request\")\n        ... except HandlerNotFoundError as exc:\n        ...     exc.payload_type\n        'task.request'\n    \"\"\"\n\n    def __init__(self, payload_type: str) -&gt; None:\n        message = f\"No handler registered for payload type: {payload_type}\"\n        super().__init__(\n            code=\"asap:transport/handler_not_found\",\n            message=message,\n            details={\"payload_type\": payload_type},\n        )\n        self.payload_type = payload_type\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerRegistry","title":"<code>HandlerRegistry</code>","text":"<p>Registry for ASAP payload handlers.</p> <p>HandlerRegistry manages the mapping between payload types and their corresponding handlers. It provides methods for registration, dispatch, and discovery of handlers.</p> Thread Safety <p>All public methods are thread-safe. The registry uses an internal RLock to protect concurrent access to the handler mapping. This allows safe concurrent registration and dispatch operations from multiple threads.</p> <p>Attributes:</p> Name Type Description <code>_handlers</code> <code>dict[str, Handler]</code> <p>Internal mapping of payload_type to handler function</p> <code>_lock</code> <p>Reentrant lock for thread-safe operations</p> <code>_executor</code> <code>Executor | None</code> <p>Optional executor for running sync handlers (for DoS prevention)</p> Example <p>registry = HandlerRegistry() registry.register(\"task.request\", my_handler) registry.has_handler(\"task.request\") True response = registry.dispatch(envelope, manifest)</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Registry for ASAP payload handlers.\n\n    HandlerRegistry manages the mapping between payload types and their\n    corresponding handlers. It provides methods for registration, dispatch,\n    and discovery of handlers.\n\n    Thread Safety:\n        All public methods are thread-safe. The registry uses an internal\n        RLock to protect concurrent access to the handler mapping. This\n        allows safe concurrent registration and dispatch operations from\n        multiple threads.\n\n    Attributes:\n        _handlers: Internal mapping of payload_type to handler function\n        _lock: Reentrant lock for thread-safe operations\n        _executor: Optional executor for running sync handlers (for DoS prevention)\n\n    Example:\n        &gt;&gt;&gt; registry = HandlerRegistry()\n        &gt;&gt;&gt; registry.register(\"task.request\", my_handler)\n        &gt;&gt;&gt; registry.has_handler(\"task.request\")\n        True\n        &gt;&gt;&gt; response = registry.dispatch(envelope, manifest)\n    \"\"\"\n\n    def __init__(\n        self,\n        executor: Executor | None = None,\n        metering_store: object | None = None,\n    ) -&gt; None:\n        self._handlers: dict[str, Handler] = {}\n        self._lock = RLock()\n        self._executor: Executor | None = executor\n        self._metering_store = metering_store\n\n    def register(self, payload_type: str, handler: Handler) -&gt; None:\n        validate_handler(handler)\n        with self._lock:\n            is_override = payload_type in self._handlers\n            self._handlers[payload_type] = handler\n            logger.debug(\n                \"asap.handler.registered\",\n                payload_type=payload_type,\n                handler_name=handler.__name__ if hasattr(handler, \"__name__\") else str(handler),\n                is_override=is_override,\n            )\n\n    def has_handler(self, payload_type: str) -&gt; bool:\n        with self._lock:\n            return payload_type in self._handlers\n\n    def set_metering_store(self, store: object | None) -&gt; None:\n        \"\"\"Set MeteringStore for usage recording (optional).\n\n        When set, task.request completions are recorded to the store.\n        \"\"\"\n        self._metering_store = store\n\n    def dispatch(self, envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n        \"\"\"Dispatch an envelope to its registered handler.\n\n        Looks up the handler for the envelope's payload_type and\n        invokes it with the envelope and manifest.\n\n        This method is thread-safe for handler lookup. The handler\n        execution itself is not protected by the lock.\n\n        Args:\n            envelope: The incoming ASAP envelope\n            manifest: The server's manifest for context\n\n        Returns:\n            Response envelope from the handler\n\n        Raises:\n            HandlerNotFoundError: If no handler is registered for the payload type\n\n        Example:\n            &gt;&gt;&gt; registry = create_default_registry()\n            &gt;&gt;&gt; response = registry.dispatch(envelope, manifest)\n        \"\"\"\n        payload_type = envelope.payload_type\n        start_time = time.perf_counter()\n\n        with self._lock:\n            if payload_type not in self._handlers:\n                logger.warning(\n                    \"asap.handler.not_found\",\n                    payload_type=payload_type,\n                    envelope_id=envelope.id,\n                )\n                raise HandlerNotFoundError(payload_type)\n            handler = self._handlers[payload_type]\n\n        logger.debug(\n            \"asap.handler.dispatch\",\n            payload_type=payload_type,\n            envelope_id=envelope.id,\n            handler_name=handler.__name__ if hasattr(handler, \"__name__\") else str(handler),\n        )\n\n        try:\n            result = handler(envelope, manifest)\n            if inspect.isawaitable(result):\n                if inspect.iscoroutine(result):\n                    result.close()\n                raise TypeError(\n                    f\"Handler {handler} returned awaitable in sync dispatch(). \"\n                    \"Use dispatch_async() for async handlers.\"\n                )\n            response: Envelope = result\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            logger.debug(\n                \"asap.handler.completed\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n                response_id=response.id,\n                duration_ms=round(duration_ms, 2),\n            )\n            return response\n        except Exception as e:\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            logger.exception(\n                \"asap.handler.error\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n                error=str(e),\n                error_type=type(e).__name__,\n                duration_ms=round(duration_ms, 2),\n            )\n            raise\n\n    async def dispatch_async(self, envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n        \"\"\"Dispatch an envelope to its registered handler (async version).\n\n        This method supports both synchronous and asynchronous handlers.\n        When called from an async context (e.g., FastAPI endpoint), this\n        method will properly await async handlers and run sync handlers\n        in a thread pool to avoid blocking the event loop.\n\n        Args:\n            envelope: The ASAP envelope to dispatch\n            manifest: The server's manifest for context\n\n        Returns:\n            Response envelope from the handler\n\n        Raises:\n            HandlerNotFoundError: If no handler is registered for the payload type\n\n        Example:\n            &gt;&gt;&gt; registry = create_default_registry()\n            &gt;&gt;&gt; response = await registry.dispatch_async(envelope, manifest)\n        \"\"\"\n        payload_type = envelope.payload_type\n        start_time = time.perf_counter()\n\n        with self._lock:\n            if payload_type not in self._handlers:\n                logger.warning(\n                    \"asap.handler.not_found\",\n                    payload_type=payload_type,\n                    envelope_id=envelope.id,\n                )\n                raise HandlerNotFoundError(payload_type)\n            handler = self._handlers[payload_type]\n\n        logger.debug(\n            \"asap.handler.dispatch\",\n            payload_type=payload_type,\n            envelope_id=envelope.id,\n            handler_name=handler.__name__ if hasattr(handler, \"__name__\") else str(handler),\n        )\n\n        agent_urn = manifest.id\n        with handler_span_context(\n            payload_type=payload_type,\n            agent_urn=agent_urn,\n            envelope_id=envelope.id,\n        ):\n            try:\n                response: Envelope\n                if inspect.iscoroutinefunction(handler):\n                    response = await handler(envelope, manifest)\n                else:\n                    loop = asyncio.get_running_loop()\n                    executor = self._executor if self._executor is not None else None\n                    result: object = await loop.run_in_executor(\n                        executor, handler, envelope, manifest\n                    )\n                    if inspect.isawaitable(result):\n                        response = await result\n                    else:\n                        response = cast(Envelope, result)\n\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                duration_seconds = duration_ms / 1000.0\n                logger.debug(\n                    \"asap.handler.completed\",\n                    payload_type=payload_type,\n                    envelope_id=envelope.id,\n                    response_id=response.id,\n                    duration_ms=round(duration_ms, 2),\n                )\n                metrics = get_metrics()\n                metrics.increment_counter(\n                    \"asap_handler_executions_total\",\n                    {\"payload_type\": payload_type},\n                )\n                metrics.observe_histogram(\n                    \"asap_handler_duration_seconds\",\n                    duration_seconds,\n                    {\"payload_type\": payload_type},\n                )\n                if self._metering_store is not None:\n                    from asap.state.metering import MeteringStore\n\n                    await record_task_usage(\n                        cast(MeteringStore, self._metering_store),\n                        envelope,\n                        response,\n                        duration_ms,\n                        manifest,\n                    )\n                return response\n            except Exception as e:\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                get_metrics().increment_counter(\n                    \"asap_handler_errors_total\",\n                    {\"payload_type\": payload_type},\n                )\n                logger.exception(\n                    \"asap.handler.error\",\n                    payload_type=payload_type,\n                    envelope_id=envelope.id,\n                    error=str(e),\n                    error_type=type(e).__name__,\n                    duration_ms=round(duration_ms, 2),\n                )\n                raise\n\n    def list_handlers(self) -&gt; list[str]:\n        \"\"\"List all registered payload types.\n\n        This method is thread-safe. Returns a copy of the keys list.\n\n        Returns:\n            List of payload type strings that have registered handlers\n\n        Example:\n            &gt;&gt;&gt; registry = create_default_registry()\n            &gt;&gt;&gt; registry.list_handlers()\n            ['task.request']\n        \"\"\"\n        with self._lock:\n            return list(self._handlers.keys())\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerRegistry.dispatch","title":"<code>dispatch(envelope, manifest)</code>","text":"<p>Dispatch an envelope to its registered handler.</p> <p>Looks up the handler for the envelope's payload_type and invokes it with the envelope and manifest.</p> <p>This method is thread-safe for handler lookup. The handler execution itself is not protected by the lock.</p> <p>Parameters:</p> Name Type Description Default <code>envelope</code> <code>Envelope</code> <p>The incoming ASAP envelope</p> required <code>manifest</code> <code>Manifest</code> <p>The server's manifest for context</p> required <p>Returns:</p> Type Description <code>Envelope</code> <p>Response envelope from the handler</p> <p>Raises:</p> Type Description <code>HandlerNotFoundError</code> <p>If no handler is registered for the payload type</p> Example <p>registry = create_default_registry() response = registry.dispatch(envelope, manifest)</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>def dispatch(self, envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n    \"\"\"Dispatch an envelope to its registered handler.\n\n    Looks up the handler for the envelope's payload_type and\n    invokes it with the envelope and manifest.\n\n    This method is thread-safe for handler lookup. The handler\n    execution itself is not protected by the lock.\n\n    Args:\n        envelope: The incoming ASAP envelope\n        manifest: The server's manifest for context\n\n    Returns:\n        Response envelope from the handler\n\n    Raises:\n        HandlerNotFoundError: If no handler is registered for the payload type\n\n    Example:\n        &gt;&gt;&gt; registry = create_default_registry()\n        &gt;&gt;&gt; response = registry.dispatch(envelope, manifest)\n    \"\"\"\n    payload_type = envelope.payload_type\n    start_time = time.perf_counter()\n\n    with self._lock:\n        if payload_type not in self._handlers:\n            logger.warning(\n                \"asap.handler.not_found\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n            )\n            raise HandlerNotFoundError(payload_type)\n        handler = self._handlers[payload_type]\n\n    logger.debug(\n        \"asap.handler.dispatch\",\n        payload_type=payload_type,\n        envelope_id=envelope.id,\n        handler_name=handler.__name__ if hasattr(handler, \"__name__\") else str(handler),\n    )\n\n    try:\n        result = handler(envelope, manifest)\n        if inspect.isawaitable(result):\n            if inspect.iscoroutine(result):\n                result.close()\n            raise TypeError(\n                f\"Handler {handler} returned awaitable in sync dispatch(). \"\n                \"Use dispatch_async() for async handlers.\"\n            )\n        response: Envelope = result\n        duration_ms = (time.perf_counter() - start_time) * 1000\n        logger.debug(\n            \"asap.handler.completed\",\n            payload_type=payload_type,\n            envelope_id=envelope.id,\n            response_id=response.id,\n            duration_ms=round(duration_ms, 2),\n        )\n        return response\n    except Exception as e:\n        duration_ms = (time.perf_counter() - start_time) * 1000\n        logger.exception(\n            \"asap.handler.error\",\n            payload_type=payload_type,\n            envelope_id=envelope.id,\n            error=str(e),\n            error_type=type(e).__name__,\n            duration_ms=round(duration_ms, 2),\n        )\n        raise\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerRegistry.dispatch_async","title":"<code>dispatch_async(envelope, manifest)</code>  <code>async</code>","text":"<p>Dispatch an envelope to its registered handler (async version).</p> <p>This method supports both synchronous and asynchronous handlers. When called from an async context (e.g., FastAPI endpoint), this method will properly await async handlers and run sync handlers in a thread pool to avoid blocking the event loop.</p> <p>Parameters:</p> Name Type Description Default <code>envelope</code> <code>Envelope</code> <p>The ASAP envelope to dispatch</p> required <code>manifest</code> <code>Manifest</code> <p>The server's manifest for context</p> required <p>Returns:</p> Type Description <code>Envelope</code> <p>Response envelope from the handler</p> <p>Raises:</p> Type Description <code>HandlerNotFoundError</code> <p>If no handler is registered for the payload type</p> Example <p>registry = create_default_registry() response = await registry.dispatch_async(envelope, manifest)</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>async def dispatch_async(self, envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n    \"\"\"Dispatch an envelope to its registered handler (async version).\n\n    This method supports both synchronous and asynchronous handlers.\n    When called from an async context (e.g., FastAPI endpoint), this\n    method will properly await async handlers and run sync handlers\n    in a thread pool to avoid blocking the event loop.\n\n    Args:\n        envelope: The ASAP envelope to dispatch\n        manifest: The server's manifest for context\n\n    Returns:\n        Response envelope from the handler\n\n    Raises:\n        HandlerNotFoundError: If no handler is registered for the payload type\n\n    Example:\n        &gt;&gt;&gt; registry = create_default_registry()\n        &gt;&gt;&gt; response = await registry.dispatch_async(envelope, manifest)\n    \"\"\"\n    payload_type = envelope.payload_type\n    start_time = time.perf_counter()\n\n    with self._lock:\n        if payload_type not in self._handlers:\n            logger.warning(\n                \"asap.handler.not_found\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n            )\n            raise HandlerNotFoundError(payload_type)\n        handler = self._handlers[payload_type]\n\n    logger.debug(\n        \"asap.handler.dispatch\",\n        payload_type=payload_type,\n        envelope_id=envelope.id,\n        handler_name=handler.__name__ if hasattr(handler, \"__name__\") else str(handler),\n    )\n\n    agent_urn = manifest.id\n    with handler_span_context(\n        payload_type=payload_type,\n        agent_urn=agent_urn,\n        envelope_id=envelope.id,\n    ):\n        try:\n            response: Envelope\n            if inspect.iscoroutinefunction(handler):\n                response = await handler(envelope, manifest)\n            else:\n                loop = asyncio.get_running_loop()\n                executor = self._executor if self._executor is not None else None\n                result: object = await loop.run_in_executor(\n                    executor, handler, envelope, manifest\n                )\n                if inspect.isawaitable(result):\n                    response = await result\n                else:\n                    response = cast(Envelope, result)\n\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            duration_seconds = duration_ms / 1000.0\n            logger.debug(\n                \"asap.handler.completed\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n                response_id=response.id,\n                duration_ms=round(duration_ms, 2),\n            )\n            metrics = get_metrics()\n            metrics.increment_counter(\n                \"asap_handler_executions_total\",\n                {\"payload_type\": payload_type},\n            )\n            metrics.observe_histogram(\n                \"asap_handler_duration_seconds\",\n                duration_seconds,\n                {\"payload_type\": payload_type},\n            )\n            if self._metering_store is not None:\n                from asap.state.metering import MeteringStore\n\n                await record_task_usage(\n                    cast(MeteringStore, self._metering_store),\n                    envelope,\n                    response,\n                    duration_ms,\n                    manifest,\n                )\n            return response\n        except Exception as e:\n            duration_ms = (time.perf_counter() - start_time) * 1000\n            get_metrics().increment_counter(\n                \"asap_handler_errors_total\",\n                {\"payload_type\": payload_type},\n            )\n            logger.exception(\n                \"asap.handler.error\",\n                payload_type=payload_type,\n                envelope_id=envelope.id,\n                error=str(e),\n                error_type=type(e).__name__,\n                duration_ms=round(duration_ms, 2),\n            )\n            raise\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerRegistry.list_handlers","title":"<code>list_handlers()</code>","text":"<p>List all registered payload types.</p> <p>This method is thread-safe. Returns a copy of the keys list.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of payload type strings that have registered handlers</p> Example <p>registry = create_default_registry() registry.list_handlers() ['task.request']</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>def list_handlers(self) -&gt; list[str]:\n    \"\"\"List all registered payload types.\n\n    This method is thread-safe. Returns a copy of the keys list.\n\n    Returns:\n        List of payload type strings that have registered handlers\n\n    Example:\n        &gt;&gt;&gt; registry = create_default_registry()\n        &gt;&gt;&gt; registry.list_handlers()\n        ['task.request']\n    \"\"\"\n    with self._lock:\n        return list(self._handlers.keys())\n</code></pre>"},{"location":"api-reference/#asap.transport.HandlerRegistry.set_metering_store","title":"<code>set_metering_store(store)</code>","text":"<p>Set MeteringStore for usage recording (optional).</p> <p>When set, task.request completions are recorded to the store.</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>def set_metering_store(self, store: object | None) -&gt; None:\n    \"\"\"Set MeteringStore for usage recording (optional).\n\n    When set, task.request completions are recorded to the store.\n    \"\"\"\n    self._metering_store = store\n</code></pre>"},{"location":"api-reference/#asap.transport.JsonRpcError","title":"<code>JsonRpcError</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>JSON-RPC 2.0 error object.</p> <p>Represents an error that occurred during request processing. Follows JSON-RPC 2.0 specification for error responses.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>Integer error code (standard or application-defined)</p> <code>message</code> <code>str</code> <p>Short error description</p> <code>data</code> <code>dict[str, Any] | None</code> <p>Optional additional error information</p> Example <p>error = JsonRpcError( ...     code=-32602, ...     message=\"Invalid params\", ...     data={\"missing_field\": \"task_id\"} ... ) error.code -32602</p> Source code in <code>src/asap/transport/jsonrpc.py</code> <pre><code>class JsonRpcError(ASAPBaseModel):\n    \"\"\"JSON-RPC 2.0 error object.\n\n    Represents an error that occurred during request processing.\n    Follows JSON-RPC 2.0 specification for error responses.\n\n    Attributes:\n        code: Integer error code (standard or application-defined)\n        message: Short error description\n        data: Optional additional error information\n\n    Example:\n        &gt;&gt;&gt; error = JsonRpcError(\n        ...     code=-32602,\n        ...     message=\"Invalid params\",\n        ...     data={\"missing_field\": \"task_id\"}\n        ... )\n        &gt;&gt;&gt; error.code\n        -32602\n    \"\"\"\n\n    code: int = Field(description=\"Error code (negative integer)\")\n    message: str = Field(description=\"Short error description\")\n    data: dict[str, Any] | None = Field(\n        default=None, description=\"Optional additional error information\"\n    )\n\n    @staticmethod\n    def from_code(code: int, data: dict[str, Any] | None = None) -&gt; \"JsonRpcError\":\n        \"\"\"Create error from standard error code.\n\n        Args:\n            code: Standard JSON-RPC error code\n            data: Optional additional error information\n\n        Returns:\n            JsonRpcError instance with standard message\n\n        Example:\n            &gt;&gt;&gt; error = JsonRpcError.from_code(INVALID_PARAMS, data={\"field\": \"task_id\"})\n            &gt;&gt;&gt; error.message\n            'Invalid params'\n        \"\"\"\n        message = ERROR_MESSAGES.get(code, \"Unknown error\")\n        return JsonRpcError(code=code, message=message, data=data)\n</code></pre>"},{"location":"api-reference/#asap.transport.JsonRpcError.from_code","title":"<code>from_code(code, data=None)</code>  <code>staticmethod</code>","text":"<p>Create error from standard error code.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>Standard JSON-RPC error code</p> required <code>data</code> <code>dict[str, Any] | None</code> <p>Optional additional error information</p> <code>None</code> <p>Returns:</p> Type Description <code>'JsonRpcError'</code> <p>JsonRpcError instance with standard message</p> Example <p>error = JsonRpcError.from_code(INVALID_PARAMS, data={\"field\": \"task_id\"}) error.message 'Invalid params'</p> Source code in <code>src/asap/transport/jsonrpc.py</code> <pre><code>@staticmethod\ndef from_code(code: int, data: dict[str, Any] | None = None) -&gt; \"JsonRpcError\":\n    \"\"\"Create error from standard error code.\n\n    Args:\n        code: Standard JSON-RPC error code\n        data: Optional additional error information\n\n    Returns:\n        JsonRpcError instance with standard message\n\n    Example:\n        &gt;&gt;&gt; error = JsonRpcError.from_code(INVALID_PARAMS, data={\"field\": \"task_id\"})\n        &gt;&gt;&gt; error.message\n        'Invalid params'\n    \"\"\"\n    message = ERROR_MESSAGES.get(code, \"Unknown error\")\n    return JsonRpcError(code=code, message=message, data=data)\n</code></pre>"},{"location":"api-reference/#asap.transport.JsonRpcErrorResponse","title":"<code>JsonRpcErrorResponse</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>JSON-RPC 2.0 error response.</p> <p>Returned when a request fails or cannot be processed.</p> <p>Attributes:</p> Name Type Description <code>jsonrpc</code> <code>Literal['2.0']</code> <p>Protocol version (always \"2.0\")</p> <code>error</code> <code>JsonRpcError</code> <p>Error object with code, message, and optional data</p> <code>id</code> <code>str | int | None</code> <p>Request identifier (matches request, or null if id unavailable)</p> Example <p>error_response = JsonRpcErrorResponse( ...     error=JsonRpcError(code=-32602, message=\"Invalid params\"), ...     id=\"req-123\" ... ) error_response.error.code -32602</p> Source code in <code>src/asap/transport/jsonrpc.py</code> <pre><code>class JsonRpcErrorResponse(ASAPBaseModel):\n    \"\"\"JSON-RPC 2.0 error response.\n\n    Returned when a request fails or cannot be processed.\n\n    Attributes:\n        jsonrpc: Protocol version (always \"2.0\")\n        error: Error object with code, message, and optional data\n        id: Request identifier (matches request, or null if id unavailable)\n\n    Example:\n        &gt;&gt;&gt; error_response = JsonRpcErrorResponse(\n        ...     error=JsonRpcError(code=-32602, message=\"Invalid params\"),\n        ...     id=\"req-123\"\n        ... )\n        &gt;&gt;&gt; error_response.error.code\n        -32602\n    \"\"\"\n\n    jsonrpc: Literal[\"2.0\"] = Field(\n        default=\"2.0\", description=\"JSON-RPC protocol version (always '2.0')\"\n    )\n    error: JsonRpcError = Field(description=\"Error object\")\n    id: str | int | None = Field(description=\"Request identifier (or null)\")\n</code></pre>"},{"location":"api-reference/#asap.transport.JsonRpcRequest","title":"<code>JsonRpcRequest</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>JSON-RPC 2.0 request.</p> <p>Wraps an ASAP Envelope in a JSON-RPC request structure. The envelope is passed in the params field.</p> <p>Attributes:</p> Name Type Description <code>jsonrpc</code> <code>Literal['2.0']</code> <p>Protocol version (always \"2.0\")</p> <code>method</code> <code>str</code> <p>RPC method name (typically \"asap.send\")</p> <code>params</code> <code>dict[str, Any]</code> <p>Request parameters (contains ASAP envelope)</p> <code>id</code> <code>str | int</code> <p>Request identifier for correlation</p> Example <p>request = JsonRpcRequest( ...     method=\"asap.send\", ...     params={\"envelope\": {...}}, ...     id=\"req-123\" ... ) request.jsonrpc '2.0'</p> Source code in <code>src/asap/transport/jsonrpc.py</code> <pre><code>class JsonRpcRequest(ASAPBaseModel):\n    \"\"\"JSON-RPC 2.0 request.\n\n    Wraps an ASAP Envelope in a JSON-RPC request structure.\n    The envelope is passed in the params field.\n\n    Attributes:\n        jsonrpc: Protocol version (always \"2.0\")\n        method: RPC method name (typically \"asap.send\")\n        params: Request parameters (contains ASAP envelope)\n        id: Request identifier for correlation\n\n    Example:\n        &gt;&gt;&gt; request = JsonRpcRequest(\n        ...     method=\"asap.send\",\n        ...     params={\"envelope\": {...}},\n        ...     id=\"req-123\"\n        ... )\n        &gt;&gt;&gt; request.jsonrpc\n        '2.0'\n    \"\"\"\n\n    jsonrpc: Literal[\"2.0\"] = Field(\n        default=\"2.0\", description=\"JSON-RPC protocol version (always '2.0')\"\n    )\n    method: str = Field(description=\"RPC method name\")\n    params: dict[str, Any] = Field(description=\"Request parameters\")\n    id: str | int = Field(description=\"Request identifier for correlation\")\n</code></pre>"},{"location":"api-reference/#asap.transport.JsonRpcResponse","title":"<code>JsonRpcResponse</code>","text":"<p>               Bases: <code>ASAPBaseModel</code></p> <p>JSON-RPC 2.0 successful response.</p> <p>Wraps an ASAP Envelope response or other result data.</p> <p>Attributes:</p> Name Type Description <code>jsonrpc</code> <code>Literal['2.0']</code> <p>Protocol version (always \"2.0\")</p> <code>result</code> <code>dict[str, Any]</code> <p>Response data (ASAP envelope or other result)</p> <code>id</code> <code>str | int</code> <p>Request identifier (matches original request)</p> Example <p>response = JsonRpcResponse( ...     result={\"envelope\": {...}}, ...     id=\"req-123\" ... ) response.jsonrpc '2.0'</p> Source code in <code>src/asap/transport/jsonrpc.py</code> <pre><code>class JsonRpcResponse(ASAPBaseModel):\n    \"\"\"JSON-RPC 2.0 successful response.\n\n    Wraps an ASAP Envelope response or other result data.\n\n    Attributes:\n        jsonrpc: Protocol version (always \"2.0\")\n        result: Response data (ASAP envelope or other result)\n        id: Request identifier (matches original request)\n\n    Example:\n        &gt;&gt;&gt; response = JsonRpcResponse(\n        ...     result={\"envelope\": {...}},\n        ...     id=\"req-123\"\n        ... )\n        &gt;&gt;&gt; response.jsonrpc\n        '2.0'\n    \"\"\"\n\n    jsonrpc: Literal[\"2.0\"] = Field(\n        default=\"2.0\", description=\"JSON-RPC protocol version (always '2.0')\"\n    )\n    result: dict[str, Any] = Field(description=\"Response data\")\n    id: str | int = Field(description=\"Request identifier (matches request)\")\n</code></pre>"},{"location":"api-reference/#asap.transport.ManifestCache","title":"<code>ManifestCache</code>","text":"<p>Thread-safe in-memory LRU cache for agent manifests.</p> <p>Provides TTL-based expiration, LRU eviction when max_size is reached, and methods for cache management. Thread-safe for concurrent access from multiple async tasks.</p> <p>Attributes:</p> Name Type Description <code>_cache</code> <code>OrderedDict[str, CacheEntry]</code> <p>OrderedDict mapping URL to CacheEntry (maintains LRU order)</p> <code>_lock</code> <p>Lock for thread-safe access</p> <code>_default_ttl</code> <p>Default TTL in seconds</p> <code>_max_size</code> <p>Maximum number of entries (0 for unlimited)</p> Example <p>cache = ManifestCache(default_ttl=300.0, max_size=100) cache.set(\"http://agent.example.com/manifest.json\", manifest, ttl=300.0) cached = cache.get(\"http://agent.example.com/manifest.json\") if cached: ...     print(cached.id)</p> Source code in <code>src/asap/transport/cache.py</code> <pre><code>class ManifestCache:\n    \"\"\"Thread-safe in-memory LRU cache for agent manifests.\n\n    Provides TTL-based expiration, LRU eviction when max_size is reached,\n    and methods for cache management. Thread-safe for concurrent access\n    from multiple async tasks.\n\n    Attributes:\n        _cache: OrderedDict mapping URL to CacheEntry (maintains LRU order)\n        _lock: Lock for thread-safe access\n        _default_ttl: Default TTL in seconds\n        _max_size: Maximum number of entries (0 for unlimited)\n\n    Example:\n        &gt;&gt;&gt; cache = ManifestCache(default_ttl=300.0, max_size=100)\n        &gt;&gt;&gt; cache.set(\"http://agent.example.com/manifest.json\", manifest, ttl=300.0)\n        &gt;&gt;&gt; cached = cache.get(\"http://agent.example.com/manifest.json\")\n        &gt;&gt;&gt; if cached:\n        ...     print(cached.id)\n    \"\"\"\n\n    def __init__(\n        self,\n        default_ttl: float = DEFAULT_TTL,\n        max_size: int = DEFAULT_MAX_SIZE,\n    ) -&gt; None:\n        self._cache: OrderedDict[str, CacheEntry] = OrderedDict()\n        self._lock = Lock()\n        self._default_ttl = default_ttl\n        self._max_size = max_size\n\n    def get(self, url: str) -&gt; Optional[Manifest]:\n        with self._lock:\n            entry = self._cache.get(url)\n            if entry is None:\n                return None\n            if entry.is_expired():\n                del self._cache[url]\n                return None\n            self._cache.move_to_end(url)\n            return entry.manifest\n\n    def set(self, url: str, manifest: Manifest, ttl: Optional[float] = None) -&gt; None:\n        if ttl is None:\n            ttl = self._default_ttl\n        with self._lock:\n            if url in self._cache:\n                del self._cache[url]\n            elif self._max_size &gt; 0:\n                while len(self._cache) &gt;= self._max_size:\n                    self._cache.popitem(last=False)\n            self._cache[url] = CacheEntry(manifest, ttl)\n\n    def invalidate(self, url: str) -&gt; None:\n        with self._lock:\n            self._cache.pop(url, None)\n\n    def clear_all(self) -&gt; None:\n        with self._lock:\n            self._cache.clear()\n\n    def size(self) -&gt; int:\n        with self._lock:\n            return len(self._cache)\n\n    @property\n    def max_size(self) -&gt; int:\n        return self._max_size\n\n    def cleanup_expired(self) -&gt; int:\n        \"\"\"Remove all expired entries from cache.\n\n        Holds the lock for O(N). For very large max_size, prefer lazy eviction\n        in get() or call less frequently.\n\n        Returns:\n            Number of expired entries removed\n        \"\"\"\n        with self._lock:\n            expired_urls = [url for url, entry in self._cache.items() if entry.is_expired()]\n            for url in expired_urls:\n                del self._cache[url]\n            return len(expired_urls)\n</code></pre>"},{"location":"api-reference/#asap.transport.ManifestCache.cleanup_expired","title":"<code>cleanup_expired()</code>","text":"<p>Remove all expired entries from cache.</p> <p>Holds the lock for O(N). For very large max_size, prefer lazy eviction in get() or call less frequently.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of expired entries removed</p> Source code in <code>src/asap/transport/cache.py</code> <pre><code>def cleanup_expired(self) -&gt; int:\n    \"\"\"Remove all expired entries from cache.\n\n    Holds the lock for O(N). For very large max_size, prefer lazy eviction\n    in get() or call less frequently.\n\n    Returns:\n        Number of expired entries removed\n    \"\"\"\n    with self._lock:\n        expired_urls = [url for url, entry in self._cache.items() if entry.is_expired()]\n        for url in expired_urls:\n            del self._cache[url]\n        return len(expired_urls)\n</code></pre>"},{"location":"api-reference/#asap.transport.RetryConfig","title":"<code>RetryConfig</code>  <code>dataclass</code>","text":"<p>Configuration for retry logic and circuit breaker.</p> <p>Groups retry and circuit breaker parameters to simplify client initialization and avoid boolean trap issues.</p> <p>Attributes:</p> Name Type Description <code>max_retries</code> <code>int</code> <p>Maximum retry attempts for transient failures (default: 3)</p> <code>base_delay</code> <code>float</code> <p>Base delay in seconds for exponential backoff (default: 1.0)</p> <code>max_delay</code> <code>float</code> <p>Maximum delay in seconds for exponential backoff (default: 60.0)</p> <code>jitter</code> <code>bool</code> <p>Whether to add random jitter to backoff delays (default: True)</p> <code>circuit_breaker_enabled</code> <code>bool</code> <p>Enable circuit breaker pattern (default: False)</p> <code>circuit_breaker_threshold</code> <code>int</code> <p>Number of consecutive failures before opening circuit (default: 5)</p> <code>circuit_breaker_timeout</code> <code>float</code> <p>Seconds before transitioning OPEN -&gt; HALF_OPEN (default: 60.0)</p> Source code in <code>src/asap/transport/client.py</code> <pre><code>@dataclass\nclass RetryConfig:\n    \"\"\"Configuration for retry logic and circuit breaker.\n\n    Groups retry and circuit breaker parameters to simplify client initialization\n    and avoid boolean trap issues.\n\n    Attributes:\n        max_retries: Maximum retry attempts for transient failures (default: 3)\n        base_delay: Base delay in seconds for exponential backoff (default: 1.0)\n        max_delay: Maximum delay in seconds for exponential backoff (default: 60.0)\n        jitter: Whether to add random jitter to backoff delays (default: True)\n        circuit_breaker_enabled: Enable circuit breaker pattern (default: False)\n        circuit_breaker_threshold: Number of consecutive failures before opening circuit (default: 5)\n        circuit_breaker_timeout: Seconds before transitioning OPEN -&gt; HALF_OPEN (default: 60.0)\n    \"\"\"\n\n    max_retries: int = DEFAULT_MAX_RETRIES\n    base_delay: float = DEFAULT_BASE_DELAY\n    max_delay: float = DEFAULT_MAX_DELAY\n    jitter: bool = True\n    circuit_breaker_enabled: bool = False\n    circuit_breaker_threshold: int = DEFAULT_CIRCUIT_BREAKER_THRESHOLD\n    circuit_breaker_timeout: float = DEFAULT_CIRCUIT_BREAKER_TIMEOUT\n</code></pre>"},{"location":"api-reference/#asap.transport.RetryPolicy","title":"<code>RetryPolicy</code>  <code>dataclass</code>","text":"<p>Webhook retry: max_retries, base_delay, max_delay, rate_per_second.</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass RetryPolicy:\n    \"\"\"Webhook retry: max_retries, base_delay, max_delay, rate_per_second.\"\"\"\n\n    max_retries: int = DEFAULT_MAX_RETRIES\n    base_delay: float = DEFAULT_RETRY_BASE_DELAY\n    max_delay: float = DEFAULT_RETRY_MAX_DELAY\n    rate_per_second: float = DEFAULT_WEBHOOK_RATE_PER_SECOND\n\n    def backoff_delay(self, attempt: int) -&gt; float:\n        \"\"\"min(base_delay * 2^attempt, max_delay) seconds.\"\"\"\n        return float(min(self.base_delay * (2**attempt), self.max_delay))\n</code></pre>"},{"location":"api-reference/#asap.transport.RetryPolicy.backoff_delay","title":"<code>backoff_delay(attempt)</code>","text":"<p>min(base_delay * 2^attempt, max_delay) seconds.</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>def backoff_delay(self, attempt: int) -&gt; float:\n    \"\"\"min(base_delay * 2^attempt, max_delay) seconds.\"\"\"\n    return float(min(self.base_delay * (2**attempt), self.max_delay))\n</code></pre>"},{"location":"api-reference/#asap.transport.WebhookDelivery","title":"<code>WebhookDelivery</code>","text":"<p>Delivers webhook payloads via POST to registered callback URLs.</p> <p>Validates callback URLs to prevent SSRF, signs payloads with HMAC-SHA256, and supports configurable timeouts.</p> Example <p>import asyncio delivery = WebhookDelivery(secret=b\"my-secret\", require_https=False) result = asyncio.run(delivery.deliver( ...     \"http://receiver.example.com/hook\", ...     {\"event\": \"task.completed\", \"task_id\": \"abc-123\"}, ... )) print(result.success, result.status_code)</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>class WebhookDelivery:\n    \"\"\"Delivers webhook payloads via POST to registered callback URLs.\n\n    Validates callback URLs to prevent SSRF, signs payloads with HMAC-SHA256,\n    and supports configurable timeouts.\n\n    Example:\n        &gt;&gt;&gt; import asyncio\n        &gt;&gt;&gt; delivery = WebhookDelivery(secret=b\"my-secret\", require_https=False)\n        &gt;&gt;&gt; result = asyncio.run(delivery.deliver(\n        ...     \"http://receiver.example.com/hook\",\n        ...     {\"event\": \"task.completed\", \"task_id\": \"abc-123\"},\n        ... ))\n        &gt;&gt;&gt; print(result.success, result.status_code)\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        secret: bytes | None = None,\n        timeout_seconds: float = DEFAULT_WEBHOOK_TIMEOUT,\n        require_https: bool = True,\n        client: httpx.AsyncClient | None = None,\n    ) -&gt; None:\n        self._secret = secret\n        self._timeout_seconds = timeout_seconds\n        self._require_https = require_https\n        self._external_client = client\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n\n    async def validate_url(self, url: str) -&gt; None:\n        await validate_callback_url(url, require_https=self._require_https)\n\n    async def deliver(\n        self,\n        url: str,\n        payload: dict[str, Any],\n        *,\n        extra_headers: dict[str, str] | None = None,\n    ) -&gt; WebhookResult:\n        await self.validate_url(url)\n\n        body = json.dumps(payload, separators=(\",\", \":\"), sort_keys=True).encode()\n\n        headers: dict[str, str] = {\"Content-Type\": \"application/json\"}\n        if self._secret is not None:\n            headers[X_ASAP_SIGNATURE_HEADER] = compute_signature(body, self._secret)\n        if extra_headers:\n            headers.update(extra_headers)\n\n        start = time.monotonic()\n        try:\n            if self._external_client is not None:\n                response = await self._external_client.post(url, content=body, headers=headers)\n            else:\n                async with httpx.AsyncClient(timeout=self._timeout_seconds) as client:\n                    response = await client.post(url, content=body, headers=headers)\n\n            elapsed_ms = (time.monotonic() - start) * 1000\n            success = 200 &lt;= response.status_code &lt; 300\n\n            logger.info(\n                \"webhook.delivered\",\n                url=url,\n                status_code=response.status_code,\n                success=success,\n                elapsed_ms=round(elapsed_ms, 1),\n            )\n\n            return WebhookResult(\n                url=url,\n                status_code=response.status_code,\n                success=success,\n                elapsed_ms=round(elapsed_ms, 1),\n            )\n\n        except httpx.TimeoutException as exc:\n            elapsed_ms = (time.monotonic() - start) * 1000\n            logger.warning(\n                \"webhook.timeout\",\n                url=url,\n                timeout_seconds=self._timeout_seconds,\n                elapsed_ms=round(elapsed_ms, 1),\n            )\n            return WebhookResult(\n                url=url,\n                status_code=0,\n                success=False,\n                elapsed_ms=round(elapsed_ms, 1),\n                error=f\"Timeout after {self._timeout_seconds}s: {exc}\",\n            )\n\n        except httpx.HTTPError as exc:\n            elapsed_ms = (time.monotonic() - start) * 1000\n            logger.warning(\n                \"webhook.delivery_failed\",\n                url=url,\n                error=str(exc),\n                elapsed_ms=round(elapsed_ms, 1),\n            )\n            return WebhookResult(\n                url=url,\n                status_code=0,\n                success=False,\n                elapsed_ms=round(elapsed_ms, 1),\n                error=str(exc),\n            )\n</code></pre>"},{"location":"api-reference/#asap.transport.WebhookRetryManager","title":"<code>WebhookRetryManager</code>","text":"<p>Delivers webhooks with automatic retry, exponential backoff, per-URL rate limiting, and DLQ.</p> <p>Wraps a <code>WebhookDelivery</code> instance and adds reliability:     * Retry queue \u2014 failed deliveries are re-queued automatically.     * Exponential backoff \u2014 delays double per attempt (1 \u2192 2 \u2192 4 \u2192 8 \u2192 16 s).     * Dead letter queue \u2014 after <code>max_retries</code> the entry is logged and the       optional <code>on_dead_letter</code> callback is invoked.     * Per-URL rate limit \u2014 token bucket prevents flooding a single receiver.</p> Example <p>manager = WebhookRetryManager(delivery, policy=RetryPolicy(max_retries=3)) result = await manager.deliver_with_retry(url, payload)</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>class WebhookRetryManager:\n    \"\"\"Delivers webhooks with automatic retry, exponential backoff, per-URL rate limiting, and DLQ.\n\n    Wraps a ``WebhookDelivery`` instance and adds reliability:\n        * **Retry queue** \u2014 failed deliveries are re-queued automatically.\n        * **Exponential backoff** \u2014 delays double per attempt (1 \u2192 2 \u2192 4 \u2192 8 \u2192 16 s).\n        * **Dead letter queue** \u2014 after ``max_retries`` the entry is logged and the\n          optional ``on_dead_letter`` callback is invoked.\n        * **Per-URL rate limit** \u2014 token bucket prevents flooding a single receiver.\n\n    Example:\n        &gt;&gt;&gt; manager = WebhookRetryManager(delivery, policy=RetryPolicy(max_retries=3))\n        &gt;&gt;&gt; result = await manager.deliver_with_retry(url, payload)\n    \"\"\"\n\n    def __init__(\n        self,\n        delivery: WebhookDelivery,\n        *,\n        policy: RetryPolicy | None = None,\n        on_dead_letter: DeadLetterCallback | None = None,\n    ) -&gt; None:\n        self._delivery = delivery\n        self._policy = policy or RetryPolicy()\n        self._on_dead_letter = on_dead_letter\n        self._dead_letters: list[DeadLetterEntry] = []\n        self._url_buckets: dict[str, _URLTokenBucket] = {}\n        self._max_buckets = 10_000\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n\n    @property\n    def dead_letters(self) -&gt; list[DeadLetterEntry]:\n        return list(self._dead_letters)\n\n    async def deliver_with_retry(\n        self,\n        url: str,\n        payload: dict[str, Any],\n        *,\n        extra_headers: dict[str, str] | None = None,\n    ) -&gt; WebhookResult:\n        \"\"\"Deliver with retry on 5xx/network error; no retry on 4xx; DLQ after max_retries.\"\"\"\n        last_result: WebhookResult | None = None\n\n        for attempt in range(1 + self._policy.max_retries):\n            # Per-URL rate limiting \u2014 wait until a token is available.\n            await self._wait_for_rate_limit(url)\n\n            last_result = await self._delivery.deliver(\n                url,\n                payload,\n                extra_headers=extra_headers,\n            )\n\n            if last_result.success:\n                return last_result\n\n            # 4xx \u2192 do not retry (client error, the request itself is wrong).\n            if last_result.status_code in _NON_RETRYABLE_STATUS_RANGE:\n                logger.info(\n                    \"webhook.retry.non_retryable\",\n                    url=url,\n                    status_code=last_result.status_code,\n                    attempt=attempt + 1,\n                )\n                return last_result\n\n            # Last attempt \u2014 don't sleep, go straight to DLQ.\n            if attempt == self._policy.max_retries:\n                break\n\n            delay = self._policy.backoff_delay(attempt)\n            logger.info(\n                \"webhook.retry.backoff\",\n                url=url,\n                attempt=attempt + 1,\n                max_retries=self._policy.max_retries,\n                delay_seconds=delay,\n                status_code=last_result.status_code,\n                error=last_result.error,\n            )\n            await asyncio.sleep(delay)\n\n        # All retries exhausted \u2192 dead letter queue.\n        assert last_result is not None  # At least one attempt was made.\n        await self._send_to_dead_letter(url, payload, last_result)\n        return last_result\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    def _get_bucket(self, url: str) -&gt; _URLTokenBucket:\n        bucket = self._url_buckets.get(url)\n        if bucket is None:\n            # Evict oldest entry if at capacity to prevent unbounded growth.\n            if len(self._url_buckets) &gt;= self._max_buckets:\n                oldest_key = next(iter(self._url_buckets))\n                del self._url_buckets[oldest_key]\n                logger.debug(\n                    \"webhook.bucket_evicted\",\n                    evicted_url=oldest_key,\n                    capacity=self._max_buckets,\n                )\n            bucket = _URLTokenBucket(rate=self._policy.rate_per_second)\n            self._url_buckets[url] = bucket\n        return bucket\n\n    async def _wait_for_rate_limit(self, url: str) -&gt; None:\n        bucket = self._get_bucket(url)\n        while not bucket.consume():\n            wait = bucket.seconds_until_available()\n            logger.debug(\n                \"webhook.rate_limit.waiting\",\n                url=url,\n                wait_seconds=round(wait, 3),\n            )\n            await asyncio.sleep(wait)\n\n    async def _send_to_dead_letter(\n        self,\n        url: str,\n        payload: dict[str, Any],\n        last_result: WebhookResult,\n    ) -&gt; None:\n        entry = DeadLetterEntry(\n            url=url,\n            payload=payload,\n            last_result=last_result,\n            attempts=1 + self._policy.max_retries,\n        )\n        self._dead_letters.append(entry)\n        logger.warning(\n            \"webhook.dead_letter\",\n            url=url,\n            attempts=entry.attempts,\n            last_status_code=last_result.status_code,\n            last_error=last_result.error,\n        )\n        if self._on_dead_letter is not None:\n            try:\n                await self._on_dead_letter(entry)\n            except Exception:\n                logger.exception(\"webhook.dead_letter.callback_error\", url=url)\n</code></pre>"},{"location":"api-reference/#asap.transport.WebhookRetryManager.deliver_with_retry","title":"<code>deliver_with_retry(url, payload, *, extra_headers=None)</code>  <code>async</code>","text":"<p>Deliver with retry on 5xx/network error; no retry on 4xx; DLQ after max_retries.</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>async def deliver_with_retry(\n    self,\n    url: str,\n    payload: dict[str, Any],\n    *,\n    extra_headers: dict[str, str] | None = None,\n) -&gt; WebhookResult:\n    \"\"\"Deliver with retry on 5xx/network error; no retry on 4xx; DLQ after max_retries.\"\"\"\n    last_result: WebhookResult | None = None\n\n    for attempt in range(1 + self._policy.max_retries):\n        # Per-URL rate limiting \u2014 wait until a token is available.\n        await self._wait_for_rate_limit(url)\n\n        last_result = await self._delivery.deliver(\n            url,\n            payload,\n            extra_headers=extra_headers,\n        )\n\n        if last_result.success:\n            return last_result\n\n        # 4xx \u2192 do not retry (client error, the request itself is wrong).\n        if last_result.status_code in _NON_RETRYABLE_STATUS_RANGE:\n            logger.info(\n                \"webhook.retry.non_retryable\",\n                url=url,\n                status_code=last_result.status_code,\n                attempt=attempt + 1,\n            )\n            return last_result\n\n        # Last attempt \u2014 don't sleep, go straight to DLQ.\n        if attempt == self._policy.max_retries:\n            break\n\n        delay = self._policy.backoff_delay(attempt)\n        logger.info(\n            \"webhook.retry.backoff\",\n            url=url,\n            attempt=attempt + 1,\n            max_retries=self._policy.max_retries,\n            delay_seconds=delay,\n            status_code=last_result.status_code,\n            error=last_result.error,\n        )\n        await asyncio.sleep(delay)\n\n    # All retries exhausted \u2192 dead letter queue.\n    assert last_result is not None  # At least one attempt was made.\n    await self._send_to_dead_letter(url, payload, last_result)\n    return last_result\n</code></pre>"},{"location":"api-reference/#asap.transport.compress_payload","title":"<code>compress_payload(data, preferred_algorithm=None, threshold=COMPRESSION_THRESHOLD)</code>","text":"<p>Compress payload if it exceeds threshold.</p> <p>Compresses the payload using the preferred algorithm if specified, otherwise uses the best available algorithm (brotli &gt; gzip).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw bytes to compress</p> required <code>preferred_algorithm</code> <code>CompressionAlgorithm | None</code> <p>Optional preferred compression algorithm. If None, uses brotli if available, otherwise gzip.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>Minimum payload size to trigger compression (default: 1KB). Payloads smaller than this are returned as-is with IDENTITY encoding.</p> <code>COMPRESSION_THRESHOLD</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Tuple of (compressed_data, algorithm_used)</p> <code>CompressionAlgorithm</code> <p>If compression is skipped, returns (original_data, IDENTITY)</p> <code>tuple[bytes, CompressionAlgorithm]</code> <p>compressed, algorithm = compress_payload(data)</p> <code>tuple[bytes, CompressionAlgorithm]</code> <p>print(f\"Compressed {len(data)} -&gt; {len(compressed)} bytes using {algorithm.value}\")</p> Note <p>Compression adds CPU overhead which may increase latency for very small payloads. For extremely latency-sensitive scenarios, consider increasing the threshold or disabling compression if payloads are typically small.</p> Source code in <code>src/asap/transport/compression.py</code> <pre><code>def compress_payload(\n    data: bytes,\n    preferred_algorithm: CompressionAlgorithm | None = None,\n    threshold: int = COMPRESSION_THRESHOLD,\n) -&gt; tuple[bytes, CompressionAlgorithm]:\n    \"\"\"Compress payload if it exceeds threshold.\n\n    Compresses the payload using the preferred algorithm if specified,\n    otherwise uses the best available algorithm (brotli &gt; gzip).\n\n    Args:\n        data: Raw bytes to compress\n        preferred_algorithm: Optional preferred compression algorithm.\n            If None, uses brotli if available, otherwise gzip.\n        threshold: Minimum payload size to trigger compression (default: 1KB).\n            Payloads smaller than this are returned as-is with IDENTITY encoding.\n\n    Returns:\n        Tuple of (compressed_data, algorithm_used)\n        If compression is skipped, returns (original_data, IDENTITY)\n\n        &gt;&gt;&gt; compressed, algorithm = compress_payload(data)\n        &gt;&gt;&gt; print(f\"Compressed {len(data)} -&gt; {len(compressed)} bytes using {algorithm.value}\")\n\n    Note:\n        Compression adds CPU overhead which may increase latency for very small payloads.\n        For extremely latency-sensitive scenarios, consider increasing the threshold\n        or disabling compression if payloads are typically small.\n    \"\"\"\n    # Skip compression for small payloads\n    if len(data) &lt; threshold:\n        logger.debug(\n            \"asap.compression.skipped\",\n            size=len(data),\n            threshold=threshold,\n            reason=\"payload_below_threshold\",\n        )\n        return data, CompressionAlgorithm.IDENTITY\n\n    # Determine algorithm to use\n    if preferred_algorithm is not None:\n        algorithm = preferred_algorithm\n    elif is_brotli_available():\n        # TODO: Add prefer_fast_compression option to prefer gzip even when brotli is available\n        algorithm = CompressionAlgorithm.BROTLI\n    else:\n        algorithm = CompressionAlgorithm.GZIP\n\n    # Skip if identity is requested\n    if algorithm == CompressionAlgorithm.IDENTITY:\n        return data, CompressionAlgorithm.IDENTITY\n\n    # Compress using selected algorithm\n    original_size = len(data)\n    try:\n        if algorithm == CompressionAlgorithm.BROTLI:\n            compressed = compress_brotli(data)\n        else:\n            compressed = compress_gzip(data)\n\n        compressed_size = len(compressed)\n        reduction_pct = (1 - compressed_size / original_size) * 100\n\n        logger.debug(\n            \"asap.compression.applied\",\n            algorithm=algorithm.value,\n            original_size=original_size,\n            compressed_size=compressed_size,\n            reduction_percent=round(reduction_pct, 1),\n        )\n\n        # Only use compression if it actually reduces size\n        if compressed_size &gt;= original_size:\n            logger.debug(\n                \"asap.compression.ineffective\",\n                algorithm=algorithm.value,\n                original_size=original_size,\n                compressed_size=compressed_size,\n                reason=\"compression_increased_size\",\n            )\n            return data, CompressionAlgorithm.IDENTITY\n\n        return compressed, algorithm\n\n    except ImportError:\n        # Brotli not available, fallback to gzip\n        logger.warning(\n            \"asap.compression.fallback\",\n            requested=algorithm.value,\n            fallback=\"gzip\",\n            reason=\"brotli_not_installed\",\n        )\n        return compress_payload(data, CompressionAlgorithm.GZIP, threshold)\n    except Exception as e:\n        # Compression failed, return original\n        logger.warning(\n            \"asap.compression.failed\",\n            algorithm=algorithm.value,\n            error=str(e),\n            error_type=type(e).__name__,\n        )\n        return data, CompressionAlgorithm.IDENTITY\n</code></pre>"},{"location":"api-reference/#asap.transport.compute_signature","title":"<code>compute_signature(body, secret)</code>","text":"<p>HMAC-SHA256 of body with secret; returns <code>sha256=&lt;hex&gt;</code> (GitHub/Stripe convention).</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>def compute_signature(body: bytes, secret: bytes) -&gt; str:\n    \"\"\"HMAC-SHA256 of body with secret; returns ``sha256=&lt;hex&gt;`` (GitHub/Stripe convention).\"\"\"\n    digest = hmac.new(secret, body, hashlib.sha256).hexdigest()\n    return f\"sha256={digest}\"\n</code></pre>"},{"location":"api-reference/#asap.transport.create_app","title":"<code>create_app(manifest, registry=None, token_validator=None, oauth2_config=None, rate_limit=None, max_request_size=None, max_threads=None, require_nonce=False, hot_reload=None, snapshot_store=None, metering_store=None, metering_storage=None, websocket_message_rate_limit=10.0, mtls_config=None, delegation_key_store=None, delegation_storage=None, sla_storage=None)</code>","text":"<p>Create and configure a FastAPI application for ASAP protocol.</p> <p>This factory function creates a FastAPI app with: - POST /asap endpoint for handling ASAP messages via JSON-RPC - WebSocket /asap/ws for real-time JSON-RPC (same protocol as POST /asap) - GET /.well-known/asap/manifest.json for agent discovery - GET /asap/metrics for Prometheus-compatible metrics - Authentication middleware (if manifest.auth is configured) - Error handling middleware - Request validation - Extensible handler registry for payload processing</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>The agent's manifest describing capabilities and endpoints</p> required <code>registry</code> <code>HandlerRegistry | None</code> <p>Optional handler registry for processing payloads. If None, a default registry with echo handler is created.</p> <code>None</code> <code>token_validator</code> <code>Callable[[str], str | None] | None</code> <p>Optional function to validate Bearer tokens. Required if manifest.auth is configured. Should return agent ID if token is valid, None otherwise.</p> <code>None</code> <code>oauth2_config</code> <code>OAuth2Config | None</code> <p>Optional OAuth2 config. When provided, OAuth2Middleware is applied to all /asap/* routes (JWT validation via JWKS). If not provided, /asap remains unauthenticated unless manifest.auth is used.</p> <code>None</code> <code>rate_limit</code> <code>str | None</code> <p>Optional rate limit string (e.g., \"10/second;100/minute\"). Rate limiting is IP-based (per client IP address) to prevent DoS attacks. Uses token bucket pattern: burst limit + sustained limit. Defaults to ASAP_RATE_LIMIT environment variable or \"10/second;100/minute\". Warning: The default storage is <code>memory://</code> (per-process). In multi-worker deployments (e.g., Gunicorn with 4 workers), each worker has isolated limits, so effective rate = limit \u00d7 workers (e.g., 10/s \u2192 40/s). For production, use Redis-backed storage.</p> <code>None</code> <code>max_request_size</code> <code>int | None</code> <p>Optional maximum request size in bytes. Defaults to ASAP_MAX_REQUEST_SIZE environment variable or 10MB.</p> <code>None</code> <code>max_threads</code> <code>int | None</code> <p>Optional maximum number of threads for sync handlers. Defaults to ASAP_MAX_THREADS environment variable or min(32, cpu_count + 4). Set to None to use unbounded executor (not recommended for production).</p> <code>None</code> <code>require_nonce</code> <code>bool</code> <p>If True, enables nonce validation for replay attack prevention. When enabled, creates an InMemoryNonceStore and validates nonces in envelopes. Defaults to False (nonce validation is optional).</p> <code>False</code> <code>hot_reload</code> <code>bool | None</code> <p>If True, watch handlers.py and reload handler registry on file change (development only). Defaults to ASAP_HOT_RELOAD env or False.</p> <code>None</code> <code>snapshot_store</code> <code>SnapshotStore | None</code> <p>Optional SnapshotStore for state persistence. If None, uses create_snapshot_store() (ASAP_STORAGE_BACKEND and ASAP_STORAGE_PATH). Stored on app.state.snapshot_store for handlers.</p> <code>None</code> <code>metering_store</code> <code>MeteringStore | None</code> <p>Optional MeteringStore for usage recording. When set, task.request completions are recorded (tokens, duration, api_calls from TaskResponse.metrics).</p> <code>None</code> <code>websocket_message_rate_limit</code> <code>float | None</code> <p>Max messages per second per WebSocket connection. When set (default 10.0), connections exceeding this are sent an error frame and closed. Set to None to disable WebSocket message rate limiting.</p> <code>10.0</code> <code>mtls_config</code> <code>MTLSConfig | None</code> <p>Optional mTLS config for server. When provided, store on app.state.mtls_config. Use asap.transport.mtls.mtls_config_to_uvicorn_kwargs() when running uvicorn.</p> <code>None</code> <code>delegation_key_store</code> <code>Callable[[str], Any] | None</code> <p>Optional callable (delegator_urn: str) -&gt; Ed25519PrivateKey for signing delegation tokens. When provided together with oauth2_config, enables POST /asap/delegations (creates JWT delegation token; authenticated agent is issuer).</p> <code>None</code> <code>delegation_storage</code> <code>object | None</code> <p>Optional DelegationStorage for revocation. When provided with delegation_key_store, enables DELETE /asap/delegations/{id} and registers issued token IDs so only the delegator can revoke.</p> <code>None</code> <code>sla_storage</code> <code>object | None</code> <p>Optional SLAStorage for SLA metrics and breaches. When provided, enables GET /sla, /sla/history, /sla/breaches for querying SLA status.</p> <code>None</code> <p>Returns:</p> Type Description <code>FastAPI</code> <p>Configured FastAPI application ready to run</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If manifest requires authentication but no token_validator provided</p> Example <p>from asap.models.entities import Manifest, Capability, Endpoint, Skill, AuthScheme, SLADefinition from asap.transport.handlers import HandlerRegistry manifest = Manifest( ...     id=\"urn:asap:agent:test\", ...     name=\"Test Agent\", ...     version=\"1.0.0\", ...     description=\"Test agent\", ...     capabilities=Capability( ...         asap_version=\"0.1\", ...         skills=[Skill(id=\"test\", description=\"Test skill\")], ...         state_persistence=False ...     ), ...     endpoints=Endpoint(asap=\"http://localhost:8000/asap\") ... ) app = create_app(manifest)</p> Source code in <code>src/asap/transport/server.py</code> <pre><code>def create_app(\n    manifest: Manifest,\n    registry: HandlerRegistry | None = None,\n    token_validator: Callable[[str], str | None] | None = None,\n    oauth2_config: OAuth2Config | None = None,\n    rate_limit: str | None = None,\n    max_request_size: int | None = None,\n    max_threads: int | None = None,\n    require_nonce: bool = False,\n    hot_reload: bool | None = None,\n    snapshot_store: SnapshotStore | None = None,\n    metering_store: MeteringStore | None = None,\n    metering_storage: object | None = None,\n    websocket_message_rate_limit: float | None = 10.0,\n    mtls_config: MTLSConfig | None = None,\n    delegation_key_store: Callable[[str], Any] | None = None,\n    delegation_storage: object | None = None,\n    sla_storage: object | None = None,\n) -&gt; FastAPI:\n    \"\"\"Create and configure a FastAPI application for ASAP protocol.\n\n    This factory function creates a FastAPI app with:\n    - POST /asap endpoint for handling ASAP messages via JSON-RPC\n    - WebSocket /asap/ws for real-time JSON-RPC (same protocol as POST /asap)\n    - GET /.well-known/asap/manifest.json for agent discovery\n    - GET /asap/metrics for Prometheus-compatible metrics\n    - Authentication middleware (if manifest.auth is configured)\n    - Error handling middleware\n    - Request validation\n    - Extensible handler registry for payload processing\n\n    Args:\n        manifest: The agent's manifest describing capabilities and endpoints\n        registry: Optional handler registry for processing payloads.\n            If None, a default registry with echo handler is created.\n        token_validator: Optional function to validate Bearer tokens.\n            Required if manifest.auth is configured. Should return agent ID\n            if token is valid, None otherwise.\n        oauth2_config: Optional OAuth2 config. When provided, OAuth2Middleware\n            is applied to all /asap/* routes (JWT validation via JWKS). If not\n            provided, /asap remains unauthenticated unless manifest.auth is used.\n        rate_limit: Optional rate limit string (e.g., \"10/second;100/minute\").\n            Rate limiting is IP-based (per client IP address) to prevent DoS attacks.\n            Uses token bucket pattern: burst limit + sustained limit.\n            Defaults to ASAP_RATE_LIMIT environment variable or \"10/second;100/minute\".\n            **Warning:** The default storage is ``memory://`` (per-process). In\n            multi-worker deployments (e.g., Gunicorn with 4 workers), each worker\n            has isolated limits, so effective rate = limit \u00d7 workers (e.g.,\n            10/s \u2192 40/s). For production, use Redis-backed storage.\n        max_request_size: Optional maximum request size in bytes.\n            Defaults to ASAP_MAX_REQUEST_SIZE environment variable or 10MB.\n        max_threads: Optional maximum number of threads for sync handlers.\n            Defaults to ASAP_MAX_THREADS environment variable or min(32, cpu_count + 4).\n            Set to None to use unbounded executor (not recommended for production).\n        require_nonce: If True, enables nonce validation for replay attack prevention.\n            When enabled, creates an InMemoryNonceStore and validates nonces in envelopes.\n            Defaults to False (nonce validation is optional).\n        hot_reload: If True, watch handlers.py and reload handler registry on file change\n            (development only). Defaults to ASAP_HOT_RELOAD env or False.\n        snapshot_store: Optional SnapshotStore for state persistence. If None, uses\n            create_snapshot_store() (ASAP_STORAGE_BACKEND and ASAP_STORAGE_PATH).\n            Stored on app.state.snapshot_store for handlers.\n        metering_store: Optional MeteringStore for usage recording. When set, task.request\n            completions are recorded (tokens, duration, api_calls from TaskResponse.metrics).\n        websocket_message_rate_limit: Max messages per second per WebSocket connection.\n            When set (default 10.0), connections exceeding this are sent an error frame\n            and closed. Set to None to disable WebSocket message rate limiting.\n        mtls_config: Optional mTLS config for server. When provided, store on app.state.mtls_config.\n            Use asap.transport.mtls.mtls_config_to_uvicorn_kwargs() when running uvicorn.\n        delegation_key_store: Optional callable (delegator_urn: str) -&gt; Ed25519PrivateKey for\n            signing delegation tokens. When provided together with oauth2_config, enables\n            POST /asap/delegations (creates JWT delegation token; authenticated agent is issuer).\n        delegation_storage: Optional DelegationStorage for revocation. When provided with\n            delegation_key_store, enables DELETE /asap/delegations/{id} and registers issued\n            token IDs so only the delegator can revoke.\n        sla_storage: Optional SLAStorage for SLA metrics and breaches. When provided,\n            enables GET /sla, /sla/history, /sla/breaches for querying SLA status.\n\n    Returns:\n        Configured FastAPI application ready to run\n\n    Raises:\n        ValueError: If manifest requires authentication but no token_validator provided\n\n    Example:\n        &gt;&gt;&gt; from asap.models.entities import Manifest, Capability, Endpoint, Skill, AuthScheme, SLADefinition\n        &gt;&gt;&gt; from asap.transport.handlers import HandlerRegistry\n        &gt;&gt;&gt; manifest = Manifest(\n        ...     id=\"urn:asap:agent:test\",\n        ...     name=\"Test Agent\",\n        ...     version=\"1.0.0\",\n        ...     description=\"Test agent\",\n        ...     capabilities=Capability(\n        ...         asap_version=\"0.1\",\n        ...         skills=[Skill(id=\"test\", description=\"Test skill\")],\n        ...         state_persistence=False\n        ...     ),\n        ...     endpoints=Endpoint(asap=\"http://localhost:8000/asap\")\n        ... )\n        &gt;&gt;&gt; app = create_app(manifest)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With SLA (optional): add sla=SLADefinition(availability=\"99.5%\", max_latency_p95_ms=500)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With authentication:\n        &gt;&gt;&gt; manifest_with_auth = Manifest(\n        ...     ...,  # same as above\n        ...     auth=AuthScheme(schemes=[\"bearer\"])\n        ... )\n        &gt;&gt;&gt; def my_token_validator(token: str) -&gt; str | None:\n        ...     if token == \"valid-token\":\n        ...         return \"urn:asap:agent:client\"\n        ...     return None\n        &gt;&gt;&gt; app = create_app(manifest_with_auth, token_validator=my_token_validator)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With custom registry:\n        &gt;&gt;&gt; registry = HandlerRegistry()\n        &gt;&gt;&gt; registry.register(\"task.request\", my_handler)\n        &gt;&gt;&gt; app = create_app(manifest, registry)\n        &gt;&gt;&gt; # Run with uvicorn: uvicorn module:app\n    \"\"\"\n    # Configure thread pool executor for DoS prevention\n    executor: BoundedExecutor | None = None\n    if max_threads is None:\n        max_threads_env = os.getenv(\"ASAP_MAX_THREADS\")\n        if max_threads_env:\n            max_threads = int(max_threads_env)\n    if max_threads is not None:\n        executor = BoundedExecutor(max_threads=max_threads)\n        logger.info(\n            \"asap.server.bounded_executor_enabled\",\n            manifest_id=manifest.id,\n            max_threads=max_threads,\n        )\n\n    # Resolve metering: metering_storage takes precedence (enables usage API)\n    effective_metering_store: MeteringStore | None = metering_store\n    if metering_storage is not None and isinstance(metering_storage, MeteringStorage):\n        effective_metering_store = metering_storage_adapter(metering_storage)\n\n    # Use default registry if none provided\n    use_default_registry = registry is None\n    if registry is None:\n        registry = create_default_registry(metering_store=effective_metering_store)\n    elif effective_metering_store is not None:\n        registry.set_metering_store(effective_metering_store)\n\n    # Attach executor to registry if provided\n    if executor is not None:\n        registry._executor = executor\n\n    # Wrap registry in holder for hot reload support\n    registry_holder = RegistryHolder(registry)\n    if executor is not None:\n        registry_holder._executor = executor\n\n    # Resolve hot_reload from env if not specified\n    if hot_reload is None:\n        hot_reload = os.getenv(ENV_HOT_RELOAD, \"\").strip().lower() in (\"true\", \"1\", \"yes\")\n\n    # Create authentication middleware if auth is configured\n    auth_middleware: AuthenticationMiddleware | None = None\n    if manifest.auth is not None:\n        if token_validator is None:\n            raise ValueError(\n                \"token_validator is required when manifest.auth is configured. \"\n                \"Provide a function that validates tokens and returns agent IDs.\"\n            )\n        validator = BearerTokenValidator(token_validator)\n        auth_middleware = AuthenticationMiddleware(manifest, validator)\n        logger.info(\n            \"asap.server.auth_enabled\",\n            manifest_id=manifest.id,\n            schemes=manifest.auth.schemes,\n        )\n\n    # Configure max request size\n    if max_request_size is None:\n        max_request_size = int(os.getenv(\"ASAP_MAX_REQUEST_SIZE\", str(MAX_REQUEST_SIZE)))\n\n    # Create nonce store if required\n    nonce_store: NonceStore | None = None\n    if require_nonce:\n        nonce_store = InMemoryNonceStore()\n        logger.info(\n            \"asap.server.nonce_validation_enabled\",\n            manifest_id=manifest.id,\n        )\n\n    # Resolve snapshot store (env-based when not provided)\n    if snapshot_store is None:\n        snapshot_store = create_snapshot_store()\n        logger.info(\n            \"asap.server.snapshot_store_from_env\",\n            manifest_id=manifest.id,\n            backend=os.environ.get(\"ASAP_STORAGE_BACKEND\", \"memory\"),\n        )\n\n    # Create request handler\n    handler = ASAPRequestHandler(\n        registry_holder, manifest, auth_middleware, max_request_size, nonce_store\n    )\n\n    # Start handler file watcher when hot reload is enabled (only with default registry)\n    if hot_reload and use_default_registry:\n        _handlers_module = sys.modules.get(\"asap.transport.handlers\")\n        _handlers_file = getattr(_handlers_module, \"__file__\", \"\") if _handlers_module else \"\"\n        if _handlers_file and Path(_handlers_file).exists():\n            watcher = threading.Thread(\n                target=_run_handler_watcher,\n                args=(registry_holder, _handlers_file),\n                name=\"asap-handler-watcher\",\n                daemon=True,\n            )\n            watcher.start()\n            logger.info(\n                \"asap.server.hot_reload_enabled\",\n                manifest_id=manifest.id,\n                path=_handlers_file,\n            )\n        else:\n            logger.warning(\n                \"asap.server.hot_reload_skipped\",\n                reason=\"handlers module path not found\",\n            )\n\n    # Enable Swagger UI (/docs) and ReDoc (/redoc) only when ASAP_DEBUG=true\n    _docs_url = \"/docs\" if is_debug_mode() else None\n    _redoc_url = \"/redoc\" if is_debug_mode() else None\n    _openapi_url = \"/openapi.json\" if is_debug_mode() else None\n\n    # Track active WebSocket connections for graceful shutdown (close with reason)\n    _active_websockets: set[WebSocket] = set()\n    # Subset of connections subscribed to SLA breach notifications (v1.3)\n    _sla_breach_subscribers: set[WebSocket] = set()\n\n    @asynccontextmanager\n    async def _lifespan(app: FastAPI) -&gt; Any:\n        yield\n        for ws in list(_active_websockets):\n            with suppress(OSError):\n                await ws.close(\n                    code=WS_CLOSE_GOING_AWAY,\n                    reason=WS_CLOSE_REASON_SHUTDOWN,\n                )\n\n    app = FastAPI(\n        title=\"ASAP Protocol Server\",\n        description=f\"ASAP server for {manifest.name}\",\n        version=manifest.version,\n        docs_url=_docs_url,\n        redoc_url=_redoc_url,\n        openapi_url=_openapi_url,\n        lifespan=_lifespan,\n    )\n    app.state.websocket_connections = _active_websockets\n    app.state.sla_breach_subscribers = _sla_breach_subscribers\n    app.state.websocket_message_rate_limit = websocket_message_rate_limit\n    app.state.mtls_config = mtls_config\n    if metering_storage is not None and isinstance(metering_storage, MeteringStorage):\n        app.state.metering_storage = metering_storage\n        app.include_router(create_usage_router())\n        logger.warning(\n            \"asap.server.usage_api_unauthenticated\",\n            message=(\n                \"Usage API (/usage) is enabled but unauthenticated. \"\n                \"Intended for local/operator use only. Protect with OAuth2 or network controls when exposed.\"\n            ),\n        )\n    if mtls_config is not None:\n        logger.info(\n            \"asap.server.mtls_enabled\",\n            manifest_id=manifest.id,\n            cert_file=str(mtls_config.cert_file),\n        )\n\n    if sla_storage is not None and isinstance(sla_storage, SLAStorage):\n        app.state.sla_storage = sla_storage\n        app.state.manifest = manifest\n        app.include_router(create_sla_router())\n        logger.warning(\n            \"asap.server.sla_api_unauthenticated\",\n            message=(\n                \"SLA API (/sla) is enabled but unauthenticated. \"\n                \"Intended for local/operator use only. Protect with OAuth2 or network controls when exposed.\"\n            ),\n        )\n\n    if oauth2_config is not None and delegation_key_store is not None:\n        app.state.delegation_key_store = delegation_key_store\n        if delegation_storage is not None:\n            app.state.delegation_storage = delegation_storage\n        app.include_router(create_delegation_router(), prefix=\"/asap\")\n        logger.info(\n            \"asap.server.delegation_api_enabled\",\n            manifest_id=manifest.id,\n        )\n\n    # Add size limit middleware (runs before routing)\n    app.add_middleware(SizeLimitMiddleware, max_size=max_request_size)\n\n    if oauth2_config is not None:\n        middleware_kwargs: dict[str, Any] = {\n            \"jwks_uri\": oauth2_config.jwks_uri,\n            \"required_scope\": oauth2_config.required_scope,\n            \"path_prefix\": oauth2_config.path_prefix,\n            \"manifest_id\": manifest.id,\n            \"custom_claim\": oauth2_config.custom_claim,\n        }\n        if oauth2_config.jwks_fetcher is not None:\n            middleware_kwargs[\"jwks_fetcher\"] = oauth2_config.jwks_fetcher\n        app.add_middleware(OAuth2Middleware, **middleware_kwargs)\n        logger.info(\n            \"asap.server.oauth2_enabled\",\n            manifest_id=manifest.id,\n            jwks_uri=oauth2_config.jwks_uri,\n            path_prefix=oauth2_config.path_prefix,\n        )\n\n    # Configure rate limiting\n    if rate_limit is None:\n        # Default matches DD-012: Burst allowance for better UX with bursty agent traffic\n        rate_limit_str = os.getenv(\"ASAP_RATE_LIMIT\", \"10/second;100/minute\")\n    else:\n        rate_limit_str = rate_limit\n\n    # Create isolated limiter instance for this app.\n    # Each app instance gets its own rate limiter storage.\n    # Tests can override via direct assignment to app.state.limiter.\n    app.state.limiter = create_limiter(\n        [rate_limit_str],\n        key_func=_get_sender_from_envelope,\n    )\n    app.state.max_request_size = max_request_size\n    app.state.snapshot_store = snapshot_store\n    app.state.metering_store = metering_store\n    app.add_exception_handler(RateLimitExceeded, rate_limit_handler)\n    logger.info(\n        \"asap.server.rate_limit_enabled\",\n        manifest_id=manifest.id,\n        rate_limit=rate_limit_str,\n    )\n    logger.info(\n        \"asap.server.max_request_size\",\n        manifest_id=manifest.id,\n        max_request_size=max_request_size,\n    )\n\n    @app.get(\"/health\")\n    async def health() -&gt; JSONResponse:\n        \"\"\"Liveness probe: always OK if the process is running.\n\n        Used by Kubernetes livenessProbe and Docker HEALTHCHECK.\n        Returns 200 with {\"status\": \"ok\"}.\n\n        Returns:\n            JSONResponse with status ok\n        \"\"\"\n        return JSONResponse(status_code=200, content={\"status\": \"ok\"})\n\n    @app.get(\"/ready\")\n    async def ready() -&gt; JSONResponse:\n        \"\"\"Readiness probe: OK when the server is ready to accept traffic.\n\n        Used by Kubernetes readinessProbe. Returns 200 when the app\n        is initialized and can serve requests.\n\n        Returns:\n            JSONResponse with status ok\n        \"\"\"\n        return JSONResponse(status_code=200, content={\"status\": \"ok\"})\n\n    server_started_at = time.monotonic()\n    if manifest is not None:\n\n        @app.get(wellknown.WELLKNOWN_MANIFEST_PATH)\n        async def get_manifest(request: Request) -&gt; Response:\n            \"\"\"Return the agent's manifest for discovery.\n\n            This endpoint allows other agents to discover this agent's\n            capabilities, skills, and communication endpoints.\n            \"\"\"\n            return await wellknown.get_manifest_response(manifest, request)\n\n        @app.get(discovery_health.WELLKNOWN_HEALTH_PATH)\n        async def get_health() -&gt; JSONResponse:\n            \"\"\"Return agent health/liveness status (200 healthy, 503 unhealthy).\"\"\"\n            return await discovery_health.get_health_response_async(manifest, server_started_at)\n\n    @app.get(\"/asap/metrics\")\n    async def get_metrics_endpoint() -&gt; PlainTextResponse:\n        \"\"\"Return Prometheus-compatible metrics.\n\n        This endpoint exposes server metrics in Prometheus text format,\n        including request counts, error rates, and latency histograms.\n\n        Returns:\n            PlainTextResponse with metrics in Prometheus format\n\n        Example:\n            curl http://localhost:8000/asap/metrics\n        \"\"\"\n        metrics = get_metrics()\n        return PlainTextResponse(\n            content=metrics.export_prometheus(),\n            media_type=\"application/openmetrics-text; version=1.0.0; charset=utf-8\",\n        )\n\n    # OpenTelemetry tracing (zero-config via OTEL_* env vars)\n    configure_tracing(service_name=manifest.id, app=app)\n\n    @app.post(\"/asap\")\n    async def handle_asap_message(request: Request) -&gt; JSONResponse:\n        \"\"\"Handle ASAP messages wrapped in JSON-RPC 2.0.\n\n        This endpoint:\n        1. Enforces rate limiting via ``app.state.limiter``\n        2. Receives JSON-RPC wrapped ASAP envelopes\n        3. Validates the request structure\n        4. Extracts and processes the ASAP envelope\n        5. Returns response wrapped in JSON-RPC\n        6. Records metrics for observability\n\n        Args:\n            request: FastAPI request object with JSON body\n\n        Returns:\n            JSON-RPC response or error response\n\n        Example:\n            &gt;&gt;&gt; # Send JSON-RPC to POST /asap and receive JSON-RPC response.\n            &gt;&gt;&gt; # See tests/transport/test_server.py for full request examples.\n        \"\"\"\n        # Rate limit check \u2014 uses app.state.limiter so tests can override.\n        app.state.limiter.check(request)\n        return await handler.handle_message(request)\n\n    @app.websocket(\"/asap/ws\")\n    async def websocket_asap(websocket: WebSocket) -&gt; None:\n        \"\"\"ASAP JSON-RPC over WebSocket; same handlers as POST /asap.\"\"\"\n        ws_rate_limit: float | None = getattr(app.state, \"websocket_message_rate_limit\", 10.0)\n        sla_subscribers: set[WebSocket] | None = getattr(app.state, \"sla_breach_subscribers\", None)\n        await handle_websocket_connection(\n            websocket,\n            handler,\n            app.state.websocket_connections,\n            ws_message_rate_limit=ws_rate_limit,\n            sla_breach_subscribers=sla_subscribers,\n        )\n\n    return app\n</code></pre>"},{"location":"api-reference/#asap.transport.create_app--with-sla-optional-add-slasladefinitionavailability995-max_latency_p95_ms500","title":"With SLA (optional): add sla=SLADefinition(availability=\"99.5%\", max_latency_p95_ms=500)","text":""},{"location":"api-reference/#asap.transport.create_app--with-authentication","title":"With authentication:","text":"<p>manifest_with_auth = Manifest( ...     ...,  # same as above ...     auth=AuthScheme(schemes=[\"bearer\"]) ... ) def my_token_validator(token: str) -&gt; str | None: ...     if token == \"valid-token\": ...         return \"urn:asap:agent:client\" ...     return None app = create_app(manifest_with_auth, token_validator=my_token_validator)</p>"},{"location":"api-reference/#asap.transport.create_app--with-custom-registry","title":"With custom registry:","text":"<p>registry = HandlerRegistry() registry.register(\"task.request\", my_handler) app = create_app(manifest, registry)</p>"},{"location":"api-reference/#asap.transport.create_app--run-with-uvicorn-uvicorn-moduleapp","title":"Run with uvicorn: uvicorn module:app","text":""},{"location":"api-reference/#asap.transport.create_default_registry","title":"<code>create_default_registry(metering_store=None)</code>","text":"<p>Create a registry with default handlers.</p> <p>Creates a HandlerRegistry pre-configured with standard handlers: - task.request: Echo handler (for basic testing)</p> <p>Additional handlers can be registered after creation.</p> <p>Parameters:</p> Name Type Description Default <code>metering_store</code> <code>object | None</code> <p>Optional MeteringStore for usage recording.</p> <code>None</code> <p>Returns:</p> Type Description <code>HandlerRegistry</code> <p>HandlerRegistry with default handlers registered</p> Example <p>registry = create_default_registry() registry.has_handler(\"task.request\") True</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>def create_default_registry(\n    metering_store: object | None = None,\n) -&gt; HandlerRegistry:\n    \"\"\"Create a registry with default handlers.\n\n    Creates a HandlerRegistry pre-configured with standard handlers:\n    - task.request: Echo handler (for basic testing)\n\n    Additional handlers can be registered after creation.\n\n    Args:\n        metering_store: Optional MeteringStore for usage recording.\n\n    Returns:\n        HandlerRegistry with default handlers registered\n\n    Example:\n        &gt;&gt;&gt; registry = create_default_registry()\n        &gt;&gt;&gt; registry.has_handler(\"task.request\")\n        True\n    \"\"\"\n    registry = HandlerRegistry(metering_store=metering_store)\n    registry.register(\"task.request\", create_echo_handler())\n    return registry\n</code></pre>"},{"location":"api-reference/#asap.transport.create_echo_handler","title":"<code>create_echo_handler()</code>","text":"<p>Create a synchronous echo handler that echoes TaskRequest input.</p> <p>The echo handler is a simple implementation that: - Receives a TaskRequest envelope - Returns a TaskResponse with the input echoed back - Preserves trace_id and sets correlation_id</p> <p>Returns SyncHandler (not Handler) so tests can use it without casting. This is useful for testing and as a base for custom handlers.</p> <p>Returns:</p> Type Description <code>SyncHandler</code> <p>SyncHandler that echoes TaskRequest input</p> Example <p>handler = create_echo_handler() response = handler(request_envelope, manifest)</p> Source code in <code>src/asap/transport/handlers.py</code> <pre><code>def create_echo_handler() -&gt; SyncHandler:\n    \"\"\"Create a synchronous echo handler that echoes TaskRequest input.\n\n    The echo handler is a simple implementation that:\n    - Receives a TaskRequest envelope\n    - Returns a TaskResponse with the input echoed back\n    - Preserves trace_id and sets correlation_id\n\n    Returns SyncHandler (not Handler) so tests can use it without casting.\n    This is useful for testing and as a base for custom handlers.\n\n    Returns:\n        SyncHandler that echoes TaskRequest input\n\n    Example:\n        &gt;&gt;&gt; handler = create_echo_handler()\n        &gt;&gt;&gt; response = handler(request_envelope, manifest)\n    \"\"\"\n\n    def echo_handler(envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n        \"\"\"Echo handler implementation.\"\"\"\n        # Parse the TaskRequest payload\n        task_request = TaskRequest(**envelope.payload_dict)\n\n        # Create response with echoed input\n        response_payload = TaskResponse(\n            task_id=f\"task_{generate_id()}\",\n            status=TaskStatus.COMPLETED,\n            result={\"echoed\": task_request.input},\n        )\n\n        # Create response envelope\n        return Envelope(\n            asap_version=envelope.asap_version,\n            sender=manifest.id,\n            recipient=envelope.sender,\n            payload_type=\"task.response\",\n            payload=response_payload.model_dump(),\n            correlation_id=envelope.id,\n            trace_id=envelope.trace_id,\n        )\n\n    return echo_handler\n</code></pre>"},{"location":"api-reference/#asap.transport.decompress_payload","title":"<code>decompress_payload(data, encoding)</code>","text":"<p>Decompress payload based on Content-Encoding header.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Compressed bytes</p> required <code>encoding</code> <code>str</code> <p>Content-Encoding header value (e.g., \"gzip\", \"br\", \"identity\")</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Decompressed bytes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If encoding is not supported</p> <code>OSError</code> <p>If decompression fails (invalid compressed data)</p> Example <p>compressed_data = gzip.compress(b'{\"message\": \"hello\"}') original = decompress_payload(compressed_data, \"gzip\")</p> Source code in <code>src/asap/transport/compression.py</code> <pre><code>def decompress_payload(\n    data: bytes,\n    encoding: str,\n) -&gt; bytes:\n    \"\"\"Decompress payload based on Content-Encoding header.\n\n    Args:\n        data: Compressed bytes\n        encoding: Content-Encoding header value (e.g., \"gzip\", \"br\", \"identity\")\n\n    Returns:\n        Decompressed bytes\n\n    Raises:\n        ValueError: If encoding is not supported\n        OSError: If decompression fails (invalid compressed data)\n\n    Example:\n        &gt;&gt;&gt; compressed_data = gzip.compress(b'{\"message\": \"hello\"}')\n        &gt;&gt;&gt; original = decompress_payload(compressed_data, \"gzip\")\n    \"\"\"\n    # Normalize encoding name\n    encoding_lower = encoding.lower().strip()\n\n    # Handle identity (no compression)\n    if encoding_lower in (\"identity\", \"\"):\n        return data\n\n    original_size = len(data)\n\n    try:\n        if encoding_lower == \"gzip\":\n            decompressed = decompress_gzip(data)\n        elif encoding_lower == \"br\":\n            if not is_brotli_available():\n                raise ValueError(\n                    \"Brotli decompression requested but brotli package is not installed. \"\n                    \"Install with: pip install brotli\"\n                )\n            decompressed = decompress_brotli(data)\n        else:\n            raise ValueError(\n                f\"Unsupported Content-Encoding: {encoding}. Supported: gzip, br, identity\"\n            )\n\n        decompressed_size = len(decompressed)\n        logger.debug(\n            \"asap.decompression.applied\",\n            encoding=encoding_lower,\n            compressed_size=original_size,\n            decompressed_size=decompressed_size,\n        )\n\n        return decompressed\n\n    except ImportError as e:\n        raise ValueError(\n            f\"Cannot decompress {encoding}: required package not installed. {e}\"\n        ) from e\n</code></pre>"},{"location":"api-reference/#asap.transport.select_best_encoding","title":"<code>select_best_encoding(accept_encoding)</code>","text":"<p>Select best compression algorithm based on Accept-Encoding header.</p> <p>Parses the Accept-Encoding header and selects the best supported algorithm based on client preferences and availability.</p> <p>Parameters:</p> Name Type Description Default <code>accept_encoding</code> <code>str | None</code> <p>Accept-Encoding header value (e.g., \"gzip, br;q=0.9\") If None, returns IDENTITY (no compression).</p> required <p>Returns:</p> Type Description <code>CompressionAlgorithm</code> <p>Best available compression algorithm</p> Example <p>algorithm = select_best_encoding(\"br, gzip;q=0.9, identity;q=0.5\") print(algorithm.value)  # \"br\" if brotli available, else \"gzip\"</p> Source code in <code>src/asap/transport/compression.py</code> <pre><code>def select_best_encoding(accept_encoding: str | None) -&gt; CompressionAlgorithm:\n    \"\"\"Select best compression algorithm based on Accept-Encoding header.\n\n    Parses the Accept-Encoding header and selects the best supported algorithm\n    based on client preferences and availability.\n\n    Args:\n        accept_encoding: Accept-Encoding header value (e.g., \"gzip, br;q=0.9\")\n            If None, returns IDENTITY (no compression).\n\n    Returns:\n        Best available compression algorithm\n\n    Example:\n        &gt;&gt;&gt; algorithm = select_best_encoding(\"br, gzip;q=0.9, identity;q=0.5\")\n        &gt;&gt;&gt; print(algorithm.value)  # \"br\" if brotli available, else \"gzip\"\n    \"\"\"\n    if not accept_encoding:\n        return CompressionAlgorithm.IDENTITY\n\n    # Parse Accept-Encoding header (simplified parser)\n    # Format: encoding[;q=weight], encoding[;q=weight], ...\n    encodings: dict[str, float] = {}\n    for part in accept_encoding.split(\",\"):\n        part = part.strip()\n        if not part:\n            continue\n\n        # Split encoding and quality\n        if \";q=\" in part.lower():\n            encoding, q_str = part.lower().split(\";q=\", 1)\n            try:\n                quality = float(q_str)\n            except ValueError:\n                quality = 1.0\n        else:\n            encoding = part.lower()\n            quality = 1.0\n\n        encoding = encoding.strip()\n        if encoding:\n            encodings[encoding] = quality\n\n    # Sort by quality (highest first) and filter to supported encodings\n    supported = get_supported_encodings()\n    candidates: list[tuple[str, float]] = []\n\n    for enc, quality in encodings.items():\n        if enc in supported or enc == \"identity\":\n            candidates.append((enc, quality))\n\n    # Sort by quality descending\n    candidates.sort(key=lambda x: x[1], reverse=True)\n\n    if not candidates:\n        return CompressionAlgorithm.IDENTITY\n\n    best_encoding = candidates[0][0]\n\n    if best_encoding == \"br\" and is_brotli_available():\n        return CompressionAlgorithm.BROTLI\n    if best_encoding == \"gzip\":\n        return CompressionAlgorithm.GZIP\n    return CompressionAlgorithm.IDENTITY\n</code></pre>"},{"location":"api-reference/#asap.transport.validate_callback_url","title":"<code>validate_callback_url(url, *, require_https=True)</code>  <code>async</code>","text":"<p>Validate a webhook callback URL against SSRF rules.</p> <p>Rejects non-HTTPS schemes (unless require_https is False), missing hostnames, private/loopback/link-local IP literals, and hostnames that resolve to any blocked IP range (anti DNS-rebinding).</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>async def validate_callback_url(url: str, *, require_https: bool = True) -&gt; None:\n    \"\"\"Validate a webhook callback URL against SSRF rules.\n\n    Rejects non-HTTPS schemes (unless *require_https* is False), missing\n    hostnames, private/loopback/link-local IP literals, and hostnames that\n    resolve to any blocked IP range (anti DNS-rebinding).\n    \"\"\"\n    parsed = urlparse(url)\n\n    # --- Scheme check ---\n    allowed = _ALLOWED_SCHEMES_STRICT if require_https else _ALLOWED_SCHEMES_RELAXED\n    if parsed.scheme not in allowed:\n        raise WebhookURLValidationError(\n            url=url,\n            reason=(\n                f\"Scheme '{parsed.scheme}' is not allowed. \"\n                f\"Allowed schemes: {', '.join(sorted(allowed))}\"\n            ),\n        )\n\n    # --- Hostname presence ---\n    hostname = parsed.hostname\n    if not hostname:\n        raise WebhookURLValidationError(\n            url=url,\n            reason=\"URL must include a hostname\",\n        )\n\n    # --- IP literal check (skip DNS for raw IPs) ---\n    if _is_ip_blocked(hostname):\n        raise WebhookURLValidationError(\n            url=url,\n            reason=f\"Host '{hostname}' resolves to a blocked address range (private/loopback/link-local)\",\n        )\n\n    # --- DNS resolution check (anti DNS-rebinding) ---\n    resolved_ips = await _resolve_hostname(hostname)\n    for ip_str in resolved_ips:\n        if _is_ip_blocked(ip_str):\n            raise WebhookURLValidationError(\n                url=url,\n                reason=(\n                    f\"Host '{hostname}' resolved to blocked IP '{ip_str}' \"\n                    \"(private/loopback/link-local)\"\n                ),\n                details={\"resolved_ips\": resolved_ips},\n            )\n\n    logger.debug(\n        \"webhook.url_validated\",\n        url=url,\n        resolved_ips=resolved_ips,\n    )\n</code></pre>"},{"location":"api-reference/#asap.transport.verify_signature","title":"<code>verify_signature(body, secret, signature)</code>","text":"<p>Constant-time check that signature matches HMAC-SHA256 of body.</p> Source code in <code>src/asap/transport/webhook.py</code> <pre><code>def verify_signature(body: bytes, secret: bytes, signature: str) -&gt; bool:\n    \"\"\"Constant-time check that signature matches HMAC-SHA256 of body.\"\"\"\n    expected = compute_signature(body, secret)\n    return hmac.compare_digest(expected, signature)\n</code></pre>"},{"location":"error-handling/","title":"Error Handling","text":"<p>This document describes ASAP error taxonomy and handling patterns.</p>"},{"location":"error-handling/#error-taxonomy","title":"Error Taxonomy","text":"<p>ASAP defines structured errors in <code>asap.errors</code> with a stable error code format:</p> <pre><code>asap:&lt;domain&gt;/&lt;error&gt;\n</code></pre> <p>Examples:</p> <ul> <li><code>asap:protocol/invalid_state</code></li> <li><code>asap:protocol/malformed_envelope</code></li> <li><code>asap:task/not_found</code></li> </ul>"},{"location":"error-handling/#core-error-types","title":"Core Error Types","text":"<ul> <li><code>ASAPError</code>: base class for all protocol errors</li> <li><code>InvalidTransitionError</code>: invalid task state transitions</li> <li><code>MalformedEnvelopeError</code>: invalid envelope payloads</li> <li><code>TaskNotFoundError</code>: task lookup failures</li> <li><code>TaskAlreadyCompletedError</code>: attempted updates to terminal tasks</li> </ul>"},{"location":"error-handling/#usage-example","title":"Usage Example","text":"<pre><code>from asap.errors import InvalidTransitionError\n\ntry:\n    raise InvalidTransitionError(from_state=\"submitted\", to_state=\"completed\")\nexcept InvalidTransitionError as exc:\n    error_payload = exc.to_dict()\n    # error_payload contains code, message, and details\n</code></pre>"},{"location":"error-handling/#json-rpc-mapping","title":"JSON-RPC Mapping","text":"<p>Transport layer errors are surfaced as JSON-RPC error responses:</p> <ul> <li><code>INVALID_REQUEST</code> for malformed JSON-RPC requests</li> <li><code>INVALID_PARAMS</code> for invalid envelope payloads</li> <li><code>METHOD_NOT_FOUND</code> for unknown payload types</li> <li><code>INTERNAL_ERROR</code> for unexpected exceptions</li> </ul> <p>Use structured logs with <code>trace_id</code> and <code>correlation_id</code> to debug failures across agent boundaries.</p>"},{"location":"error-handling/#connection-error-troubleshooting","title":"Connection Error Troubleshooting","text":"<p>Connection errors are common when communicating with remote ASAP agents. This section provides guidance on diagnosing and resolving connection issues.</p>"},{"location":"error-handling/#common-connection-errors","title":"Common Connection Errors","text":""},{"location":"error-handling/#asapconnectionerror","title":"ASAPConnectionError","text":"<p>Raised when the HTTP connection cannot be established or when the remote server returns an HTTP error status.</p> <p>Error Message Format:</p> <pre><code>Connection failed to {url}. Verify the agent is running and accessible.\nTroubleshooting: Check the URL format, network connectivity, and firewall settings.\n</code></pre> <p>Common Causes:</p> <ol> <li>Agent Not Running: The target agent service is not started or has crashed</li> <li>Incorrect URL: The base URL is malformed or points to the wrong endpoint</li> <li>Network Issues: Firewall blocking, DNS resolution failures, or network unreachable</li> <li>Port Mismatch: The agent is running on a different port than specified</li> <li>HTTPS/HTTP Mismatch: Using HTTP when HTTPS is required (or vice versa)</li> </ol> <p>Diagnostic Steps:</p> <pre><code>from asap.transport.client import ASAPClient\nfrom asap.errors import ASAPConnectionError\n\nasync def diagnose_connection(base_url: str):\n    \"\"\"Diagnose connection issues with an ASAP agent.\"\"\"\n    try:\n        async with ASAPClient(base_url=base_url) as client:\n            # Try to validate connection\n            is_valid = await client._validate_connection()\n            if is_valid:\n                print(f\"\u2713 Connection to {base_url} is valid\")\n            else:\n                print(f\"\u2717 Connection validation failed for {base_url}\")\n    except ASAPConnectionError as e:\n        print(f\"Connection Error: {e.message}\")\n        print(f\"URL: {e.url}\")\n        print(\"\\nTroubleshooting steps:\")\n        print(\"1. Verify the agent is running:\")\n        print(f\"   curl {base_url}/.well-known/asap/manifest.json\")\n        print(\"2. Check URL format (should be http:// or https://)\")\n        print(\"3. Verify network connectivity:\")\n        print(f\"   ping {base_url.split('://')[1].split('/')[0]}\")\n        print(\"4. Check firewall settings\")\n        print(\"5. Verify port is correct\")\n</code></pre>"},{"location":"error-handling/#asaptimeouterror","title":"ASAPTimeoutError","text":"<p>Raised when the HTTP request exceeds the configured timeout duration.</p> <p>Error Message Format:</p> <pre><code>Request to {url} timed out after {timeout} seconds\n</code></pre> <p>Common Causes:</p> <ol> <li>Slow Network: High latency or slow network connection</li> <li>Server Overload: Server is processing requests slowly</li> <li>Timeout Too Short: Configured timeout is insufficient for the operation</li> <li>Large Payload: Request/response payload is large and takes time to transfer</li> </ol> <p>Solutions:</p> <pre><code># Increase timeout for slow connections\nasync with ASAPClient(\n    base_url=\"https://api.example.com\",\n    timeout=120.0  # 2 minutes instead of default 60 seconds\n) as client:\n    response = await client.send(envelope)\n\n# For large payloads, consider:\n# - Splitting into smaller requests\n# - Using streaming for large responses\n# - Increasing both client and server timeouts\n</code></pre>"},{"location":"error-handling/#circuitopenerror","title":"CircuitOpenError","text":"<p>Raised when the circuit breaker is open and requests are rejected immediately.</p> <p>Error Message Format:</p> <pre><code>Circuit breaker is OPEN for {base_url}. Too many consecutive failures ({count}).\nService temporarily unavailable.\n</code></pre> <p>Common Causes:</p> <ol> <li>Service Down: The remote service is completely unavailable</li> <li>High Failure Rate: Multiple consecutive failures have occurred</li> <li>Network Partition: Network connectivity issues causing repeated failures</li> </ol> <p>Solutions:</p> <pre><code>from asap.errors import CircuitOpenError\n\ntry:\n    async with ASAPClient(\n        base_url=\"https://api.example.com\",\n        circuit_breaker_enabled=True\n    ) as client:\n        response = await client.send(envelope)\nexcept CircuitOpenError as e:\n    print(f\"Circuit is open: {e.message}\")\n    print(f\"Consecutive failures: {e.consecutive_failures}\")\n    print(\"\\nSolutions:\")\n    print(\"1. Wait for circuit breaker timeout (default: 60s)\")\n    print(\"2. Check if remote service is operational\")\n    print(\"3. Verify network connectivity\")\n    print(\"4. Consider disabling circuit breaker if failures are expected\")\n</code></pre>"},{"location":"error-handling/#diagnostic-checklist","title":"Diagnostic Checklist","text":"<p>When experiencing connection errors, follow this checklist:</p>"},{"location":"error-handling/#1-verify-agent-is-running","title":"1. Verify Agent is Running","text":"<pre><code># Check if agent is accessible\ncurl -I https://api.example.com/.well-known/asap/manifest.json\n\n# Expected: HTTP/1.1 200 OK\n# If 404: Agent may not be running or URL is incorrect\n# If connection refused: Agent is not listening on that port\n</code></pre>"},{"location":"error-handling/#2-check-url-format","title":"2. Check URL Format","text":"<pre><code># Valid URLs\n\"https://api.example.com\"           # \u2713 HTTPS production\n\"http://localhost:8000\"             # \u2713 HTTP localhost (development)\n\"https://localhost:8443\"            # \u2713 HTTPS localhost\n\n# Invalid URLs\n\"api.example.com\"                   # \u2717 Missing scheme\n\"ftp://api.example.com\"             # \u2717 Unsupported scheme\n\"http://api.example.com\"            # \u2717 HTTP in production (if require_https=True)\n</code></pre>"},{"location":"error-handling/#3-test-network-connectivity","title":"3. Test Network Connectivity","text":"<pre><code># Test DNS resolution\nnslookup api.example.com\n\n# Test TCP connection\ntelnet api.example.com 443\n\n# Test HTTP connection\ncurl -v https://api.example.com/.well-known/asap/manifest.json\n</code></pre>"},{"location":"error-handling/#4-verify-firewall-and-security-groups","title":"4. Verify Firewall and Security Groups","text":"<ul> <li>Outbound Rules: Ensure your client can make outbound HTTPS connections</li> <li>Inbound Rules: Ensure the agent server accepts inbound connections on the configured port</li> <li>Security Groups: Check cloud provider security group rules (AWS, GCP, Azure)</li> </ul>"},{"location":"error-handling/#5-check-ssltls-configuration","title":"5. Check SSL/TLS Configuration","text":"<pre><code># For development with self-signed certificates\nasync with ASAPClient(\n    base_url=\"https://localhost:8443\",\n    verify_ssl=False  # \u26a0\ufe0f Development only, not for production\n) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"error-handling/#6-review-error-logs","title":"6. Review Error Logs","text":"<p>The ASAP client provides structured logging with context:</p> <pre><code>import logging\nfrom asap.observability import get_logger\n\nlogger = get_logger(__name__)\n\n# Logs include:\n# - target_url: The URL being accessed\n# - attempt: Retry attempt number\n# - status_code: HTTP status code (if available)\n# - error: Error message\n# - delay_seconds: Backoff delay before retry\n</code></pre>"},{"location":"error-handling/#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":""},{"location":"error-handling/#1-implement-retry-logic","title":"1. Implement Retry Logic","text":"<p>The client includes automatic retry with exponential backoff, but you can add custom retry logic:</p> <pre><code>from asap.transport.client import ASAPClient\nfrom asap.errors import ASAPConnectionError, ASAPTimeoutError\nimport asyncio\n\nasync def send_with_custom_retry(envelope, max_attempts=3):\n    \"\"\"Send envelope with custom retry logic.\"\"\"\n    for attempt in range(max_attempts):\n        try:\n            async with ASAPClient(base_url=\"https://api.example.com\") as client:\n                return await client.send(envelope)\n        except (ASAPConnectionError, ASAPTimeoutError) as e:\n            if attempt == max_attempts - 1:\n                raise  # Last attempt failed\n            wait_time = 2 ** attempt  # Exponential backoff\n            print(f\"Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            await asyncio.sleep(wait_time)\n</code></pre>"},{"location":"error-handling/#2-handle-circuit-breaker-gracefully","title":"2. Handle Circuit Breaker Gracefully","text":"<pre><code>from asap.errors import CircuitOpenError\n\ntry:\n    response = await client.send(envelope)\nexcept CircuitOpenError:\n    # Circuit is open, use fallback or queue for later\n    print(\"Service unavailable, using fallback\")\n    return fallback_response()\n</code></pre>"},{"location":"error-handling/#3-validate-connection-before-sending","title":"3. Validate Connection Before Sending","text":"<pre><code>async with ASAPClient(base_url=\"https://api.example.com\") as client:\n    # Optional: Validate connection before sending\n    is_valid = await client._validate_connection()\n    if not is_valid:\n        print(\"Connection validation failed, but attempting anyway...\")\n\n    # Send envelope (will retry automatically on failure)\n    response = await client.send(envelope)\n</code></pre>"},{"location":"error-handling/#4-monitor-and-alert","title":"4. Monitor and Alert","text":"<p>Set up monitoring for connection errors:</p> <pre><code>from asap.errors import ASAPConnectionError\nimport metrics\n\nasync def monitored_send(client, envelope):\n    \"\"\"Send envelope with error monitoring.\"\"\"\n    try:\n        response = await client.send(envelope)\n        metrics.increment(\"asap.requests.success\")\n        return response\n    except ASAPConnectionError as e:\n        metrics.increment(\"asap.requests.connection_error\")\n        metrics.increment(f\"asap.errors.connection.{e.url}\")\n        # Send alert if error rate is high\n        raise\n</code></pre>"},{"location":"error-handling/#example-complete-error-handling","title":"Example: Complete Error Handling","text":"<pre><code>from asap.transport.client import ASAPClient\nfrom asap.errors import (\n    ASAPConnectionError,\n    ASAPTimeoutError,\n    CircuitOpenError,\n    ASAPRemoteError,\n)\nfrom asap.models.envelope import Envelope\n\nasync def robust_send(envelope: Envelope, base_url: str):\n    \"\"\"Send envelope with comprehensive error handling.\"\"\"\n    try:\n        async with ASAPClient(\n            base_url=base_url,\n            timeout=30.0,\n            max_retries=3,\n            circuit_breaker_enabled=True,\n        ) as client:\n            response = await client.send(envelope)\n            return response\n\n    except CircuitOpenError as e:\n        print(f\"Circuit breaker is open: {e.message}\")\n        print(\"Service is temporarily unavailable. Please try again later.\")\n        raise\n\n    except ASAPConnectionError as e:\n        print(f\"Connection failed: {e.message}\")\n        print(f\"Troubleshooting:\")\n        print(f\"1. Verify agent is running at {e.url}\")\n        print(f\"2. Check network connectivity\")\n        print(f\"3. Verify URL format and port\")\n        raise\n\n    except ASAPTimeoutError as e:\n        print(f\"Request timed out after {e.timeout} seconds\")\n        print(\"Consider increasing timeout or checking network latency\")\n        raise\n\n    except ASAPRemoteError as e:\n        print(f\"Remote error: {e.code} - {e.message}\")\n        print(f\"Error details: {e.data}\")\n        raise\n</code></pre>"},{"location":"error-handling/#related-documentation","title":"Related Documentation","text":"<ul> <li>Transport Guide - HTTP/JSON-RPC binding details</li> <li>Security Guide - Authentication and TLS configuration</li> <li>Observability - Logging and tracing for debugging</li> </ul>"},{"location":"mcp-integration/","title":"MCP Integration","text":"<p>This guide describes how to use the Model Context Protocol (MCP) with ASAP. The implementation follows MCP spec 2025-11-25 and supports the stdio transport plus the tools feature (list and call).</p>"},{"location":"mcp-integration/#overview","title":"Overview","text":"<ul> <li>MCP server: Exposes tools over stdio; clients (e.g. IDEs, Claude Desktop) launch the server as a subprocess and send JSON-RPC messages.</li> <li>MCP client: Connects to a server process, performs the initialize handshake, and can list tools and call them.</li> </ul> <p>ASAP provides:</p> <ul> <li><code>asap.mcp.MCPServer</code>: Build a server that exposes tools over stdio.</li> <li><code>asap.mcp.MCPClient</code>: Connect to an MCP server (e.g. for tests or automation).</li> <li>Protocol types in <code>asap.mcp.protocol</code> (JSON-RPC, Initialize, Tool, CallToolResult, etc.).</li> </ul>"},{"location":"mcp-integration/#how-to-expose-asap-agents-as-mcp-servers","title":"How to Expose ASAP Agents as MCP Servers","text":"<p>You can expose an ASAP agent\u2019s capabilities as MCP tools by running an MCP server that forwards tool calls to your agent (e.g. via ASAP envelopes).</p>"},{"location":"mcp-integration/#1-implement-an-mcp-server-with-tools","title":"1. Implement an MCP server with tools","text":"<pre><code>from asap.mcp import MCPServer\n\nserver = MCPServer(\n    name=\"my-asap-mcp\",\n    version=\"1.0.0\",\n    description=\"MCP server that forwards to ASAP agent\",\n)\nserver.register_tool(\n    \"task_request\",\n    your_task_request_handler,\n    {\"type\": \"object\", \"properties\": {\"conversation_id\": {\"type\": \"string\"}, \"payload\": {\"type\": \"object\"}}, \"required\": [\"conversation_id\"]},\n    description=\"Send a task request to the ASAP agent\",\n)\n# Add more tools as needed\n</code></pre> <p>Your handler can be sync or async; it receives the tool <code>arguments</code> as keyword arguments and can return a string or a dict (serialized to text in the result).</p>"},{"location":"mcp-integration/#2-run-the-server-over-stdio","title":"2. Run the server over stdio","text":"<p>Clients (e.g. Claude Desktop, Cursor) start your server as a subprocess and talk to it via stdin/stdout. So the process entry point must run the server loop:</p> <pre><code># server_runner.py or __main__\nimport asyncio\nfrom asap.mcp import MCPServer\n\nasync def main():\n    server = MCPServer(...)\n    # register_tool(...)\n    await server.run_stdio()\n\nasyncio.run(main())\n</code></pre> <p>Run with:</p> <pre><code>python -m your_package.server_runner\n</code></pre> <p>Configure the client to use this command so it launches the server and connects over stdio.</p>"},{"location":"mcp-integration/#3-forward-tool-calls-to-asap","title":"3. Forward tool calls to ASAP","text":"<p>Inside a tool handler, build an ASAP envelope (e.g. <code>mcp_tool_call</code> / <code>mcp_tool_result</code> or your own payload types), call your ASAP agent via <code>ASAPClient.send()</code>, and map the response into MCP <code>CallToolResult</code> (e.g. a single <code>TextContent</code> with the result text). The MCP server\u2019s <code>register_tool</code> handler return value is turned into text automatically; for more control you could run a small internal MCP server that builds <code>CallToolResult</code> explicitly and then have the stdio server return that.</p>"},{"location":"mcp-integration/#connecting-claude-gemini-to-asap","title":"Connecting Claude / Gemini to ASAP","text":"<p>To connect a host application (e.g. Claude Desktop, or a Gemini-based app) to ASAP via MCP:</p> <ol> <li> <p>Run an MCP server that exposes tools backed by your ASAP agent (see above). The host starts this server as a subprocess and communicates over stdio.</p> </li> <li> <p>Configure the host to use your server command, for example in Claude Desktop\u2019s config add your server under MCP servers with the command that runs your <code>server_runner</code> (e.g. <code>python -m your_package.server_runner</code>).</p> </li> <li> <p>Tool discovery: The host will send <code>initialize</code> and then <code>tools/list</code>; your server returns the list of tools (name, description, inputSchema). The host can then show these tools to the user or the model.</p> </li> <li> <p>Tool execution: When the user or model invokes a tool, the host sends <code>tools/call</code> with <code>name</code> and <code>arguments</code>. Your server executes the handler (and optionally forwards to the ASAP agent), then returns a result with <code>content</code> (e.g. <code>[{\"type\": \"text\", \"text\": \"...\"}]</code>) and <code>isError: false</code> (or <code>true</code> for tool-level errors).</p> </li> </ol> <p>This way, Claude or Gemini can \u201csee\u201d your ASAP-backed tools and call them; your MCP server is the bridge between MCP and ASAP.</p>"},{"location":"mcp-integration/#demo","title":"Demo","text":"<p>A minimal demo that starts the built-in demo server (echo tool) and calls it:</p> <pre><code>PYTHONPATH=src uv run python examples/mcp_demo.py\n</code></pre> <p>The demo uses <code>MCPClient</code> to start <code>asap.mcp.server_runner</code> as a subprocess, performs initialize, lists tools, and calls the <code>echo</code> tool.</p>"},{"location":"mcp-integration/#protocol-version","title":"Protocol version","text":"<p>This implementation follows MCP 2025-11-25. For a short reference of the types and messages used, see mcp-specs.md in the repo.</p>"},{"location":"metrics/","title":"Metrics Guide","text":"<p>Prometheus-compatible metrics for monitoring ASAP protocol agents.</p>"},{"location":"metrics/#overview","title":"Overview","text":"<p>ASAP provides built-in metrics collection for observability and monitoring. Metrics are exposed in Prometheus text format via the <code>/asap/metrics</code> endpoint.</p>"},{"location":"metrics/#features","title":"Features","text":"<ul> <li>Request Counts: Track total, successful, and failed requests</li> <li>Latency Histograms: Measure request processing duration</li> <li>Error Classification: Categorize errors by type</li> <li>Process Uptime: Monitor agent availability</li> </ul>"},{"location":"metrics/#metrics-endpoint","title":"Metrics Endpoint","text":""},{"location":"metrics/#get-asapmetrics","title":"GET <code>/asap/metrics</code>","text":"<p>Returns all collected metrics in Prometheus text format.</p>"},{"location":"metrics/#request","title":"Request","text":"<pre><code>curl http://localhost:8000/asap/metrics\n</code></pre>"},{"location":"metrics/#response","title":"Response","text":"<pre><code># HELP asap_requests_total Total number of ASAP requests received\n# TYPE asap_requests_total counter\nasap_requests_total{payload_type=\"task.request\",status=\"success\"} 42\nasap_requests_total{payload_type=\"task.request\",status=\"error\"} 3\n\n# HELP asap_requests_success_total Total number of successful ASAP requests\n# TYPE asap_requests_success_total counter\nasap_requests_success_total{payload_type=\"task.request\"} 42\n\n# HELP asap_requests_error_total Total number of failed ASAP requests\n# TYPE asap_requests_error_total counter\nasap_requests_error_total{payload_type=\"task.request\",error_type=\"handler_not_found\"} 2\nasap_requests_error_total{payload_type=\"task.request\",error_type=\"invalid_envelope\"} 1\n\n# HELP asap_request_duration_seconds Request processing duration in seconds\n# TYPE asap_request_duration_seconds histogram\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.005\"} 10\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.01\"} 25\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.025\"} 38\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.05\"} 40\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.1\"} 41\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.25\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"0.5\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"1.0\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"2.5\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"5.0\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"10.0\"} 42\nasap_request_duration_seconds_bucket{payload_type=\"task.request\",status=\"success\",le=\"+Inf\"} 42\nasap_request_duration_seconds_sum{payload_type=\"task.request\",status=\"success\"} 1.234\nasap_request_duration_seconds_count{payload_type=\"task.request\",status=\"success\"} 42\n\n# HELP asap_process_uptime_seconds Time since server start\n# TYPE asap_process_uptime_seconds gauge\nasap_process_uptime_seconds 3600.123\n</code></pre>"},{"location":"metrics/#available-metrics","title":"Available Metrics","text":""},{"location":"metrics/#counters","title":"Counters","text":"Metric Labels Description <code>asap_requests_total</code> <code>payload_type</code>, <code>status</code> Total requests received <code>asap_requests_success_total</code> <code>payload_type</code> Successful requests <code>asap_requests_error_total</code> <code>payload_type</code>, <code>error_type</code> Failed requests"},{"location":"metrics/#histograms","title":"Histograms","text":"Metric Labels Buckets Description <code>asap_request_duration_seconds</code> <code>payload_type</code>, <code>status</code> 5ms to 10s Processing duration"},{"location":"metrics/#gauges","title":"Gauges","text":"Metric Description <code>asap_process_uptime_seconds</code> Time since server start"},{"location":"metrics/#labels","title":"Labels","text":""},{"location":"metrics/#payload_type","title":"<code>payload_type</code>","text":"<p>The ASAP payload type being processed:</p> <ul> <li><code>task.request</code> - Task request</li> <li><code>task.response</code> - Task response</li> <li><code>mcp.tool_call</code> - MCP tool invocation</li> <li><code>unknown</code> - Unrecognized or malformed payload</li> </ul>"},{"location":"metrics/#status","title":"<code>status</code>","text":"<p>Request outcome:</p> <ul> <li><code>success</code> - Request processed successfully</li> <li><code>error</code> - Request failed</li> </ul>"},{"location":"metrics/#error_type","title":"<code>error_type</code>","text":"<p>Error classification (only on error metrics):</p> <ul> <li><code>invalid_envelope</code> - Malformed envelope structure</li> <li><code>handler_not_found</code> - No handler for payload type</li> <li><code>internal_error</code> - Unhandled exception</li> </ul>"},{"location":"metrics/#using-the-metrics-api","title":"Using the Metrics API","text":""},{"location":"metrics/#programmatic-access","title":"Programmatic Access","text":"<pre><code>from asap.observability import get_metrics\n\n# Get the global metrics collector\nmetrics = get_metrics()\n\n# Increment a counter\nmetrics.increment_counter(\n    \"asap_requests_total\",\n    {\"payload_type\": \"task.request\", \"status\": \"success\"}\n)\n\n# Record a histogram observation\nmetrics.observe_histogram(\n    \"asap_request_duration_seconds\",\n    0.125,  # 125ms\n    {\"payload_type\": \"task.request\", \"status\": \"success\"}\n)\n\n# Export Prometheus format\nprometheus_output = metrics.export_prometheus()\nprint(prometheus_output)\n</code></pre>"},{"location":"metrics/#custom-metrics","title":"Custom Metrics","text":"<p>Register custom metrics for your agent:</p> <pre><code>from asap.observability import get_metrics\n\nmetrics = get_metrics()\n\n# Register a custom counter\nmetrics.register_counter(\n    \"myagent_tasks_processed_total\",\n    \"Total tasks processed by my agent\"\n)\n\n# Register a custom histogram\nmetrics.register_histogram(\n    \"myagent_skill_duration_seconds\",\n    \"Time spent executing skills\",\n    buckets=(0.1, 0.5, 1.0, 5.0, 10.0)\n)\n\n# Use custom metrics\nmetrics.increment_counter(\n    \"myagent_tasks_processed_total\",\n    {\"skill\": \"research\"}\n)\nmetrics.observe_histogram(\n    \"myagent_skill_duration_seconds\",\n    2.5,\n    {\"skill\": \"research\"}\n)\n</code></pre>"},{"location":"metrics/#prometheus-integration","title":"Prometheus Integration","text":""},{"location":"metrics/#scrape-configuration","title":"Scrape Configuration","text":"<p>Add the ASAP agent to your Prometheus configuration:</p> <pre><code># prometheus.yml\nscrape_configs:\n  - job_name: 'asap-agents'\n    scrape_interval: 15s\n    static_configs:\n      - targets:\n          - 'agent1.example.com:8000'\n          - 'agent2.example.com:8000'\n    metrics_path: '/asap/metrics'\n</code></pre>"},{"location":"metrics/#service-discovery","title":"Service Discovery","text":"<p>For Kubernetes deployments:</p> <pre><code># prometheus.yml\nscrape_configs:\n  - job_name: 'asap-agents'\n    kubernetes_sd_configs:\n      - role: pod\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_label_app]\n        regex: asap-agent\n        action: keep\n      - source_labels: [__meta_kubernetes_pod_container_port_number]\n        regex: \"8000\"\n        action: keep\n    metrics_path: '/asap/metrics'\n</code></pre>"},{"location":"metrics/#grafana-dashboard","title":"Grafana Dashboard","text":""},{"location":"metrics/#example-queries","title":"Example Queries","text":""},{"location":"metrics/#request-rate","title":"Request Rate","text":"<pre><code>rate(asap_requests_total[5m])\n</code></pre>"},{"location":"metrics/#success-rate","title":"Success Rate","text":"<pre><code>sum(rate(asap_requests_success_total[5m])) \n/ \nsum(rate(asap_requests_total[5m]))\n</code></pre>"},{"location":"metrics/#error-rate-by-type","title":"Error Rate by Type","text":"<pre><code>sum by (error_type) (rate(asap_requests_error_total[5m]))\n</code></pre>"},{"location":"metrics/#p50-latency","title":"P50 Latency","text":"<pre><code>histogram_quantile(0.5, \n  sum by (le) (rate(asap_request_duration_seconds_bucket[5m]))\n)\n</code></pre>"},{"location":"metrics/#p99-latency","title":"P99 Latency","text":"<pre><code>histogram_quantile(0.99, \n  sum by (le) (rate(asap_request_duration_seconds_bucket[5m]))\n)\n</code></pre>"},{"location":"metrics/#request-duration-by-payload-type","title":"Request Duration by Payload Type","text":"<pre><code>histogram_quantile(0.95, \n  sum by (payload_type, le) (rate(asap_request_duration_seconds_bucket[5m]))\n)\n</code></pre>"},{"location":"metrics/#dashboard-json","title":"Dashboard JSON","text":"<p>A sample Grafana dashboard configuration:</p> <pre><code>{\n  \"title\": \"ASAP Agent Metrics\",\n  \"panels\": [\n    {\n      \"title\": \"Request Rate\",\n      \"type\": \"graph\",\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(asap_requests_total[5m])) by (status)\",\n          \"legendFormat\": \"{{status}}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Latency (P50/P95/P99)\",\n      \"type\": \"graph\",\n      \"targets\": [\n        {\n          \"expr\": \"histogram_quantile(0.5, sum(rate(asap_request_duration_seconds_bucket[5m])) by (le))\",\n          \"legendFormat\": \"P50\"\n        },\n        {\n          \"expr\": \"histogram_quantile(0.95, sum(rate(asap_request_duration_seconds_bucket[5m])) by (le))\",\n          \"legendFormat\": \"P95\"\n        },\n        {\n          \"expr\": \"histogram_quantile(0.99, sum(rate(asap_request_duration_seconds_bucket[5m])) by (le))\",\n          \"legendFormat\": \"P99\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Errors by Type\",\n      \"type\": \"piechart\",\n      \"targets\": [\n        {\n          \"expr\": \"sum by (error_type) (increase(asap_requests_error_total[1h]))\",\n          \"legendFormat\": \"{{error_type}}\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"metrics/#alerting-rules","title":"Alerting Rules","text":"<p>Sample Prometheus alerting rules:</p> <pre><code># alerts.yml\ngroups:\n  - name: asap-agent-alerts\n    rules:\n      - alert: ASAPHighErrorRate\n        expr: |\n          sum(rate(asap_requests_error_total[5m])) \n          / \n          sum(rate(asap_requests_total[5m])) \n          &gt; 0.1\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High error rate on ASAP agent\"\n          description: \"Error rate is above 10% for 5 minutes\"\n\n      - alert: ASAPHighLatency\n        expr: |\n          histogram_quantile(0.99, \n            sum(rate(asap_request_duration_seconds_bucket[5m])) by (le)\n          ) &gt; 1.0\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High latency on ASAP agent\"\n          description: \"P99 latency is above 1 second\"\n\n      - alert: ASAPAgentDown\n        expr: up{job=\"asap-agents\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"ASAP agent is down\"\n          description: \"Agent {{ $labels.instance }} is not responding\"\n</code></pre>"},{"location":"metrics/#best-practices","title":"Best Practices","text":""},{"location":"metrics/#1-use-meaningful-labels","title":"1. Use Meaningful Labels","text":"<p>Keep labels low-cardinality to avoid metric explosion:</p> <pre><code># Good: Fixed set of values\nmetrics.increment_counter(\"asap_requests_total\", {\"status\": \"success\"})\n\n# Avoid: High-cardinality labels\nmetrics.increment_counter(\"asap_requests_total\", {\"request_id\": unique_id})\n</code></pre>"},{"location":"metrics/#2-set-appropriate-scrape-intervals","title":"2. Set Appropriate Scrape Intervals","text":"<ul> <li>15s: Standard for most use cases</li> <li>5s: High-resolution monitoring</li> <li>60s: Cost-sensitive environments</li> </ul>"},{"location":"metrics/#3-monitor-key-slis","title":"3. Monitor Key SLIs","text":"<p>Focus on the four golden signals:</p> <ol> <li>Latency: <code>asap_request_duration_seconds</code></li> <li>Traffic: <code>rate(asap_requests_total[5m])</code></li> <li>Errors: <code>asap_requests_error_total</code></li> <li>Saturation: Custom metrics for queue depth, etc.</li> </ol>"},{"location":"metrics/#4-retention-policies","title":"4. Retention Policies","text":"<p>Configure appropriate retention for your metrics:</p> <pre><code># prometheus.yml\nglobal:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nstorage:\n  tsdb:\n    retention.time: 15d\n    retention.size: 10GB\n</code></pre>"},{"location":"metrics/#related-documentation","title":"Related Documentation","text":"<ul> <li>Observability - Logging and tracing</li> <li>Transport - HTTP endpoint details</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"migration/","title":"Migration Guide","text":"<p>Migrating from A2A (Agent-to-Agent) and MCP (Model Context Protocol) to ASAP.</p>"},{"location":"migration/#overview","title":"Overview","text":"<p>ASAP (Agent State and Action Protocol) builds upon concepts from both A2A and MCP, providing a unified protocol for agent-to-agent communication. This guide helps developers migrate existing agents to ASAP.</p>"},{"location":"migration/#protocol-comparison","title":"Protocol Comparison","text":"Feature A2A MCP ASAP Focus Agent communication Tool/resource access Unified agent protocol State Management Limited None First-class snapshots Message Format JSON JSON-RPC JSON-RPC + Envelope Discovery Agent Card Server info Manifest Task Lifecycle Basic N/A Full state machine Streaming SSE Stdio/SSE WebSocket (planned)"},{"location":"migration/#envelope-and-payload-mapping","title":"Envelope and Payload Mapping","text":""},{"location":"migration/#a2a-to-asap","title":"A2A to ASAP","text":""},{"location":"migration/#a2a-message-structure","title":"A2A Message Structure","text":"<pre><code>{\n  \"type\": \"task\",\n  \"id\": \"task-123\",\n  \"from\": \"agent-a\",\n  \"to\": \"agent-b\",\n  \"content\": {\n    \"action\": \"research\",\n    \"input\": {\"query\": \"AI trends\"}\n  }\n}\n</code></pre>"},{"location":"migration/#asap-envelope-structure","title":"ASAP Envelope Structure","text":"<pre><code>{\n  \"id\": \"env_01HX5K4P...\",\n  \"asap_version\": \"0.1\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"sender\": \"urn:asap:agent:agent-a\",\n  \"recipient\": \"urn:asap:agent:agent-b\",\n  \"payload_type\": \"task.request\",\n  \"payload\": {\n    \"conversation_id\": \"conv_01HX5K3M...\",\n    \"skill_id\": \"research\",\n    \"input\": {\"query\": \"AI trends\"}\n  },\n  \"trace_id\": \"trace_01HX5K...\"\n}\n</code></pre>"},{"location":"migration/#key-differences","title":"Key Differences","text":"A2A Field ASAP Field Notes <code>type</code> <code>payload_type</code> More specific typing <code>id</code> <code>id</code> ULID format in ASAP <code>from</code> <code>sender</code> URN format required <code>to</code> <code>recipient</code> URN format required <code>content</code> <code>payload</code> Structured per payload type (none) <code>asap_version</code> Protocol versioning (none) <code>timestamp</code> Auto-generated (none) <code>trace_id</code> Distributed tracing (none) <code>correlation_id</code> Request/response pairing"},{"location":"migration/#mcp-to-asap","title":"MCP to ASAP","text":""},{"location":"migration/#mcp-tool-call","title":"MCP Tool Call","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"web_search\",\n    \"arguments\": {\"query\": \"AI trends\"}\n  },\n  \"id\": 1\n}\n</code></pre>"},{"location":"migration/#asap-mcp-tool-call","title":"ASAP MCP Tool Call","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"asap.send\",\n  \"params\": {\n    \"envelope\": {\n      \"asap_version\": \"0.1\",\n      \"sender\": \"urn:asap:agent:coordinator\",\n      \"recipient\": \"urn:asap:agent:tools-agent\",\n      \"payload_type\": \"mcp.tool_call\",\n      \"payload\": {\n        \"request_id\": \"req_01HX5K...\",\n        \"tool_name\": \"web_search\",\n        \"arguments\": {\"query\": \"AI trends\"},\n        \"mcp_context\": {}\n      }\n    }\n  },\n  \"id\": \"req-1\"\n}\n</code></pre>"},{"location":"migration/#key-differences_1","title":"Key Differences","text":"MCP Field ASAP Field Notes <code>method</code> <code>payload_type</code> <code>mcp.tool_call</code> for tools <code>params.name</code> <code>payload.tool_name</code> Tool identifier <code>params.arguments</code> <code>payload.arguments</code> Same structure (none) <code>sender</code>/<code>recipient</code> Agent identity (none) <code>mcp_context</code> Additional context"},{"location":"migration/#agent-card-to-manifest","title":"Agent Card to Manifest","text":""},{"location":"migration/#a2a-agent-card","title":"A2A Agent Card","text":"<pre><code>{\n  \"name\": \"Research Agent\",\n  \"description\": \"Performs web research\",\n  \"url\": \"https://agent.example.com\",\n  \"capabilities\": [\"research\", \"summarize\"],\n  \"authentication\": {\n    \"type\": \"bearer\"\n  }\n}\n</code></pre>"},{"location":"migration/#asap-manifest","title":"ASAP Manifest","text":"<pre><code>{\n  \"id\": \"urn:asap:agent:research-v1\",\n  \"name\": \"Research Agent\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Performs web research\",\n  \"capabilities\": {\n    \"asap_version\": \"0.1\",\n    \"skills\": [\n      {\n        \"id\": \"research\",\n        \"description\": \"Search and analyze information\",\n        \"input_schema\": {\"type\": \"object\"},\n        \"output_schema\": {\"type\": \"object\"}\n      },\n      {\n        \"id\": \"summarize\",\n        \"description\": \"Summarize content\",\n        \"input_schema\": {\"type\": \"object\"},\n        \"output_schema\": {\"type\": \"object\"}\n      }\n    ],\n    \"state_persistence\": true,\n    \"streaming\": false,\n    \"mcp_tools\": []\n  },\n  \"endpoints\": {\n    \"asap\": \"https://agent.example.com/asap\",\n    \"events\": null\n  },\n  \"auth\": {\n    \"schemes\": [\"bearer\"],\n    \"oauth2\": null\n  }\n}\n</code></pre>"},{"location":"migration/#key-improvements-in-asap","title":"Key Improvements in ASAP","text":"Feature A2A Agent Card ASAP Manifest Identity URL-based URN-based (<code>urn:asap:agent:*</code>) Versioning None Semantic versioning Skills String list Structured with schemas State Not specified <code>state_persistence</code> flag Endpoints Single URL Multiple endpoints Validation None JSON Schema for I/O"},{"location":"migration/#payload-type-mapping","title":"Payload Type Mapping","text":""},{"location":"migration/#task-operations","title":"Task Operations","text":"A2A Action MCP Method ASAP Payload Type <code>task.create</code> N/A <code>task.request</code> <code>task.status</code> N/A <code>task.response</code> <code>task.update</code> N/A <code>task.update</code> <code>task.cancel</code> N/A <code>task.cancel</code>"},{"location":"migration/#mcp-operations","title":"MCP Operations","text":"MCP Method ASAP Payload Type <code>tools/call</code> <code>mcp.tool_call</code> <code>tools/call</code> (response) <code>mcp.tool_result</code> <code>resources/read</code> <code>mcp.resource_fetch</code> <code>resources/read</code> (response) <code>mcp.resource_data</code>"},{"location":"migration/#message-operations","title":"Message Operations","text":"Operation ASAP Payload Type Send message <code>message.send</code> Query state <code>state.query</code> Restore state <code>state.restore</code> Notify artifact <code>artifact.notify</code>"},{"location":"migration/#migration-checklist","title":"Migration Checklist","text":""},{"location":"migration/#phase-1-preparation","title":"Phase 1: Preparation","text":"<ul> <li>[ ] Review current protocol usage</li> <li>Document all A2A/MCP endpoints in use</li> <li>List all message types and payloads</li> <li> <p>Identify state management patterns</p> </li> <li> <p>[ ] Plan agent identity</p> </li> <li>Define URN format: <code>urn:asap:agent:{agent-name}</code></li> <li>Plan versioning strategy (semantic versioning)</li> <li> <p>Document skill definitions</p> </li> <li> <p>[ ] Set up ASAP dependencies <code>bash   # Install ASAP protocol library   pip install asap-protocol   # Or with uv   uv add asap-protocol</code></p> </li> </ul>"},{"location":"migration/#phase-2-manifest-creation","title":"Phase 2: Manifest Creation","text":"<ul> <li>[ ] Create agent manifest   ```python   from asap.models.entities import (       Manifest, Capability, Endpoint, Skill, AuthScheme   )</li> </ul> <p>manifest = Manifest(       id=\"urn:asap:agent:my-agent\",       name=\"My Agent\",       version=\"1.0.0\",       description=\"Migrated from A2A/MCP\",       capabilities=Capability(           asap_version=\"0.1\",           skills=[               Skill(id=\"skill1\", description=\"...\"),               # Add all skills           ],           state_persistence=True,  # Enable if needed           streaming=False,           mcp_tools=[\"tool1\", \"tool2\"],  # MCP tools       ),       endpoints=Endpoint(asap=\"https://my-agent.example.com/asap\"),       auth=AuthScheme(schemes=[\"bearer\"]),   )   ```</p> <ul> <li>[ ] Expose manifest endpoint <code>python   # Manifest will be available at:   # GET /.well-known/asap/manifest.json</code></li> </ul>"},{"location":"migration/#phase-3-message-conversion","title":"Phase 3: Message Conversion","text":"<ul> <li>[ ] Update message sending   ```python   # Before (A2A style)   message = {\"type\": \"task\", \"from\": \"agent-a\", ...}   response = requests.post(url, json=message)</li> </ul> <p># After (ASAP)   from asap.transport.client import ASAPClient   from asap.models.envelope import Envelope</p> <p>envelope = Envelope(       asap_version=\"0.1\",       sender=\"urn:asap:agent:agent-a\",       recipient=\"urn:asap:agent:agent-b\",       payload_type=\"task.request\",       payload={...}   )</p> <p>async with ASAPClient(base_url=url) as client:       response = await client.send(envelope)   ```</p> <ul> <li>[ ] Update message receiving   ```python   # Use ASAP server with handler registry   from asap.transport.server import create_app   from asap.transport.handlers import HandlerRegistry</li> </ul> <p>registry = HandlerRegistry()   registry.register(\"task.request\", handle_task_request)</p> <p>app = create_app(manifest, registry)   ```</p>"},{"location":"migration/#phase-4-state-management","title":"Phase 4: State Management","text":"<ul> <li>[ ] Implement state snapshots (if using state persistence)   ```python   from asap.state.snapshot import InMemorySnapshotStore   from asap.models.entities import StateSnapshot</li> </ul> <p>store = InMemorySnapshotStore()</p> <p># Save state   snapshot = StateSnapshot(       id=generate_id(),       task_id=task.id,       version=1,       data={\"current_state\": \"...\"},       checkpoint=True,       created_at=datetime.now(timezone.utc),   )   store.save(snapshot)</p> <p># Restore state   restored = store.get(task_id)   ```</p> <ul> <li>[ ] Use state machine for task lifecycle   ```python   from asap.state.machine import transition, can_transition   from asap.models.enums import TaskStatus</li> </ul> <p># Validate and perform transition   if can_transition(task.status, TaskStatus.COMPLETED):       task = transition(task, TaskStatus.COMPLETED)   ```</p>"},{"location":"migration/#phase-5-testing","title":"Phase 5: Testing","text":"<ul> <li>[ ] Unit tests for new handlers   ```python   import pytest   from asap.transport.server import create_app   from fastapi.testclient import TestClient</li> </ul> <p>def test_task_request():       app = create_app(manifest)       client = TestClient(app)</p> <pre><code>  response = client.post(\"/asap\", json={\n      \"jsonrpc\": \"2.0\",\n      \"method\": \"asap.send\",\n      \"params\": {\"envelope\": {...}},\n      \"id\": \"test-1\"\n  })\n\n  assert response.status_code == 200\n</code></pre> <p>```</p> <ul> <li> <p>[ ] Integration tests <code>python   @pytest.mark.asyncio   async def test_full_flow():       async with ASAPClient(base_url=\"http://localhost:8000\") as client:           response = await client.send(envelope)           assert response.payload_type == \"task.response\"</code></p> </li> <li> <p>[ ] Verify manifest discovery <code>bash   curl http://localhost:8000/.well-known/asap/manifest.json</code></p> </li> </ul>"},{"location":"migration/#phase-6-deployment","title":"Phase 6: Deployment","text":"<ul> <li>[ ] Update API documentation</li> <li>[ ] Configure monitoring (trace IDs, logging)</li> <li>[ ] Set up TLS (required for production)</li> <li>[ ] Configure authentication</li> <li>[ ] Gradual rollout</li> <li>Deploy ASAP endpoint alongside existing</li> <li>Route traffic gradually</li> <li>Monitor for errors</li> <li>Deprecate old endpoints</li> </ul>"},{"location":"migration/#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"migration/#pattern-1-dual-protocol-support","title":"Pattern 1: Dual-Protocol Support","text":"<p>Run both A2A/MCP and ASAP during transition:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n# Legacy A2A endpoint\n@app.post(\"/a2a\")\nasync def handle_a2a(request: dict):\n    # Convert to ASAP internally\n    envelope = convert_a2a_to_asap(request)\n    return await process_envelope(envelope)\n\n# New ASAP endpoint\n@app.post(\"/asap\")\nasync def handle_asap(request: dict):\n    return await process_envelope(request)\n</code></pre>"},{"location":"migration/#pattern-2-mcp-tool-wrapper","title":"Pattern 2: MCP Tool Wrapper","text":"<p>Wrap existing MCP tools for ASAP:</p> <pre><code>from asap.transport.handlers import HandlerRegistry\n\ndef create_mcp_handler(mcp_tool_function):\n    \"\"\"Wrap MCP tool as ASAP handler.\"\"\"\n    def handler(envelope, manifest):\n        tool_name = envelope.payload[\"tool_name\"]\n        arguments = envelope.payload[\"arguments\"]\n\n        # Call original MCP tool\n        result = mcp_tool_function(tool_name, arguments)\n\n        # Return ASAP response\n        return create_tool_result_envelope(envelope, result)\n\n    return handler\n\nregistry = HandlerRegistry()\nregistry.register(\"mcp.tool_call\", create_mcp_handler(call_mcp_tool))\n</code></pre>"},{"location":"migration/#pattern-3-state-migration","title":"Pattern 3: State Migration","text":"<p>Migrate existing state to ASAP snapshots:</p> <pre><code>async def migrate_state(old_state_store, new_snapshot_store):\n    \"\"\"Migrate state from old format to ASAP snapshots.\"\"\"\n    for task_id, state in old_state_store.items():\n        snapshot = StateSnapshot(\n            id=generate_id(),\n            task_id=task_id,\n            version=1,\n            data=state,\n            checkpoint=True,\n            created_at=datetime.now(timezone.utc),\n        )\n        new_snapshot_store.save(snapshot)\n</code></pre>"},{"location":"migration/#upgrading-asap-protocol-versions","title":"Upgrading ASAP Protocol Versions","text":""},{"location":"migration/#version-history","title":"Version History","text":"<p>ASAP Protocol has evolved through the following releases: - v0.1.0 (2026-01-23): Initial alpha release with core models, state management, and HTTP transport - v0.3.0 (2026-01-26): Test infrastructure refactoring and stability improvements - v0.5.0 (2026-01-28): Security-hardened release with authentication, DoS protection, and comprehensive security features</p>"},{"location":"migration/#upgrading-from-v010-or-v030-to-v050","title":"Upgrading from v0.1.0 or v0.3.0 to v0.5.0","text":"<p>v0.5.0 is a security-hardened release with zero breaking changes. All existing code from v0.1.0 and v0.3.0 will work without modifications.</p> <p>Upgrade Paths: - v0.1.0 \u2192 v0.5.0: Direct upgrade supported (tested and verified) - v0.3.0 \u2192 v0.5.0: Direct upgrade supported (tested and verified) - v0.1.0 \u2192 v0.3.0 \u2192 v0.5.0: Sequential upgrade also supported</p>"},{"location":"migration/#whats-new-in-v050","title":"What's New in v0.5.0","text":"<ul> <li>Security Features (all opt-in):</li> <li>Bearer token authentication</li> <li>Timestamp validation (5-minute window)</li> <li>Optional nonce validation for replay attack prevention</li> <li>Rate limiting (100 req/min, configurable)</li> <li>Request size limits (10MB, configurable)</li> <li>HTTPS enforcement (client-side)</li> <li> <p>Secure logging (automatic sanitization)</p> </li> <li> <p>Retry Logic:</p> </li> <li>Exponential backoff with jitter</li> <li>Circuit breaker pattern</li> <li> <p><code>Retry-After</code> header support</p> </li> <li> <p>Code Quality:</p> </li> <li>Full mypy strict compliance</li> <li>Enhanced error handling</li> <li>Improved test coverage (95.90%)</li> </ul>"},{"location":"migration/#upgrade-steps","title":"Upgrade Steps","text":"<ol> <li> <p>Update Dependencies:    <code>bash    pip install --upgrade asap-protocol==0.5.0    # or    uv add asap-protocol==0.5.0</code></p> </li> <li> <p>Verify Compatibility:    Your existing code should work without changes:    ```python    # This code from v0.1.0/v0.3.0 still works in v0.5.0    from asap.models.entities import Manifest, Capability, Endpoint, Skill    from asap.transport.handlers import HandlerRegistry, create_echo_handler    from asap.transport.server import create_app</p> </li> </ol> <p>manifest = Manifest(        id=\"urn:asap:agent:my-agent\",        name=\"My Agent\",        version=\"1.0.0\",        description=\"My agent\",        capabilities=Capability(            asap_version=\"0.1\",            skills=[Skill(id=\"echo\", description=\"Echo skill\")],            state_persistence=False,        ),        endpoints=Endpoint(asap=\"http://127.0.0.1:8000/asap\"),    )</p> <p>registry = HandlerRegistry()    registry.register(\"task.request\", create_echo_handler())    app = create_app(manifest, registry)    ```</p> <ol> <li>Opt-in to Security Features (optional):    ```python    from asap.models.entities import AuthScheme    from asap.transport.middleware import BearerTokenValidator</li> </ol> <p># Add authentication (optional)    def validate_token(token: str) -&gt; str | None:        if token == \"my-secret-token\":            return \"urn:asap:agent:client\"        return None</p> <p>manifest = Manifest(        # ... existing manifest ...        auth=AuthScheme(schemes=[\"bearer\"])  # Enable authentication    )</p> <p>app = create_app(        manifest,        registry,        token_validator=validate_token,  # Add token validator        rate_limit=\"10/second;100/minute\", # Burst + sustained rate limiting        require_nonce=True                # Enable nonce validation    )    ```</p> <ol> <li>Test Your Upgrade:    <code>bash    # Run compatibility tests    uv run python -m pytest tests/compatibility/ -v</code></li> </ol>"},{"location":"migration/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>\u2705 No breaking changes: All v0.1.0 and v0.3.0 APIs remain unchanged</li> <li>\u2705 Security features are opt-in: Existing deployments continue to work</li> <li>\u2705 Default behavior unchanged: Rate limiting and size limits have safe defaults</li> <li>\u2705 Examples still work: All example code from previous versions is compatible</li> </ul>"},{"location":"migration/#migration-checklist_1","title":"Migration Checklist","text":"<ul> <li>[ ] Update <code>asap-protocol</code> to v0.5.0</li> <li>[ ] Run existing tests to verify compatibility</li> <li>[ ] Review security features and opt-in as needed</li> <li>[ ] Update documentation if using new security features</li> <li>[ ] Test in staging environment before production deployment</li> </ul>"},{"location":"migration/#what-changed-between-versions","title":"What Changed Between Versions","text":"<p>v0.1.0 \u2192 v0.3.0 (2026-01-26): - Test infrastructure refactoring - Improved test stability and isolation - Fixed rate limiter initialization issues - Enhanced test organization (unit/integration/E2E separation)</p> <p>v0.3.0 \u2192 v0.5.0 (2026-01-28): - Security hardening (authentication, DoS protection, replay prevention) - Retry logic with exponential backoff - Secure logging with automatic sanitization - Enhanced code quality (mypy strict compliance) - Improved test coverage (95.90%)</p>"},{"location":"migration/#need-help","title":"Need Help?","text":"<ul> <li>See Security Guide for authentication setup</li> <li>See Transport Guide for retry configuration</li> <li>Run compatibility tests: <code>tests/compatibility/test_v0_1_0_compatibility.py</code></li> <li>Guide for migrating from A2A, MCP, or older ASAP versions. See CHANGELOG for version history.</li> </ul>"},{"location":"migration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"migration/#common-issues","title":"Common Issues","text":"Issue Cause Solution <code>Invalid agent URN</code> URN format incorrect Use <code>urn:asap:agent:{name}</code> <code>Missing correlation_id</code> Response without correlation Add <code>correlation_id</code> to responses <code>Method not found</code> Wrong JSON-RPC method Use <code>asap.send</code> <code>Invalid envelope</code> Missing required fields Check <code>sender</code>, <code>recipient</code>, <code>payload_type</code>"},{"location":"migration/#validation","title":"Validation","text":"<p>Use CLI to validate messages:</p> <pre><code># Export schemas for reference\nasap export-schemas --output-dir ./schemas\n\n# List available schemas\nasap list-schemas\n\n# Show specific schema\nasap show-schema Envelope\n</code></pre>"},{"location":"migration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Transport - HTTP/JSON-RPC details</li> <li>Security - Authentication setup</li> <li>State Management - Snapshots and lifecycle</li> <li>API Reference - Complete API docs</li> </ul>"},{"location":"observability/","title":"Observability","text":"<p>This guide describes structured logging and trace context in ASAP.</p>"},{"location":"observability/#structured-logging","title":"Structured Logging","text":"<p>ASAP uses <code>structlog</code> to emit structured logs with consistent fields for service name, log level, and timestamps.</p>"},{"location":"observability/#configuration","title":"Configuration","text":"<p>Configure logging once at startup:</p> <pre><code>from asap.observability import configure_logging\n\nconfigure_logging(log_format=\"json\", log_level=\"INFO\")\n</code></pre> <p>Environment variables:</p> <ul> <li><code>ASAP_LOG_FORMAT</code>: <code>json</code> or <code>console</code></li> <li><code>ASAP_LOG_LEVEL</code>: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code></li> <li><code>ASAP_SERVICE_NAME</code>: service name for log context</li> </ul>"},{"location":"observability/#trace-and-correlation-ids","title":"Trace and Correlation IDs","text":"<p>Include trace context in logs by binding context variables:</p> <pre><code>from asap.observability import get_logger\nfrom asap.observability.logging import bind_context, clear_context\n\nlogger = get_logger(__name__)\n\nbind_context(trace_id=\"trace_123\", correlation_id=\"corr_456\")\nlogger.info(\"asap.request.received\", envelope_id=\"env_123\", payload_type=\"task.request\")\n\nclear_context()\n</code></pre>"},{"location":"observability/#recommended-fields","title":"Recommended fields","text":"<ul> <li><code>trace_id</code>: trace a request across services</li> <li><code>correlation_id</code>: correlate request/response pairs</li> <li><code>envelope_id</code>: identify the ASAP envelope</li> <li><code>payload_type</code>: identify the message type</li> </ul>"},{"location":"observability/#logging-in-transport","title":"Logging in Transport","text":"<p>The transport layer emits structured logs around request handling, handler dispatch, and client send/response events. Use these logs to troubleshoot end-to-end flows and latency.</p>"},{"location":"observability/#opentelemetry-tracing","title":"OpenTelemetry Tracing","text":"<p>ASAP supports distributed tracing via OpenTelemetry. When the server starts, tracing is configured automatically; FastAPI and httpx are instrumented so HTTP requests and handler execution appear as spans. Trace context is propagated in envelope <code>trace_id</code> and <code>extensions.trace_id</code> / <code>extensions.span_id</code> (W3C Trace Context).</p>"},{"location":"observability/#zero-config-environment-variables","title":"Zero-config (environment variables)","text":"Variable Description Default <code>OTEL_SERVICE_NAME</code> Service name in traces <code>asap-server</code> <code>OTEL_TRACES_EXPORTER</code> <code>none</code>, <code>otlp</code>, or <code>console</code> <code>none</code> <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> OTLP endpoint (e.g. Jaeger) \u2014 <ul> <li><code>OTEL_TRACES_EXPORTER=none</code>: Tracing is configured but no spans are   exported (default; no collector required).</li> <li><code>OTEL_TRACES_EXPORTER=otlp</code>: Export spans to an OTLP endpoint. Set   <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> (e.g. <code>http://localhost:4317</code> for Jaeger).</li> <li><code>OTEL_TRACES_EXPORTER=console</code>: Log spans to stdout (debugging).</li> </ul>"},{"location":"observability/#testing-with-jaeger","title":"Testing with Jaeger","text":"<ol> <li>Run Jaeger (e.g. Docker: <code>docker run -d -p 16686:16686 -p 4317:4317 jaegertracing/all-in-one:1.53</code>).</li> <li>Start the ASAP server with:</li> <li><code>OTEL_TRACES_EXPORTER=otlp</code></li> <li><code>OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317</code></li> <li>Send requests to <code>/asap</code>; open Jaeger UI at http://localhost:16686 and    select the service name (<code>OTEL_SERVICE_NAME</code> or manifest id).</li> </ol> <p>An integration test verifies end-to-end: <code>pytest tests/observability/test_jaeger_tracing.py -v</code>. It starts Jaeger in Docker, runs the ASAP server with OTLP, sends a request, and asserts traces appear in Jaeger (skips if Docker is not available).</p>"},{"location":"observability/#custom-spans","title":"Custom spans","text":"<p>Handler execution and state machine transitions are recorded as spans with attributes (<code>asap.payload_type</code>, <code>asap.agent.urn</code>, <code>asap.envelope.id</code>, <code>asap.state.from</code>, <code>asap.state.to</code>, <code>asap.task.id</code>). Use <code>asap.observability.tracing.get_tracer()</code> to add custom spans in your code.</p>"},{"location":"observability/#metrics-and-grafana","title":"Metrics and Grafana","text":"<p>Metrics are exposed at <code>/asap/metrics</code> in Prometheus text format. Pre-built Grafana dashboards are in <code>src/asap/observability/dashboards/</code>:</p> <ul> <li>ASAP RED (<code>asap-red.json</code>): Request rate, error rate, latency (p95, p99).</li> <li>ASAP Detailed (<code>asap-detailed.json</code>): Handler executions, state machine   transitions, circuit breaker status.</li> </ul>"},{"location":"observability/#loading-the-dashboards","title":"Loading the dashboards","text":"<ol> <li>Configure a Prometheus datasource in Grafana that scrapes your ASAP server    (e.g. <code>http://&lt;host&gt;:&lt;port&gt;/asap/metrics</code>).</li> <li>Import: Dashboards \u2192 Import \u2192 Upload the JSON file, or use provisioning (see    below).</li> <li>Set the datasource to your Prometheus instance (default UID <code>prometheus</code> if    you added it with that name).</li> </ol>"},{"location":"observability/#optional-run-prometheus-grafana-locally","title":"Optional: run Prometheus + Grafana locally","text":"<p>From the repo root, run the observability stack (Prometheus + Grafana) and provision the ASAP dashboards:</p> <pre><code>cd scripts/observability-stack &amp;&amp; docker compose up -d\n</code></pre> <p>Then start your ASAP server (so Prometheus can scrape it), open Grafana at http://localhost:3000 (default login <code>admin</code> / <code>admin</code>), and open the ASAP RED or ASAP Detailed dashboard. Dashboards are auto-loaded from <code>src/asap/observability/dashboards/</code>.</p>"},{"location":"security/","title":"Security Guide","text":"<p>Comprehensive security guidance for implementing and operating ASAP protocol agents.</p>"},{"location":"security/#quick-reference","title":"Quick Reference","text":""},{"location":"security/#validation-constants","title":"Validation Constants","text":"Constant Default Value Description <code>MAX_ENVELOPE_AGE_SECONDS</code> 300 (5 minutes) Maximum age of envelope before rejection <code>MAX_FUTURE_TOLERANCE_SECONDS</code> 30 seconds Maximum future timestamp offset allowed <code>MAX_REQUEST_SIZE</code> 10,485,760 bytes (10MB) Maximum request body size Default Rate Limit 10/second;100/minute Burst (10/s) + sustained (100/min) per sender Nonce TTL 600 seconds (10 minutes) Time-to-live for nonce tracking (2x envelope age)"},{"location":"security/#security-features","title":"Security Features","text":"Feature Status Configuration Timestamp Validation Always Enabled Automatic Nonce Validation Optional <code>require_nonce=True</code> in <code>create_app()</code> HTTPS Enforcement Client-side (default) <code>require_https=True</code> (default) Rate Limiting Enabled (default) <code>rate_limit</code> parameter or <code>ASAP_RATE_LIMIT</code> env var Request Size Limits Enabled (default) <code>max_request_size</code> parameter or <code>ASAP_MAX_REQUEST_SIZE</code> env var"},{"location":"security/#overview","title":"Overview","text":"<p>The ASAP protocol is designed with security as a foundational concern. For v1.1 OAuth2, identity binding (Custom Claims), and trust limitations, see v1.1 Security Model (ADR-17).</p> <p>This guide covers:</p> <ul> <li>Authentication: How agents verify identity</li> <li>Request Signing: Cryptographic integrity for messages</li> <li>TLS/HTTPS: Transport layer security requirements</li> <li>Rate Limiting: Per-sender request rate controls</li> <li>Request Size Limits: Protection against oversized payloads</li> <li>Threat Model: Common attack vectors and mitigations</li> </ul>"},{"location":"security/#authentication","title":"Authentication","text":"<p>ASAP supports multiple authentication schemes configured via the agent's manifest. The <code>AuthScheme</code> model defines the supported methods.</p>"},{"location":"security/#supported-authentication-schemes","title":"Supported Authentication Schemes","text":"<p>The ASAP protocol validates authentication schemes at manifest creation time to ensure only supported schemes are used. The validation is enforced by the <code>Manifest</code> model and raises <code>UnsupportedAuthSchemeError</code> for invalid schemes.</p> Scheme Description Use Case Status <code>bearer</code> Bearer token authentication (RFC 6750) API keys, JWT tokens \u2705 Supported <code>basic</code> HTTP Basic authentication (RFC 7617) Simple username/password \u2705 Supported <code>oauth2</code> OAuth 2.0 with authorization code or client credentials Enterprise integrations \u2705 Supported (v1.1) <code>hmac</code> HMAC-based authentication Message signing and verification \ud83d\udd1c Planned <code>mtls</code> Mutual TLS with client certificates High-security environments \ud83d\udd1c Planned <code>none</code> No authentication (development only) Local testing \u26a0\ufe0f Development only"},{"location":"security/#manifest-configuration","title":"Manifest Configuration","text":"<p>Authentication is declared in the agent manifest's <code>auth</code> field. The ASAP protocol automatically validates that all specified schemes are supported:</p> <pre><code>from asap.models.entities import AuthScheme, Manifest\nfrom asap.errors import UnsupportedAuthSchemeError\nfrom asap.models.constants import SUPPORTED_AUTH_SCHEMES\n\n# Valid: Bearer token authentication\nauth = AuthScheme(schemes=[\"bearer\"])\nmanifest = Manifest(\n    id=\"urn:asap:agent:secure-agent\",\n    name=\"Secure Agent\",\n    version=\"1.0.0\",\n    description=\"Agent with Bearer token authentication\",\n    capabilities=capability,\n    endpoints=endpoint,\n    auth=auth\n)\n\n# Valid: Multiple supported schemes\nauth = AuthScheme(schemes=[\"bearer\", \"basic\"])\nmanifest = Manifest(\n    id=\"urn:asap:agent:multi-auth-agent\",\n    name=\"Multi-Auth Agent\",\n    version=\"1.0.0\",\n    description=\"Agent with multiple authentication methods\",\n    capabilities=capability,\n    endpoints=endpoint,\n    auth=auth\n)\n\n# Invalid: Unsupported scheme raises UnsupportedAuthSchemeError\ntry:\n    auth = AuthScheme(schemes=[\"oauth2\"])  # v1.1: use OAuth2Config with create_app()\n    manifest = Manifest(\n        id=\"urn:asap:agent:invalid-agent\",\n        name=\"Invalid Agent\",\n        version=\"1.0.0\",\n        description=\"Agent with unsupported scheme\",\n        capabilities=capability,\n        endpoints=endpoint,\n        auth=auth\n    )\nexcept UnsupportedAuthSchemeError as e:\n    print(f\"Unsupported scheme: {e.scheme}\")\n    print(f\"Supported schemes: {e.supported_schemes}\")\n</code></pre>"},{"location":"security/#scheme-validation","title":"Scheme Validation","text":"<p>The validation occurs automatically when creating a <code>Manifest</code> instance:</p> <ul> <li>Supported Schemes: <code>bearer</code>, <code>basic</code> (validated against <code>SUPPORTED_AUTH_SCHEMES</code>)</li> <li>Validation Error: Raises <code>UnsupportedAuthSchemeError</code> with code <code>asap:auth/unsupported_scheme</code></li> <li>Error Details: Includes the unsupported scheme and list of supported schemes</li> </ul>"},{"location":"security/#checking-supported-schemes","title":"Checking Supported Schemes","text":"<p>You can check which schemes are currently supported:</p> <pre><code>from asap.models.constants import SUPPORTED_AUTH_SCHEMES\n\nprint(f\"Supported schemes: {SUPPORTED_AUTH_SCHEMES}\")\n# Output: frozenset({'bearer', 'basic'})\n</code></pre>"},{"location":"security/#required-headers","title":"Required Headers","text":"<p>When making requests to authenticated agents, include the appropriate headers:</p>"},{"location":"security/#bearer-token","title":"Bearer Token","text":"<p>Bearer token authentication is the most common method for API authentication. Include the token in the <code>Authorization</code> header:</p> <pre><code>POST /asap HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Bearer &lt;token&gt;\n</code></pre> <p>Python Example:</p> <pre><code>from asap.transport.client import ASAPClient\n\nasync with ASAPClient(\"https://api.example.com\") as client:\n    # Add Bearer token to client headers\n    client._client.headers[\"Authorization\"] = f\"Bearer {my_token}\"\n    response = await client.send(envelope)\n</code></pre>"},{"location":"security/#basic-authentication","title":"Basic Authentication","text":"<p>HTTP Basic authentication uses username and password encoded in base64:</p> <pre><code>POST /asap HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Basic &lt;base64-encoded-credentials&gt;\n</code></pre> <p>Python Example:</p> <pre><code>import base64\nfrom asap.transport.client import ASAPClient\n\n# Encode credentials\ncredentials = base64.b64encode(f\"{username}:{password}\".encode()).decode()\n\nasync with ASAPClient(\"https://api.example.com\") as client:\n    # Add Basic auth header\n    client._client.headers[\"Authorization\"] = f\"Basic {credentials}\"\n    response = await client.send(envelope)\n</code></pre>"},{"location":"security/#oauth-20-v11","title":"OAuth 2.0 (v1.1+)","text":"<p>OAuth 2.0 is supported in v1.1 with JWKS validation, OIDC discovery, and Custom Claims identity binding. See v1.1 Security Model (ADR-17) for setup, trust limitations, and provider guides (Auth0, Keycloak, Azure AD).</p> <ul> <li>Authorization code flow (client-side)</li> <li>Client credentials flow (<code>OAuth2ClientCredentials</code>)</li> <li>Token validation via JWKS (OIDC discovery)</li> <li>Custom Claims or allowlist for agent identity binding</li> </ul> <pre><code>POST /asap HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre>"},{"location":"security/#implementing-authentication","title":"Implementing Authentication","text":"<p>The ASAP protocol provides built-in authentication middleware for securing agent communication. Authentication is optional and configured via the manifest.</p>"},{"location":"security/#quick-start-with-bearer-tokens","title":"Quick Start with Bearer Tokens","text":"<pre><code>from asap.models.entities import Manifest, AuthScheme, Capability, Endpoint, Skill\nfrom asap.transport.server import create_app\n\n# 1. Configure authentication in manifest\nmanifest = Manifest(\n    id=\"urn:asap:agent:secure-agent\",\n    name=\"Secure Agent\",\n    version=\"1.0.0\",\n    description=\"Agent with authentication\",\n    capabilities=Capability(\n        asap_version=\"0.1\",\n        skills=[Skill(id=\"secure-task\", description=\"Secure task processing\")],\n        state_persistence=False,\n    ),\n    endpoints=Endpoint(asap=\"https://api.example.com/asap\"),\n    auth=AuthScheme(schemes=[\"bearer\"]),  # Enable Bearer token authentication\n)\n\n# 2. Implement token validation function\ndef validate_bearer_token(token: str) -&gt; str | None:\n    \"\"\"Validate Bearer token and return agent ID if valid.\n\n    Args:\n        token: The Bearer token from Authorization header\n\n    Returns:\n        Agent ID (URN) if token is valid, None otherwise\n    \"\"\"\n    # Example: Validate against database\n    user = database.verify_token(token)\n    if user and user.is_active:\n        return user.agent_id  # e.g., \"urn:asap:agent:client-123\"\n\n    return None\n\n# 3. Create app with authentication\napp = create_app(manifest, token_validator=validate_bearer_token)\n\n# Run with uvicorn:\n# uvicorn myapp:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"security/#how-it-works","title":"How It Works","text":"<ol> <li>Manifest Declaration: Set <code>auth=AuthScheme(schemes=[\"bearer\"])</code> in manifest</li> <li>Token Validation: Provide a <code>token_validator</code> function to <code>create_app()</code></li> <li>Automatic Verification: Middleware validates every request:</li> <li>Checks for <code>Authorization: Bearer &lt;token&gt;</code> header</li> <li>Calls your <code>token_validator</code> with the token</li> <li>Returns HTTP 401 if token is invalid or missing</li> <li>Verifies <code>envelope.sender</code> matches authenticated identity</li> <li>Returns HTTP 403 if sender is spoofed</li> </ol>"},{"location":"security/#custom-token-validation","title":"Custom Token Validation","text":"<p>Integrate with any authentication system (JWT, OAuth2, database, etc.):</p> <pre><code>import jwt\nfrom datetime import datetime\n\ndef validate_jwt_token(token: str) -&gt; str | None:\n    \"\"\"Validate JWT token and extract agent ID.\"\"\"\n    try:\n        # Decode and verify JWT\n        payload = jwt.decode(\n            token,\n            key=PUBLIC_KEY,\n            algorithms=[\"RS256\"],\n            options={\"verify_exp\": True}\n        )\n\n        # Verify custom claims\n        if payload.get(\"iss\") != \"https://auth.example.com\":\n            return None\n\n        # Extract agent ID\n        return payload.get(\"sub\")  # e.g., \"urn:asap:agent:user-456\"\n\n    except jwt.InvalidTokenError:\n        return None\n\napp = create_app(manifest, token_validator=validate_jwt_token)\n</code></pre>"},{"location":"security/#oauth2-integration","title":"OAuth2 Integration","text":"<p>For OAuth2 workflows, implement token introspection:</p> <pre><code>import httpx\n\nasync def validate_oauth2_token(token: str) -&gt; str | None:\n    \"\"\"Validate OAuth2 token via introspection endpoint.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            \"https://auth.example.com/oauth/introspect\",\n            data={\"token\": token},\n            auth=(CLIENT_ID, CLIENT_SECRET)\n        )\n\n        if response.status_code != 200:\n            return None\n\n        data = response.json()\n        if not data.get(\"active\"):\n            return None\n\n        # Map OAuth2 subject to agent URN\n        return f\"urn:asap:agent:{data['sub']}\"\n\napp = create_app(manifest, token_validator=validate_oauth2_token)\n</code></pre>"},{"location":"security/#client-side-authentication","title":"Client-Side Authentication","text":"<p>When calling authenticated endpoints, include the Bearer token:</p> <pre><code>from asap.transport.client import ASAPClient\nfrom asap.models.envelope import Envelope\nfrom asap.models.payloads import TaskRequest\n\nasync with ASAPClient(\"https://api.example.com\") as client:\n    envelope = Envelope(\n        sender=\"urn:asap:agent:client-123\",\n        recipient=\"urn:asap:agent:secure-agent\",\n        payload_type=\"task.request\",\n        payload=TaskRequest(\n            conversation_id=\"conv-1\",\n            skill_id=\"secure-task\",\n            input={\"data\": \"sensitive-info\"},\n        ),\n    )\n\n    # Add authentication header to httpx client\n    client._client.headers[\"Authorization\"] = f\"Bearer {my_token}\"\n\n    response = await client.send(envelope)\n</code></pre>"},{"location":"security/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Always use HTTPS in production (client enforces this by default)</li> <li>Rotate tokens regularly to limit exposure window</li> <li>Use short-lived tokens (15-60 minutes) with refresh mechanism</li> <li>Validate sender identity (middleware does this automatically)</li> <li>Log authentication failures for security monitoring</li> <li>Rate limit authentication attempts to prevent brute force</li> </ol>"},{"location":"security/#disabling-authentication-development-only","title":"Disabling Authentication (Development Only)","text":"<pre><code># Manifest without auth - authentication is skipped\nmanifest = Manifest(\n    # ... other fields ...\n    auth=None,  # No authentication required\n)\n\napp = create_app(manifest)  # No token_validator needed\n</code></pre> <p>\u26a0\ufe0f Warning: Only disable authentication for local development. Production deployments must use authentication.</p>"},{"location":"security/#request-signing","title":"Request Signing","text":"<p>Request signing provides cryptographic proof of message origin and integrity, preventing tampering and ensuring non-repudiation.</p>"},{"location":"security/#signing-workflow","title":"Signing Workflow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Sender    \u2502     \u2502    Message      \u2502     \u2502  Recipient  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                    \u2502                      \u2502\n       \u2502  1. Create envelope                       \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                               \u2502\n       \u2502                    \u2502                      \u2502\n       \u2502  2. Sign envelope with private key        \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                               \u2502\n       \u2502                    \u2502                      \u2502\n       \u2502  3. Add signature to extensions           \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                               \u2502\n       \u2502                    \u2502                      \u2502\n       \u2502           4. Send signed envelope         \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n       \u2502                    \u2502                      \u2502\n       \u2502           5. Verify signature with public key\n       \u2502                    \u2502                      \u25c4\u2500\n       \u2502           6. Process if valid             \u2502\n       \u2502                    \u2502                      \u25c4\u2500\n</code></pre>"},{"location":"security/#signature-format","title":"Signature Format","text":"<p>Signatures are included in the envelope's <code>extensions</code> field:</p> <pre><code>from datetime import datetime, timezone\nfrom asap.models.envelope import Envelope\n\nenvelope = Envelope(\n    asap_version=\"0.1\",\n    sender=\"urn:asap:agent:sender\",\n    recipient=\"urn:asap:agent:recipient\",\n    payload_type=\"task.request\",\n    payload={\"skill_id\": \"research\", \"input\": {}},\n    extensions={\n        \"signature\": {\n            \"algorithm\": \"Ed25519\",\n            \"key_id\": \"key-2024-01\",\n            \"value\": \"&lt;base64-encoded-signature&gt;\",\n            \"signed_at\": datetime.now(timezone.utc).isoformat()\n        }\n    }\n)\n</code></pre>"},{"location":"security/#signing-implementation","title":"Signing Implementation","text":"<pre><code>import base64\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey\n\ndef sign_envelope(envelope: Envelope, private_key: Ed25519PrivateKey) -&gt; Envelope:\n    \"\"\"Sign an envelope and add signature to extensions.\"\"\"\n    # Canonical JSON representation (excluding signature field)\n    canonical = envelope.model_dump(mode=\"json\", exclude={\"extensions\"})\n    message = json.dumps(canonical, sort_keys=True).encode()\n\n    # Sign the message\n    signature = private_key.sign(message)\n    signature_b64 = base64.b64encode(signature).decode()\n\n    # Add signature to extensions\n    extensions = envelope.extensions or {}\n    extensions[\"signature\"] = {\n        \"algorithm\": \"Ed25519\",\n        \"key_id\": \"key-2024-01\",\n        \"value\": signature_b64,\n        \"signed_at\": datetime.now(timezone.utc).isoformat()\n    }\n\n    return envelope.model_copy(update={\"extensions\": extensions})\n</code></pre>"},{"location":"security/#verification-steps","title":"Verification Steps","text":"<p>Recipients verify signatures before processing:</p> <pre><code>from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey\nfrom cryptography.exceptions import InvalidSignature\n\ndef verify_envelope(envelope: Envelope, public_key: Ed25519PublicKey) -&gt; bool:\n    \"\"\"Verify envelope signature.\"\"\"\n    if not envelope.extensions or \"signature\" not in envelope.extensions:\n        return False\n\n    sig_data = envelope.extensions[\"signature\"]\n    signature = base64.b64decode(sig_data[\"value\"])\n\n    # Reconstruct canonical message\n    canonical = envelope.model_dump(mode=\"json\", exclude={\"extensions\"})\n    message = json.dumps(canonical, sort_keys=True).encode()\n\n    try:\n        public_key.verify(signature, message)\n        return True\n    except InvalidSignature:\n        return False\n</code></pre>"},{"location":"security/#key-distribution","title":"Key Distribution","text":"<p>Public keys for signature verification should be distributed via:</p> <ol> <li>Manifest: Include public key in the manifest's <code>signature</code> field</li> <li>Well-Known Endpoint: <code>/.well-known/asap/keys.json</code></li> <li>Key Server: Centralized key management system</li> </ol>"},{"location":"security/#tlshttps-requirements","title":"TLS/HTTPS Requirements","text":"<p>All production ASAP deployments must use TLS 1.2 or higher.</p>"},{"location":"security/#minimum-requirements","title":"Minimum Requirements","text":"Requirement Value TLS Version 1.2+ (1.3 recommended) Certificate Valid, not self-signed Cipher Suites AEAD ciphers (AES-GCM, ChaCha20-Poly1305) HSTS Enabled with max-age \u2265 31536000"},{"location":"security/#certificate-validation","title":"Certificate Validation","text":"<p>The ASAP client validates server certificates by default:</p> <pre><code>from asap.transport.client import ASAPClient\n\n# Production: Certificate validation enabled (default)\nasync with ASAPClient(base_url=\"https://agent.example.com\") as client:\n    response = await client.send(envelope)\n\n# Development only: Disable certificate validation (NOT FOR PRODUCTION)\nasync with ASAPClient(\n    base_url=\"https://localhost:8443\",\n    verify_ssl=False  # DANGER: Only for local development\n) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"security/#mutual-tls-mtls","title":"Mutual TLS (mTLS)","text":"<p>For high-security deployments, configure mutual TLS:</p> <pre><code>import httpx\n\n# Client certificate configuration\nclient = httpx.AsyncClient(\n    cert=(\"/path/to/client.crt\", \"/path/to/client.key\"),\n    verify=\"/path/to/ca-bundle.crt\"\n)\n</code></pre>"},{"location":"security/#rate-limiting","title":"Rate Limiting","text":"<p>Rate limiting protects ASAP agents from denial-of-service (DoS) attacks by limiting the number of requests per sender within a time window. The ASAP protocol server includes built-in rate limiting using per-sender tracking.</p>"},{"location":"security/#default-configuration","title":"Default Configuration","text":"<p>The default rate limit is 100 requests per minute per sender. This can be configured via:</p> <ul> <li>Environment variable: <code>ASAP_RATE_LIMIT</code> (e.g., <code>\"200/minute\"</code>, <code>\"10/second\"</code>)</li> <li>Application parameter: <code>rate_limit</code> parameter in <code>create_app()</code></li> </ul>"},{"location":"security/#configuration","title":"Configuration","text":"<pre><code>from asap.transport.server import create_app\nfrom asap.models.entities import Manifest\n\n# Configure via environment variable\n# export ASAP_RATE_LIMIT=\"200/minute\"\n\n# Or configure programmatically\napp = create_app(\n    manifest,\n    rate_limit=\"200/minute\"  # 200 requests per minute per sender\n)\n</code></pre>"},{"location":"security/#rate-limit-format","title":"Rate Limit Format","text":"<p>The rate limit string follows the format: <code>&lt;number&gt;/&lt;unit&gt;</code> where unit can be: - <code>second</code> or <code>sec</code> - <code>minute</code> or <code>min</code> - <code>hour</code> or <code>hr</code> - <code>day</code></p> <p>Examples: - <code>\"10/second;100/minute\"</code> - Burst (10/s) + sustained (100/min) - default - <code>\"100/minute\"</code> - 100 requests per minute (no burst allowance) - <code>\"10/second\"</code> - 10 requests per second - <code>\"1000/hour\"</code> - 1000 requests per hour</p>"},{"location":"security/#how-it-works_1","title":"How It Works","text":"<ol> <li> <p>Sender Identification: The rate limiter extracts the sender from the ASAP envelope (<code>envelope.sender</code>). If the envelope is not yet parsed, it falls back to the client IP address.</p> </li> <li> <p>Per-Sender Tracking: Each sender (agent URN or IP) has an independent rate limit counter.</p> </li> <li> <p>Window-Based Limiting: Uses a sliding window to track requests within the time period.</p> </li> <li> <p>Automatic Rejection: When the limit is exceeded, the server returns HTTP 429 (Too Many Requests) with a JSON-RPC error response.</p> </li> </ol>"},{"location":"security/#response-format","title":"Response Format","text":"<p>When rate limit is exceeded, the server returns:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"request-id\",\n  \"error\": {\n    \"code\": -32000,\n    \"message\": \"Rate limit exceeded\",\n    \"data\": {\n      \"error\": \"Rate limit exceeded: 100 per 1 minute\",\n      \"retry_after\": 45\n    }\n  }\n}\n</code></pre> <p>The response includes: - HTTP Status: 429 (Too Many Requests) - Retry-After Header: Number of seconds until the rate limit resets - JSON-RPC Error: Standard error format with rate limit details</p>"},{"location":"security/#production-recommendations","title":"Production Recommendations","text":"<ol> <li>Adjust Limits Based on Workload: </li> <li>High-throughput agents: <code>200-500/minute</code></li> <li>Interactive agents: <code>50-100/minute</code></li> <li> <p>Resource-intensive agents: <code>10-50/minute</code></p> </li> <li> <p>Use Distributed Storage: For multi-instance deployments, configure slowapi to use Redis:    ```python    from slowapi import Limiter    from slowapi.util import get_remote_address    import redis</p> </li> </ol> <p>redis_client = redis.Redis(host='localhost', port=6379, db=0)    limiter = Limiter(        key_func=_get_sender_from_envelope,        storage_uri=\"redis://localhost:6379\"    )    ```</p> <ol> <li> <p>Monitor Rate Limit Hits: Track <code>asap_rate_limit_exceeded_total</code> metric to identify potential attacks or legitimate traffic spikes.</p> </li> <li> <p>Implement Graduated Responses: Consider implementing different limits for different sender types (trusted vs. untrusted).</p> </li> </ol>"},{"location":"security/#example-custom-rate-limit-configuration","title":"Example: Custom Rate Limit Configuration","text":"<pre><code>import os\nfrom asap.transport.server import create_app\n\n# Read from environment or use default (burst + sustained)\nrate_limit = os.getenv(\"ASAP_RATE_LIMIT\", \"10/second;100/minute\")\n\napp = create_app(\n    manifest,\n    rate_limit=rate_limit\n)\n</code></pre>"},{"location":"security/#testing-rate-limits","title":"Testing Rate Limits","text":"<p>To test rate limiting behavior:</p> <pre><code>import asyncio\nimport httpx\n\nasync def test_rate_limit():\n    \"\"\"Test that rate limiting rejects excessive requests.\"\"\"\n    async with httpx.AsyncClient() as client:\n        # Send 101 requests rapidly\n        for i in range(101):\n            response = await client.post(\n                \"http://localhost:8000/asap\",\n                json={\n                    \"jsonrpc\": \"2.0\",\n                    \"method\": \"asap.send\",\n                    \"params\": {\n                        \"envelope\": {\n                            \"asap_version\": \"0.1\",\n                            \"sender\": \"urn:asap:agent:test-client\",\n                            \"recipient\": \"urn:asap:agent:server\",\n                            \"payload_type\": \"task.request\",\n                            \"payload\": {\"test\": \"data\"}\n                        }\n                    },\n                    \"id\": f\"test-{i}\"\n                }\n            )\n\n            if i &lt; 100:\n                assert response.status_code == 200\n            else:\n                assert response.status_code == 429\n                assert \"Rate limit exceeded\" in response.json()[\"error\"][\"message\"]\n\nasyncio.run(test_rate_limit())\n</code></pre>"},{"location":"security/#request-size-limits","title":"Request Size Limits","text":"<p>Request size limits protect agents from memory exhaustion attacks by rejecting oversized payloads before they are fully processed. The ASAP protocol server enforces a maximum request size to prevent DoS attacks.</p>"},{"location":"security/#default-configuration_1","title":"Default Configuration","text":"<p>The default maximum request size is 10MB (10,485,760 bytes). This can be configured via:</p> <ul> <li>Environment variable: <code>ASAP_MAX_REQUEST_SIZE</code> (in bytes, e.g., <code>\"5242880\"</code> for 5MB)</li> <li>Application parameter: <code>max_request_size</code> parameter in <code>create_app()</code></li> </ul>"},{"location":"security/#configuration_1","title":"Configuration","text":"<pre><code>from asap.transport.server import create_app\nfrom asap.models.constants import MAX_REQUEST_SIZE\n\n# Use default (10MB)\napp = create_app(manifest)\n\n# Configure via environment variable\n# export ASAP_MAX_REQUEST_SIZE=\"5242880\"  # 5MB\n\n# Or configure programmatically\napp = create_app(\n    manifest,\n    max_request_size=5 * 1024 * 1024  # 5MB in bytes\n)\n</code></pre>"},{"location":"security/#how-it-works_2","title":"How It Works","text":"<p>The server validates request size in two stages:</p> <ol> <li> <p>Content-Length Header Check: If the <code>Content-Length</code> header is present, the server checks it before reading the request body. This allows early rejection without consuming bandwidth.</p> </li> <li> <p>Actual Body Size Check: After reading the request body, the server validates the actual size. This catches cases where the <code>Content-Length</code> header is missing or incorrect.</p> </li> </ol>"},{"location":"security/#error-response","title":"Error Response","text":"<p>When a request exceeds the size limit, the server returns:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"request-id\",\n  \"error\": {\n    \"code\": -32000,\n    \"message\": \"Request too large\",\n    \"data\": {\n      \"error\": \"Request size (15728640 bytes) exceeds maximum (10485760 bytes)\"\n    }\n  }\n}\n</code></pre> <p>The response includes: - HTTP Status: 413 (Payload Too Large) - JSON-RPC Error: Standard error format with size details</p>"},{"location":"security/#rationale","title":"Rationale","text":"<p>The 10MB default limit balances: - Functionality: Allows large payloads for legitimate use cases (file uploads, batch operations) - Security: Prevents memory exhaustion from malicious oversized requests - Performance: Enables early rejection before full request processing</p>"},{"location":"security/#production-recommendations_1","title":"Production Recommendations","text":"<ol> <li>Adjust Based on Use Case:</li> <li>File processing agents: <code>50-100MB</code></li> <li>API gateway agents: <code>1-5MB</code></li> <li> <p>Real-time agents: <code>1MB or less</code></p> </li> <li> <p>Configure at Multiple Layers:</p> </li> <li>ASGI Server: Set <code>--limit-max-requests</code> in uvicorn/gunicorn</li> <li>Reverse Proxy: Configure nginx/traefik with <code>client_max_body_size</code></li> <li> <p>Application: Use <code>max_request_size</code> parameter</p> </li> <li> <p>Monitor Size Violations: Track rejected requests to identify potential attacks or legitimate needs for larger limits.</p> </li> </ol>"},{"location":"security/#example-multi-layer-size-protection","title":"Example: Multi-Layer Size Protection","text":"<pre><code># Application level (ASAP server)\napp = create_app(\n    manifest,\n    max_request_size=10 * 1024 * 1024  # 10MB\n)\n\n# Run with uvicorn size limit\n# uvicorn app:app --limit-max-requests 10485760  # 10MB\n</code></pre> <pre><code># nginx configuration\nhttp {\n    client_max_body_size 10M;\n\n    server {\n        location /asap {\n            proxy_pass http://localhost:8000;\n        }\n    }\n}\n</code></pre>"},{"location":"security/#testing-size-limits","title":"Testing Size Limits","text":"<p>To test size limit enforcement:</p> <pre><code>import httpx\n\ndef test_size_limit():\n    \"\"\"Test that oversized requests are rejected.\"\"\"\n    # Create a payload that exceeds 10MB\n    large_payload = {\"data\": \"x\" * (11 * 1024 * 1024)}  # 11MB\n\n    envelope = {\n        \"asap_version\": \"0.1\",\n        \"sender\": \"urn:asap:agent:client\",\n        \"recipient\": \"urn:asap:agent:server\",\n        \"payload_type\": \"task.request\",\n        \"payload\": large_payload\n    }\n\n    rpc_request = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": \"asap.send\",\n        \"params\": {\"envelope\": envelope},\n        \"id\": \"test-1\"\n    }\n\n    # Serialize to JSON\n    import json\n    request_json = json.dumps(rpc_request)\n    request_bytes = request_json.encode(\"utf-8\")\n\n    # Send with Content-Length header\n    response = httpx.post(\n        \"http://localhost:8000/asap\",\n        content=request_bytes,\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Content-Length\": str(len(request_bytes))\n        }\n    )\n\n    assert response.status_code == 413\n    assert \"exceeds maximum\" in response.json()[\"error\"][\"data\"][\"error\"]\n</code></pre>"},{"location":"security/#handler-security","title":"Handler Security","text":"<p>Handlers process incoming ASAP envelopes and must validate all inputs before use. Unvalidated payloads, URIs, or envelope fields can lead to path traversal, injection, or information disclosure.</p>"},{"location":"security/#input-validation-requirements","title":"Input Validation Requirements","text":"<ol> <li>Validate payload structure: Parse payloads with Pydantic models (e.g. <code>TaskRequest</code>) so required fields and types are enforced.</li> <li>Validate URIs in parts: Reject path traversal (<code>../</code>) and suspicious <code>file://</code> URIs in <code>FilePart</code> and similar fields. Use the built-in <code>FilePart</code> URI validator.</li> <li>Validate handler signature: Handlers must accept <code>(envelope: Envelope, manifest: Manifest)</code> and return <code>Envelope</code> (sync) or <code>Awaitable[Envelope]</code> (async). Use <code>validate_handler()</code> when registering custom handlers.</li> <li>Do not trust envelope payload as raw dict: Always parse into typed models and handle <code>ValidationError</code>.</li> <li>Sanitize data before logging: Use <code>sanitize_for_logging()</code> for envelope or payload data in log messages.</li> </ol>"},{"location":"security/#handler-security-review-checklist","title":"Handler Security Review Checklist","text":"<p>Before deploying a handler, verify:</p> <ul> <li>[ ] Payload is parsed with a Pydantic model (e.g. <code>TaskRequest(**envelope.payload)</code> inside try/except).</li> <li>[ ] All user-controlled strings (URIs, IDs, file paths) are validated or allowlisted.</li> <li>[ ] No path traversal possible: <code>FilePart</code> URIs use the built-in validator; custom file paths are normalized and checked against a base directory.</li> <li>[ ] Handler signature is <code>(envelope: Envelope, manifest: Manifest)</code> and return type is <code>Envelope</code> or <code>Awaitable[Envelope]</code>.</li> <li>[ ] Errors are logged server-side with full context; responses to clients are generic in production (no stack traces or internal details).</li> <li>[ ] No secrets or PII are logged; use <code>sanitize_for_logging()</code> when logging payloads or envelope content.</li> </ul>"},{"location":"security/#secure-vs-insecure-handlers","title":"Secure vs Insecure Handlers","text":"<p>Insecure: Raw payload, no URI validation, secrets in logs.</p> <pre><code>def bad_handler(envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n    # BAD: No payload validation\n    uri = envelope.payload.get(\"file_uri\")  # type: ignore[union-attr]\n    # BAD: Path traversal possible\n    with open(uri.replace(\"file://\", \"\")) as f:\n        data = f.read()\n    # BAD: Logging raw payload (may contain secrets)\n    logger.info(\"request\", payload=envelope.payload)\n    return build_response(envelope, data)\n</code></pre> <p>Secure: Typed payload, validated URIs, sanitized logging.</p> <pre><code>from asap.models.payloads import TaskRequest\nfrom asap.models.parts import FilePart\nfrom asap.observability import sanitize_for_logging\n\ndef good_handler(envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n    # GOOD: Parse and validate payload\n    try:\n        task_request = TaskRequest(**envelope.payload)\n    except ValidationError as e:\n        raise MalformedEnvelopeError(reason=\"Invalid TaskRequest\", details={\"errors\": e.errors()})\n    # GOOD: Use validated parts (FilePart validates URIs, rejects path traversal)\n    for part in task_request.input.get(\"parts\", []):\n        if part.get(\"type\") == \"file\":\n            file_part = FilePart.model_validate(part)  # URI validated here\n            # Process file_part.uri safely\n    # GOOD: Sanitize before logging\n    logger.info(\"request\", payload=sanitize_for_logging(envelope.payload))\n    return build_response(envelope, result)\n</code></pre>"},{"location":"security/#filepart-uri-validation","title":"FilePart URI Validation","text":"<p><code>FilePart</code> validates <code>uri</code> to block path traversal and risky <code>file://</code> usage:</p> <ul> <li>Rejects URIs containing <code>../</code> (path traversal).</li> <li>Rejects <code>file://</code> URIs that are not explicitly allowed (e.g. allowlisted base path).</li> <li>Allows <code>asap://</code>, <code>https://</code>, and <code>data:</code> URIs when they meet format checks.</li> </ul> <p>See <code>src/asap/models/parts.py</code> for the implementation. Use <code>FilePart</code> for any user-supplied file reference so validation is applied consistently.</p>"},{"location":"security/#handler-signature-validation","title":"Handler signature validation","text":"<p>Use <code>validate_handler(handler)</code> from <code>asap.transport.handlers</code> to ensure a handler has the required signature <code>(envelope: Envelope, manifest: Manifest)</code> before registering it. The registry calls this automatically on <code>register()</code> so invalid handlers are rejected at registration time.</p> <pre><code>from asap.transport.handlers import HandlerRegistry, validate_handler\n\ndef my_handler(envelope: Envelope, manifest: Manifest) -&gt; Envelope:\n    ...\n\nregistry = HandlerRegistry()\nvalidate_handler(my_handler)  # Optional: fail fast before register\nregistry.register(\"task.request\", my_handler)\n</code></pre>"},{"location":"security/#handler-sandboxing-optional","title":"Handler sandboxing (optional)","text":"<p>Handlers run in the same process as the server and have the same privileges. For untrusted or third-party handlers, consider:</p> <ul> <li>Running them in a separate process or worker pool with restricted resources.</li> <li>Validating and sanitizing all payload inputs before use (see input validation above).</li> <li>Using a bounded executor for sync handlers to limit CPU time (see <code>HandlerRegistry(executor=...)</code>).</li> <li>Not exposing sensitive environment variables or files to handler code.</li> </ul> <p>ASAP does not provide a sandbox; implement process or resource isolation at the deployment level if needed.</p>"},{"location":"security/#replay-attack-prevention","title":"Replay Attack Prevention","text":"<p>ASAP protocol prevents replay attacks through timestamp validation and optional nonce-based duplicate detection. This ensures that intercepted or maliciously replayed messages cannot be processed after their validity window expires.</p>"},{"location":"security/#timestamp-validation","title":"Timestamp Validation","text":"<p>Every ASAP envelope includes a <code>timestamp</code> field that is automatically validated by the server. The validation enforces two constraints:</p> <ol> <li>Maximum Age: Envelopes older than 5 minutes (300 seconds) are rejected</li> <li>Future Tolerance: Envelopes with timestamps more than 30 seconds in the future are rejected</li> </ol> <p>These windows balance security (preventing old message replays) with practical network latency and clock synchronization differences.</p>"},{"location":"security/#configuration_2","title":"Configuration","text":"<p>Timestamp validation is always enabled on the server. The validation constants can be imported:</p> <pre><code>from asap.models.constants import (\n    MAX_ENVELOPE_AGE_SECONDS,      # Default: 300 (5 minutes)\n    MAX_FUTURE_TOLERANCE_SECONDS,  # Default: 30 seconds\n)\n</code></pre>"},{"location":"security/#how-it-works_3","title":"How It Works","text":"<p>When an envelope is received:</p> <ol> <li>The server extracts the <code>timestamp</code> field from the envelope</li> <li>Calculates the age: <code>current_time - envelope.timestamp</code></li> <li>If age &gt; <code>MAX_ENVELOPE_AGE_SECONDS</code>, raises <code>InvalidTimestampError</code></li> <li>Calculates future offset: <code>envelope.timestamp - current_time</code></li> <li>If future offset &gt; <code>MAX_FUTURE_TOLERANCE_SECONDS</code>, raises <code>InvalidTimestampError</code></li> </ol>"},{"location":"security/#error-response_1","title":"Error Response","text":"<p>When timestamp validation fails, the server returns:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"request-id\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": {\n      \"error\": \"Invalid envelope timestamp\",\n      \"code\": \"asap:protocol/invalid_timestamp\",\n      \"message\": \"Envelope timestamp is too old: 600.0 seconds (max: 300 seconds)\",\n      \"details\": {\n        \"timestamp\": \"2026-01-27T22:43:12.008942+00:00\",\n        \"age_seconds\": 600.0,\n        \"envelope_id\": \"01KG0TJCY8D6NW3DHZCKYJGF5H\",\n        \"max_age_seconds\": 300\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"security/#nonce-based-duplicate-detection","title":"Nonce-Based Duplicate Detection","text":"<p>For additional protection against replay attacks, ASAP supports optional nonce-based duplicate detection. When enabled, the server tracks nonce values and rejects duplicate nonces within a time-to-live (TTL) window.</p>"},{"location":"security/#enabling-nonce-validation","title":"Enabling Nonce Validation","text":"<p>Nonce validation is optional and must be explicitly enabled:</p> <pre><code>from asap.transport.server import create_app\n\napp = create_app(\n    manifest,\n    require_nonce=True  # Enable nonce validation\n)\n</code></pre> <p>When enabled, the server creates an <code>InMemoryNonceStore</code> that tracks nonce values with a 10-minute TTL.</p>"},{"location":"security/#using-nonces-in-envelopes","title":"Using Nonces in Envelopes","text":"<p>Include a nonce in the envelope's <code>extensions</code> field:</p> <pre><code>from asap.models.envelope import Envelope\nimport secrets\n\nenvelope = Envelope(\n    asap_version=\"0.1\",\n    sender=\"urn:asap:agent:client\",\n    recipient=\"urn:asap:agent:server\",\n    payload_type=\"task.request\",\n    payload=task_request.model_dump(),\n    extensions={\n        \"nonce\": secrets.token_urlsafe(32)  # Generate unique nonce\n    }\n)\n</code></pre>"},{"location":"security/#how-it-works_4","title":"How It Works","text":"<ol> <li>No Nonce: If the envelope has no nonce, validation passes (nonce is optional)</li> <li>First Use: When a nonce is first seen, it's marked as used with a 10-minute TTL</li> <li>Duplicate Detection: If the same nonce is seen again within the TTL window, <code>InvalidNonceError</code> is raised</li> <li>Expiration: After the TTL expires, the nonce is removed from the store and can be used again</li> </ol>"},{"location":"security/#error-response_2","title":"Error Response","text":"<p>When a duplicate nonce is detected:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"request-id\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": {\n      \"error\": \"Invalid envelope nonce\",\n      \"code\": \"asap:protocol/invalid_nonce\",\n      \"message\": \"Duplicate nonce detected: abc123...\",\n      \"details\": {\n        \"nonce\": \"abc123...\",\n        \"envelope_id\": \"01KG0TJCY8D6NW3DHZCKYJGF5H\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"security/#custom-nonce-store","title":"Custom Nonce Store","text":"<p>For production deployments with multiple server instances, implement a distributed nonce store:</p> <pre><code>from asap.transport.validators import NonceStore\nimport redis\n\nclass RedisNonceStore:\n    \"\"\"Redis-based nonce store for distributed deployments.\"\"\"\n\n    def __init__(self, redis_client: redis.Redis):\n        self.redis = redis_client\n\n    def is_used(self, nonce: str) -&gt; bool:\n        \"\"\"Check if nonce exists in Redis.\"\"\"\n        return self.redis.exists(f\"nonce:{nonce}\") &gt; 0\n\n    def mark_used(self, nonce: str, ttl_seconds: int) -&gt; None:\n        \"\"\"Store nonce in Redis with TTL.\"\"\"\n        self.redis.setex(f\"nonce:{nonce}\", ttl_seconds, \"1\")\n\n# Use custom store\nredis_client = redis.Redis(host='localhost', port=6379, db=0)\nnonce_store = RedisNonceStore(redis_client)\n\n# Pass to server handler (requires custom handler setup)\n</code></pre>"},{"location":"security/#best-practices","title":"Best Practices","text":"<ol> <li>Always Use Timestamps: Timestamp validation is automatic and always enabled</li> <li>Enable Nonces for High-Security: Use nonce validation for sensitive operations</li> <li>Generate Strong Nonces: Use cryptographically secure random generators (e.g., <code>secrets.token_urlsafe()</code>)</li> <li>Distributed Deployments: Use a shared nonce store (Redis, database) for multi-instance deployments</li> <li>Monitor Rejections: Track <code>InvalidTimestampError</code> and <code>InvalidNonceError</code> to detect potential attacks</li> </ol>"},{"location":"security/#https-enforcement","title":"HTTPS Enforcement","text":"<p>The ASAP client enforces HTTPS for production connections by default, preventing unencrypted communication that could expose sensitive data or be intercepted by attackers.</p>"},{"location":"security/#client-side-enforcement","title":"Client-Side Enforcement","text":"<p>The <code>ASAPClient</code> validates URL schemes during initialization:</p> <ul> <li>HTTPS URLs: Always accepted</li> <li>HTTP localhost: Accepted with a warning (for development)</li> <li>HTTP production: Rejected with <code>ValueError</code> (security requirement)</li> </ul>"},{"location":"security/#default-behavior","title":"Default Behavior","text":"<pre><code>from asap.transport.client import ASAPClient\n\n# HTTPS: Works (production)\nasync with ASAPClient(\"https://api.example.com\") as client:\n    response = await client.send(envelope)\n\n# HTTP localhost: Works with warning (development)\nasync with ASAPClient(\"http://localhost:8000\") as client:\n    # Logs warning: \"Using HTTP for localhost connection. For production, use HTTPS.\"\n    response = await client.send(envelope)\n\n# HTTP production: Raises ValueError\ntry:\n    client = ASAPClient(\"http://api.example.com\")\nexcept ValueError as e:\n    # Error: \"HTTPS is required for non-localhost connections...\"\n</code></pre>"},{"location":"security/#override-for-development","title":"Override for Development","text":"<p>For local development or testing, you can disable HTTPS enforcement:</p> <pre><code># Development only: Disable HTTPS requirement\nasync with ASAPClient(\n    \"http://localhost:8000\",\n    require_https=False  # Override default\n) as client:\n    response = await client.send(envelope)\n</code></pre> <p>\u26a0\ufe0f Warning: Never use <code>require_https=False</code> in production. This disables a critical security check.</p>"},{"location":"security/#localhost-detection","title":"Localhost Detection","text":"<p>The client automatically detects localhost connections using:</p> <ul> <li>Hostname: <code>localhost</code></li> <li>IPv4: <code>127.0.0.1</code></li> <li>IPv6: <code>::1</code></li> </ul> <p>These addresses are allowed to use HTTP with a warning, recognizing that local development often uses unencrypted connections.</p>"},{"location":"security/#production-recommendations_2","title":"Production Recommendations","text":"<ol> <li>Always Use HTTPS: All production endpoints must use HTTPS</li> <li>Valid Certificates: Use valid SSL certificates (not self-signed)</li> <li>TLS 1.2+: Ensure servers support TLS 1.2 or higher</li> <li>Certificate Validation: Never disable certificate validation in production</li> <li>HSTS: Enable HTTP Strict Transport Security headers on servers</li> </ol>"},{"location":"security/#server-configuration","title":"Server Configuration","text":"<p>While the client enforces HTTPS, servers should also be configured to:</p> <ol> <li>Redirect HTTP to HTTPS: Automatically redirect all HTTP requests to HTTPS</li> <li>HSTS Headers: Include <code>Strict-Transport-Security</code> header</li> <li>Valid Certificates: Use certificates from trusted Certificate Authorities</li> </ol> <p>Example nginx configuration:</p> <pre><code>server {\n    listen 80;\n    server_name api.example.com;\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name api.example.com;\n\n    ssl_certificate /path/to/cert.pem;\n    ssl_certificate_key /path/to/key.pem;\n\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n\n    location /asap {\n        proxy_pass http://localhost:8000;\n    }\n}\n</code></pre>"},{"location":"security/#threat-model","title":"Threat Model","text":""},{"location":"security/#attack-vectors-and-mitigations","title":"Attack Vectors and Mitigations","text":"Threat Attack Vector Mitigation Eavesdropping Network interception TLS encryption Tampering Message modification Request signing Spoofing Identity impersonation Authentication + signing Replay Message replay attacks Timestamps + nonces Injection Malicious payload content Input validation DoS Resource exhaustion Rate limiting Man-in-the-Middle TLS interception Certificate pinning"},{"location":"security/#replay-attack-prevention_1","title":"Replay Attack Prevention","text":"<p>ASAP uses automatic timestamp validation and optional nonce-based duplicate detection to prevent replay attacks. See the Replay Attack Prevention section above for detailed documentation.</p>"},{"location":"security/#rate-limiting_1","title":"Rate Limiting","text":"<p>The ASAP protocol server includes built-in rate limiting (see Rate Limiting section above). For custom implementations, you can integrate with external rate limiting services:</p> <pre><code># Example: Custom rate limiting middleware\nfrom fastapi import Request, HTTPException\nimport redis\n\nredis_client = redis.Redis(host='localhost', port=6379, db=0)\n\nasync def custom_rate_limit(request: Request):\n    \"\"\"Custom rate limiting using Redis.\"\"\"\n    sender = _get_sender_from_envelope(request)\n    key = f\"rate_limit:{sender}\"\n\n    # Use Redis INCR with expiration\n    count = redis_client.incr(key)\n    if count == 1:\n        redis_client.expire(key, 60)  # 60 second window\n\n    if count &gt; 100:  # 100 requests per minute\n        raise HTTPException(status_code=429, detail=\"Rate limit exceeded\")\n</code></pre> <p>For most use cases, the built-in rate limiting is recommended (see Rate Limiting section).</p>"},{"location":"security/#input-validation","title":"Input Validation","text":"<p>Always validate payload content before processing:</p> <pre><code>from pydantic import ValidationError\nfrom asap.models.payloads import TaskRequest\n\ndef validate_payload(envelope: Envelope) -&gt; TaskRequest:\n    \"\"\"Validate and parse TaskRequest payload.\"\"\"\n    try:\n        return TaskRequest(**envelope.payload)\n    except ValidationError as e:\n        raise MalformedEnvelopeError(\n            reason=\"Invalid TaskRequest payload\",\n            details={\"validation_errors\": e.errors()}\n        )\n</code></pre>"},{"location":"security/#security-checklist","title":"Security Checklist","text":""},{"location":"security/#production-deployment","title":"Production Deployment","text":"<ul> <li>[ ] TLS 1.2+ enabled on all endpoints</li> <li>[ ] Valid SSL certificates (not self-signed)</li> <li>[ ] HSTS headers configured</li> <li>[ ] Authentication required for all endpoints</li> <li>[ ] Rate limiting enabled and configured appropriately</li> <li>[ ] Request size limits configured (default: 10MB)</li> <li>[ ] Request signing implemented</li> <li>[ ] Audit logging enabled</li> <li>[ ] Secrets stored in environment variables</li> <li>[ ] Input validation on all payloads</li> <li>[ ] Certificate rotation process defined</li> </ul>"},{"location":"security/#development-environment","title":"Development Environment","text":"<ul> <li>[ ] Use <code>localhost</code> or private networks only</li> <li>[ ] Never use production credentials</li> <li>[ ] Clear separation from production data</li> <li>[ ] Self-signed certificates marked as development-only</li> </ul>"},{"location":"security/#related-documentation","title":"Related Documentation","text":"<ul> <li>Error Handling - ASAP error taxonomy</li> <li>Transport - HTTP/JSON-RPC binding details</li> <li>Observability - Logging and tracing</li> </ul>"},{"location":"state-management/","title":"State Management Guide","text":"<p>Task lifecycle, state machine, and snapshot persistence in the ASAP protocol.</p>"},{"location":"state-management/#overview","title":"Overview","text":"<p>ASAP provides first-class state management through:</p> <ul> <li>Task State Machine: Defines valid task statuses and transitions</li> <li>State Snapshots: Persistent checkpoints for resumable tasks</li> <li>Versioned History: Track state evolution over time</li> </ul> <p>This addresses a key limitation in other agent protocols where task state is often ephemeral.</p>"},{"location":"state-management/#task-lifecycle","title":"Task Lifecycle","text":""},{"location":"state-management/#task-statuses","title":"Task Statuses","text":"<p>Every task in ASAP has a well-defined status from the <code>TaskStatus</code> enum:</p> Status Description Terminal <code>SUBMITTED</code> Task received, awaiting processing No <code>WORKING</code> Task actively being processed No <code>INPUT_REQUIRED</code> Waiting for additional input from requester No <code>COMPLETED</code> Task finished successfully Yes <code>FAILED</code> Task encountered an error Yes <code>CANCELLED</code> Task was cancelled by request Yes <pre><code>from asap.models.enums import TaskStatus\n\n# Check if task is in a terminal state\nstatus = TaskStatus.COMPLETED\nprint(status.is_terminal())  # True\n\n# Get all terminal states\nterminal = TaskStatus.terminal_states()\nprint(terminal)  # frozenset({COMPLETED, FAILED, CANCELLED})\n</code></pre>"},{"location":"state-management/#state-transition-diagram","title":"State Transition Diagram","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                                                     \u2502\n                    \u25bc                                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  SUBMITTED  \u2502             \u2502   WORKING   \u2502             \u2502  COMPLETED  \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n       \u2502                           \u2502                                      \u2502\n       \u2502                           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n       \u2502                           \u2502              \u2502    FAILED   \u2502        \u2502\n       \u2502                           \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n       \u2502                           \u2502                                      \u2502\n       \u2502                           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n       \u2502                           \u2502              \u2502 INPUT_REQUIRED  \u2502\u2500\u2500\u2500\u2500\u2518\n       \u2502                           \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                           \u2502                      \u2502\n       \u2502                           \u25bc                      \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502  CANCELLED  \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"state-management/#valid-transitions","title":"Valid Transitions","text":"<p>The state machine enforces these transition rules:</p> From Status Valid Target Statuses <code>SUBMITTED</code> <code>WORKING</code>, <code>CANCELLED</code> <code>WORKING</code> <code>COMPLETED</code>, <code>FAILED</code>, <code>CANCELLED</code>, <code>INPUT_REQUIRED</code> <code>INPUT_REQUIRED</code> <code>WORKING</code>, <code>CANCELLED</code> <code>COMPLETED</code> (none - terminal) <code>FAILED</code> (none - terminal) <code>CANCELLED</code> (none - terminal)"},{"location":"state-management/#using-the-state-machine","title":"Using the State Machine","text":""},{"location":"state-management/#checking-transition-validity","title":"Checking Transition Validity","text":"<p>Before transitioning, check if the transition is valid:</p> <pre><code>from asap.state.machine import can_transition\nfrom asap.models.enums import TaskStatus\n\n# Valid transition\ncan_transition(TaskStatus.SUBMITTED, TaskStatus.WORKING)  # True\n\n# Invalid transition (skipping WORKING state)\ncan_transition(TaskStatus.SUBMITTED, TaskStatus.COMPLETED)  # False\n\n# Terminal state cannot transition\ncan_transition(TaskStatus.COMPLETED, TaskStatus.WORKING)  # False\n</code></pre>"},{"location":"state-management/#transitioning-tasks","title":"Transitioning Tasks","text":"<p>Use the <code>transition()</code> function for validated state changes:</p> <pre><code>from datetime import datetime, timezone\nfrom asap.state.machine import transition\nfrom asap.models.entities import Task\nfrom asap.models.enums import TaskStatus\nfrom asap.errors import InvalidTransitionError\n\n# Create a task\ntask = Task(\n    id=\"task_01HX5K4N...\",\n    conversation_id=\"conv_01HX5K3M...\",\n    status=TaskStatus.SUBMITTED,\n    created_at=datetime.now(timezone.utc),\n    updated_at=datetime.now(timezone.utc),\n)\n\n# Valid transition - returns new Task instance\nworking_task = transition(task, TaskStatus.WORKING)\nprint(working_task.status)  # TaskStatus.WORKING\nprint(working_task.updated_at)  # Automatically updated\n\n# Invalid transition - raises exception\ntry:\n    transition(task, TaskStatus.COMPLETED)  # Skip WORKING!\nexcept InvalidTransitionError as e:\n    print(e.message)  # \"Invalid transition from 'submitted' to 'completed'\"\n    print(e.from_state)  # \"submitted\"\n    print(e.to_state)  # \"completed\"\n</code></pre>"},{"location":"state-management/#immutability","title":"Immutability","text":"<p>Task transitions are immutable - they return a new Task instance:</p> <pre><code>original = Task(\n    id=\"task_123\",\n    conversation_id=\"conv_456\",\n    status=TaskStatus.SUBMITTED,\n    created_at=datetime.now(timezone.utc),\n    updated_at=datetime.now(timezone.utc),\n)\n\nupdated = transition(original, TaskStatus.WORKING)\n\n# Original is unchanged\nprint(original.status)  # TaskStatus.SUBMITTED\n\n# Updated is a new instance\nprint(updated.status)  # TaskStatus.WORKING\nprint(original is updated)  # False\n</code></pre>"},{"location":"state-management/#task-helper-methods","title":"Task Helper Methods","text":"<p>The <code>Task</code> model provides convenient helper methods:</p> <pre><code>task = Task(\n    id=\"task_123\",\n    conversation_id=\"conv_456\",\n    status=TaskStatus.WORKING,\n    created_at=datetime.now(timezone.utc),\n    updated_at=datetime.now(timezone.utc),\n)\n\n# Check if task is in terminal state\ntask.is_terminal()  # False\n\n# Check if task can be cancelled\ntask.can_be_cancelled()  # True (SUBMITTED or WORKING only)\n\n# After completion\ncompleted_task = transition(task, TaskStatus.COMPLETED)\ncompleted_task.is_terminal()  # True\ncompleted_task.can_be_cancelled()  # False\n</code></pre>"},{"location":"state-management/#state-snapshots","title":"State Snapshots","text":"<p>Snapshots enable task state persistence, allowing tasks to be resumed after interruptions.</p>"},{"location":"state-management/#snapshot-model","title":"Snapshot Model","text":"<pre><code>from datetime import datetime, timezone\nfrom asap.models.entities import StateSnapshot\n\nsnapshot = StateSnapshot(\n    id=\"snap_01HX5K7R...\",\n    task_id=\"task_01HX5K4N...\",\n    version=1,\n    data={\n        \"search_completed\": True,\n        \"sources_analyzed\": 15,\n        \"partial_results\": [\"result1\", \"result2\"],\n        \"current_step\": \"synthesis\"\n    },\n    checkpoint=True,  # Mark as significant checkpoint\n    created_at=datetime.now(timezone.utc),\n)\n</code></pre>"},{"location":"state-management/#storage-backend-configuration","title":"Storage Backend Configuration","text":"<p>You can switch backends without code changes using environment variables or the factory:</p> Variable Description Default <code>ASAP_STORAGE_BACKEND</code> <code>memory</code> or <code>sqlite</code> <code>memory</code> <code>ASAP_STORAGE_PATH</code> Database file path when using <code>sqlite</code> <code>asap_state.db</code> <pre><code>from asap.state.stores import create_snapshot_store\n\n# Uses ASAP_STORAGE_BACKEND and ASAP_STORAGE_PATH\nstore = create_snapshot_store()\n</code></pre> <ul> <li>memory: In-memory store (default). Best for tests and single-process dev; state is lost on restart.</li> <li>sqlite: File-based persistent store. Use for development or single-instance production; state survives restarts.</li> </ul> <p>When using <code>create_app()</code>, if you do not pass <code>snapshot_store</code>, the server uses <code>create_snapshot_store()</code> and attaches the store to <code>app.state.snapshot_store</code> for handlers to use.</p> <p>Migration from InMemory to SQLite: Set <code>ASAP_STORAGE_BACKEND=sqlite</code> and optionally <code>ASAP_STORAGE_PATH=/path/to/db</code>. No code change required; existing handlers that read <code>app.state.snapshot_store</code> will use the SQLite backend. Data in the previous in-memory store is not migrated; start with an empty DB or restore from backup if needed.</p>"},{"location":"state-management/#snapshot-store-interface","title":"Snapshot Store Interface","text":"<p>The <code>SnapshotStore</code> protocol defines the storage interface:</p> <pre><code>from asap.state import InMemorySnapshotStore, SnapshotStore\n\n# Create a store (use InMemorySnapshotStore for development)\nstore = InMemorySnapshotStore()\n\n# Save a snapshot\nstore.save(snapshot)\n\n# Get latest snapshot for a task\nlatest = store.get(\"task_01HX5K4N...\")\n\n# Get specific version\nv2 = store.get(\"task_01HX5K4N...\", version=2)\n\n# List all versions\nversions = store.list_versions(\"task_01HX5K4N...\")\nprint(versions)  # [1, 2, 3]\n\n# Delete specific version\nstore.delete(\"task_01HX5K4N...\", version=1)\n\n# Delete all snapshots for a task\nstore.delete(\"task_01HX5K4N...\")\n</code></pre>"},{"location":"state-management/#creating-custom-stores","title":"Creating Custom Stores","text":"<p>Implement the <code>SnapshotStore</code> protocol for custom backends:</p> <pre><code>from asap.state.snapshot import SnapshotStore\nfrom asap.models.entities import StateSnapshot\nfrom asap.models.types import TaskID\n\nclass RedisSnapshotStore:\n    \"\"\"Redis-backed snapshot storage.\"\"\"\n\n    def __init__(self, redis_client):\n        self.redis = redis_client\n\n    def save(self, snapshot: StateSnapshot) -&gt; None:\n        key = f\"snapshot:{snapshot.task_id}:{snapshot.version}\"\n        self.redis.set(key, snapshot.model_dump_json())\n\n    def get(self, task_id: TaskID, version: int | None = None) -&gt; StateSnapshot | None:\n        if version is None:\n            version = self._get_latest_version(task_id)\n        if version is None:\n            return None\n\n        key = f\"snapshot:{task_id}:{version}\"\n        data = self.redis.get(key)\n        return StateSnapshot.model_validate_json(data) if data else None\n\n    def list_versions(self, task_id: TaskID) -&gt; list[int]:\n        pattern = f\"snapshot:{task_id}:*\"\n        keys = self.redis.keys(pattern)\n        return sorted(int(k.split(\":\")[-1]) for k in keys)\n\n    def delete(self, task_id: TaskID, version: int | None = None) -&gt; bool:\n        if version is None:\n            pattern = f\"snapshot:{task_id}:*\"\n            keys = self.redis.keys(pattern)\n            if keys:\n                self.redis.delete(*keys)\n                return True\n            return False\n\n        key = f\"snapshot:{task_id}:{version}\"\n        return bool(self.redis.delete(key))\n\n# Usage - works with SnapshotStore protocol\nstore: SnapshotStore = RedisSnapshotStore(redis_client)\nstore.save(snapshot)\n</code></pre>"},{"location":"state-management/#snapshot-usage-patterns","title":"Snapshot Usage Patterns","text":""},{"location":"state-management/#pattern-1-periodic-checkpoints","title":"Pattern 1: Periodic Checkpoints","text":"<p>Save snapshots at regular intervals during long-running tasks:</p> <pre><code>async def process_with_checkpoints(task: Task, store: SnapshotStore):\n    \"\"\"Process task with periodic checkpoints.\"\"\"\n    state = {\"step\": 0, \"results\": []}\n\n    for i, item in enumerate(items_to_process):\n        # Process item\n        result = await process_item(item)\n        state[\"results\"].append(result)\n        state[\"step\"] = i + 1\n\n        # Checkpoint every 10 items\n        if (i + 1) % 10 == 0:\n            snapshot = StateSnapshot(\n                id=generate_id(),\n                task_id=task.id,\n                version=state[\"step\"],\n                data=state,\n                checkpoint=True,\n                created_at=datetime.now(timezone.utc),\n            )\n            store.save(snapshot)\n</code></pre>"},{"location":"state-management/#pattern-2-resume-from-failure","title":"Pattern 2: Resume from Failure","text":"<p>Restore state after task interruption:</p> <pre><code>async def resume_task(task_id: str, store: SnapshotStore):\n    \"\"\"Resume task from latest snapshot.\"\"\"\n    # Get latest snapshot\n    snapshot = store.get(task_id)\n\n    if snapshot is None:\n        # No snapshot - start fresh\n        return await start_fresh(task_id)\n\n    # Restore state\n    state = snapshot.data\n    start_step = state.get(\"step\", 0)\n    results = state.get(\"results\", [])\n\n    print(f\"Resuming from step {start_step}\")\n\n    # Continue processing\n    for i, item in enumerate(items_to_process[start_step:], start=start_step):\n        result = await process_item(item)\n        results.append(result)\n        # ... continue with checkpoints\n</code></pre>"},{"location":"state-management/#pattern-3-state-rollback","title":"Pattern 3: State Rollback","text":"<p>Rollback to a previous known-good state:</p> <pre><code>async def rollback_to_checkpoint(task_id: str, store: SnapshotStore):\n    \"\"\"Rollback to the last checkpoint.\"\"\"\n    versions = store.list_versions(task_id)\n\n    # Find last checkpoint\n    for version in reversed(versions):\n        snapshot = store.get(task_id, version)\n        if snapshot and snapshot.checkpoint:\n            print(f\"Rolling back to version {version}\")\n            return snapshot.data\n\n    raise ValueError(\"No checkpoint found\")\n</code></pre>"},{"location":"state-management/#versioning-and-consistency","title":"Versioning and Consistency","text":""},{"location":"state-management/#version-numbers","title":"Version Numbers","text":"<p>Snapshot versions are positive integers starting at 1:</p> <pre><code>snapshot = StateSnapshot(\n    id=\"snap_123\",\n    task_id=\"task_456\",\n    version=1,  # Must be &gt;= 1\n    data={\"key\": \"value\"},\n    created_at=datetime.now(timezone.utc),\n)\n</code></pre>"},{"location":"state-management/#version-auto-tracking","title":"Version Auto-Tracking","text":"<p>The <code>InMemorySnapshotStore</code> tracks the latest version:</p> <pre><code>store = InMemorySnapshotStore()\n\n# Save version 1\nstore.save(StateSnapshot(\n    id=\"snap_1\", task_id=\"task_123\", version=1,\n    data={}, created_at=datetime.now(timezone.utc)\n))\n\n# Save version 2\nstore.save(StateSnapshot(\n    id=\"snap_2\", task_id=\"task_123\", version=2,\n    data={}, created_at=datetime.now(timezone.utc)\n))\n\n# Get latest returns version 2\nlatest = store.get(\"task_123\")\nprint(latest.version)  # 2\n</code></pre>"},{"location":"state-management/#thread-safety","title":"Thread Safety","text":"<p>The <code>InMemorySnapshotStore</code> is thread-safe:</p> <pre><code>from asap.state import InMemorySnapshotStore\nimport threading\n\nstore = InMemorySnapshotStore()\n\ndef worker(task_id: str, version: int):\n    snapshot = StateSnapshot(\n        id=f\"snap_{version}\",\n        task_id=task_id,\n        version=version,\n        data={\"version\": version},\n        created_at=datetime.now(timezone.utc),\n    )\n    store.save(snapshot)\n\n# Concurrent writes are safe\nthreads = [\n    threading.Thread(target=worker, args=(\"task_123\", i))\n    for i in range(1, 11)\n]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\n# All versions saved\nprint(store.list_versions(\"task_123\"))  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>"},{"location":"state-management/#consistency-expectations","title":"Consistency Expectations","text":"Operation Guarantee <code>save()</code> Atomic write <code>get()</code> Read-your-writes consistency <code>list_versions()</code> Eventually consistent <code>delete()</code> Atomic delete <p>For production deployments with multiple instances, use a distributed store (Redis, PostgreSQL) with appropriate consistency guarantees.</p>"},{"location":"state-management/#best-practices","title":"Best Practices","text":""},{"location":"state-management/#1-checkpoint-strategically","title":"1. Checkpoint Strategically","text":"<p>Save snapshots at meaningful boundaries, not after every operation:</p> <pre><code># Good: Checkpoint at logical boundaries\nif phase_complete or items_processed % 100 == 0:\n    save_snapshot(state, checkpoint=True)\n\n# Avoid: Too frequent checkpoints\nfor item in items:\n    process(item)\n    save_snapshot(state)  # Too expensive!\n</code></pre>"},{"location":"state-management/#2-keep-snapshots-lean","title":"2. Keep Snapshots Lean","text":"<p>Store only essential state, not derived data:</p> <pre><code># Good: Essential state only\nsnapshot_data = {\n    \"step\": current_step,\n    \"item_ids_processed\": processed_ids,\n    \"config\": task_config,\n}\n\n# Avoid: Storing derived/reconstructable data\nsnapshot_data = {\n    \"step\": current_step,\n    \"all_results\": huge_results_list,  # Can be reconstructed\n    \"cache\": in_memory_cache,  # Not serializable\n}\n</code></pre>"},{"location":"state-management/#3-mark-critical-checkpoints","title":"3. Mark Critical Checkpoints","text":"<p>Use the <code>checkpoint</code> flag for important states:</p> <pre><code># Mark significant milestones\nsnapshot = StateSnapshot(\n    id=generate_id(),\n    task_id=task.id,\n    version=version,\n    data=state,\n    checkpoint=True,  # After phase completion\n    created_at=datetime.now(timezone.utc),\n)\n</code></pre>"},{"location":"state-management/#4-clean-up-old-snapshots","title":"4. Clean Up Old Snapshots","text":"<p>Remove unnecessary snapshots to manage storage:</p> <pre><code>async def cleanup_old_snapshots(task_id: str, store: SnapshotStore, keep_last: int = 5):\n    \"\"\"Keep only recent snapshots plus checkpoints.\"\"\"\n    versions = store.list_versions(task_id)\n\n    for version in versions[:-keep_last]:\n        snapshot = store.get(task_id, version)\n        if snapshot and not snapshot.checkpoint:\n            store.delete(task_id, version)\n</code></pre>"},{"location":"state-management/#related-documentation","title":"Related Documentation","text":"<ul> <li>Error Handling - <code>InvalidTransitionError</code> and other exceptions</li> <li>API Reference - Complete API documentation</li> <li>Testing - Testing state management</li> <li>Best Practices: Agent Failover &amp; Migration - State handover, failover, and migration patterns</li> </ul>"},{"location":"testing/","title":"Testing Guide","text":"<p>This guide covers the testing infrastructure for the ASAP Protocol implementation.</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>Always use <code>uv run pytest</code> to run tests:</p> <pre><code># Run all tests\nuv run pytest\n\n# Run specific test file\nuv run pytest tests/transport/integration/test_rate_limiting.py -v\n\n# Run specific test\nuv run pytest tests/transport/integration/test_rate_limiting.py::TestRateLimiting::test_requests_within_limit_succeed -v\n\n# Run with coverage\nuv run pytest --cov=src --cov-report=html\n\n# Run in parallel (using pytest-xdist)\nuv run pytest -n auto\n</code></pre> <p>Why <code>uv run pytest</code> instead of <code>pytest</code>?</p> <p>The project requires Python 3.13+, but your system may have a global <code>pytest</code> installed under an older Python version (e.g., Python 3.9). Using <code>uv run pytest</code> ensures:</p> <ol> <li>\u2705 Correct Python version (from <code>.venv</code>, not system Python)</li> <li>\u2705 Correct pytest version (from project dependencies)</li> <li>\u2705 All project dependencies are available</li> <li>\u2705 Consistent with CI environment</li> </ol> <p>Alternative: Activate the virtual environment first:</p> <pre><code>source .venv/bin/activate\npytest tests/transport/integration/test_rate_limiting.py -v\ndeactivate\n</code></pre>"},{"location":"testing/#test-organization","title":"Test Organization","text":"<p>Tests are organized into three categories based on their scope and dependencies:</p>"},{"location":"testing/#unit-tests-teststransportunit","title":"Unit Tests (<code>tests/transport/unit/</code>)","text":"<p>Unit tests validate isolated components without external dependencies. These tests: - Test individual classes or functions in isolation - Have no HTTP dependencies - Have no rate limiting dependencies - Run very fast - Are deterministic and repeatable</p> <p>Example: <code>test_bounded_executor.py</code> tests the <code>BoundedExecutor</code> class without any HTTP or rate limiting.</p>"},{"location":"testing/#integration-tests-teststransportintegration","title":"Integration Tests (<code>tests/transport/integration/</code>)","text":"<p>Integration tests validate component interactions within the transport layer. These tests: - Test interactions between multiple components (e.g., server, middleware, handlers) - May use HTTP clients (<code>TestClient</code>) - Are organized by feature area:   - <code>test_rate_limiting.py</code> - Rate limiting functionality (isolated file)   - <code>test_request_size_limits.py</code> - Request size validation   - <code>test_thread_pool_bounds.py</code> - Thread pool exhaustion handling   - <code>test_metrics_cardinality.py</code> - Metrics cardinality protection   - <code>test_server_core.py</code> - Core server functionality (endpoints, handlers, metrics)</p> <p>IMPORTANT: Integration tests use fixtures from <code>tests/transport/conftest.py</code>. See the Fixtures section for details.</p>"},{"location":"testing/#e2e-tests-teststransporte2e","title":"E2E Tests (<code>tests/transport/e2e/</code>)","text":"<p>End-to-end tests validate the full agent flow using real agent implementations. These tests: - Test complete workflows from request to response - Use the full stack (server, handlers, state management) - Validate cross-component behavior - Are slower but provide high confidence</p> <p>Example: <code>test_full_agent_flow.py</code> tests complete round-trip agent interactions.</p> <p>Linking unit and integration: E2E tests can reuse the same app (e.g. <code>create_app(manifest)</code>) with <code>httpx.ASGITransport(app=app)</code> so that <code>ASAPClient</code> talks to the real server over HTTP. For example, <code>TestManifestDiscovery::test_asap_client_get_manifest_against_app_and_cache</code> asserts that <code>get_manifest()</code> fetches from <code>/.well-known/asap/manifest.json</code> and that the manifest cache is used on the second call, connecting the unit tests in <code>test_client_coverage_gaps.py</code> (cache hit/miss) with the real endpoint.</p> <p>Future integration opportunities: - MCP: An integration test that runs the MCP server (e.g. in-process <code>run_stdio</code> or subprocess) and the MCP client, then calls <code>list_tools</code> and <code>call_tool</code>, would bridge the unit tests in <code>tests/mcp/</code> with a full round-trip. - Snapshot store: If handlers or workflows start using <code>InMemorySnapshotStore</code>, an integration test that saves and deletes snapshots and asserts store state would align with the snapshot unit tests (e.g. <code>test_delete_last_version_cleans_up_task</code>). - Trace parser and logs: A test that triggers a request, captures structured log output, and runs <code>parse_trace_from_lines()</code> (or <code>extract_trace_ids</code>) on it would ensure the observability log format stays compatible with the trace parser.</p>"},{"location":"testing/#chaos-engineering-tests-testschaos","title":"Chaos Engineering Tests (<code>tests/chaos/</code>)","text":"<p>Chaos engineering tests validate system resilience under adverse conditions. These tests simulate real-world failure scenarios that distributed systems may encounter.</p> <p>Test modules:</p> Module Tests Description <code>test_network_partition.py</code> 12 Network partition and connectivity issues <code>test_crashes.py</code> 13 Server crashes and 5xx error responses <code>test_message_reliability.py</code> 19 Message loss, duplication, and corruption <code>test_clock_skew.py</code> 25 Clock synchronization and timestamp validation <p>Running chaos tests:</p> <pre><code># Run all chaos tests\nuv run pytest tests/chaos/ -v\n\n# Run specific chaos test module\nuv run pytest tests/chaos/test_network_partition.py -v\n\n# Run with verbose output for debugging\nuv run pytest tests/chaos/ -v --tb=long\n</code></pre> <p>Test categories:</p>"},{"location":"testing/#network-partition-test_network_partitionpy","title":"Network Partition (<code>test_network_partition.py</code>)","text":"<p>Simulates network-level failures: - Complete connection failures (server unreachable) - Connection timeouts (server unresponsive) - Intermittent failures (flaky networks) - DNS resolution failures - SSL/TLS handshake failures - Circuit breaker behavior under sustained failures</p>"},{"location":"testing/#server-crashes-test_crashespy","title":"Server Crashes (<code>test_crashes.py</code>)","text":"<p>Simulates server-side failures: - Server crash during request (connection reset) - HTTP 502 Bad Gateway (proxy/load balancer issues) - HTTP 503 Service Unavailable (server restarting) - HTTP 504 Gateway Timeout (slow backend) - Rolling restart scenarios (K8s deployments) - OOM kill patterns - Cascading failures</p>"},{"location":"testing/#message-reliability-test_message_reliabilitypy","title":"Message Reliability (<code>test_message_reliability.py</code>)","text":"<p>Simulates message-level issues: - Message loss (timeout, no response) - Message duplication (idempotency testing) - Out-of-order delivery - Partial message corruption (truncated JSON) - Malformed responses - Retry behavior with same envelope ID</p>"},{"location":"testing/#clock-skew-test_clock_skewpy","title":"Clock Skew (<code>test_clock_skew.py</code>)","text":"<p>Simulates clock synchronization issues: - Past timestamps (stale messages, replay attacks) - Future timestamps (sender clock ahead) - Timezone handling (UTC, positive/negative offsets) - Clock drift detection - Multi-datacenter clock variance - NTP sync failure scenarios - VM snapshot/resume clock skew</p> <p>Key patterns used:</p> <ol> <li>Mock transports: Uses <code>httpx.MockTransport</code> to simulate network behavior</li> <li>Circuit breakers: Tests circuit breaker state transitions</li> <li>Retry validation: Verifies retry counts and exponential backoff</li> <li>Error message clarity: Ensures errors are actionable</li> </ol> <p>Example chaos test:</p> <pre><code>from unittest.mock import patch\nimport httpx\nimport pytest\nfrom asap.transport.client import ASAPClient, ASAPConnectionError\n\nasync def test_intermittent_failure(sample_envelope, response_envelope):\n    \"\"\"Test client resilience to intermittent failures.\"\"\"\n    call_count = 0\n\n    def mock_transport(request: httpx.Request) -&gt; httpx.Response:\n        nonlocal call_count\n        call_count += 1\n        # First 2 attempts fail, 3rd succeeds\n        if call_count &lt;= 2:\n            raise httpx.ConnectError(\"Network flaky\")\n        return create_mock_response(response_envelope)\n\n    with patch(\"asap.transport.client.asyncio.sleep\"):\n        async with ASAPClient(\n            \"http://localhost:8000\",\n            transport=httpx.MockTransport(mock_transport),\n            max_retries=5,\n        ) as client:\n            response = await client.send(sample_envelope)\n            assert response.payload_type == \"task.response\"\n\n    assert call_count == 3  # 2 failures + 1 success\n</code></pre>"},{"location":"testing/#test-isolation-strategy","title":"Test Isolation Strategy","text":"<p>The ASAP Protocol test suite uses a three-pronged approach to ensure complete test isolation and prevent interference, especially from rate limiting:</p>"},{"location":"testing/#1-process-isolation-pytest-xdist","title":"1. Process Isolation (pytest-xdist)","text":"<p>We use <code>pytest-xdist</code> to run tests in separate processes, providing complete isolation at the process level. This is the primary mechanism for preventing interference.</p> <p>Usage:</p> <pre><code># Run tests in parallel with automatic worker count\nuv run pytest -n auto\n\n# Run with specific number of workers\nuv run pytest -n 4\n</code></pre> <p>Benefits: - Complete process-level isolation - No shared state between test processes - Faster execution on multi-core systems - Automatic worker count based on CPU cores</p>"},{"location":"testing/#2-aggressive-monkeypatch-fixtures","title":"2. Aggressive Monkeypatch Fixtures","text":"<p>For tests that can't benefit from process isolation (or need additional isolation), we use \"aggressive monkeypatch\" fixtures that replace module-level rate limiters.</p> <p>Why \"Aggressive Monkeypatch\"?</p> <p>The <code>slowapi.Limiter</code> library maintains global state that persists across tests, even with unique storage URIs. Simply replacing <code>app.state.limiter</code> is not sufficient because:</p> <ul> <li>The limiter is created at module import time</li> <li>Code may reference the module-level limiter directly</li> <li>Internal state persists even with different storage URIs</li> </ul> <p>Solution: Our fixtures replace the limiter at the module level in both <code>asap.transport.middleware</code> and <code>asap.transport.server</code>, ensuring complete isolation even when code uses the global limiter directly.</p> <p>Example:</p> <pre><code>def test_rate_limiting(replace_global_limiter, isolated_limiter_factory):\n    # replace_global_limiter automatically replaces module-level limiters\n    limiter = isolated_limiter_factory([\"5/minute\"])\n    # Global limiter is now replaced, app will use it automatically\n    app = create_app(manifest, rate_limit=\"5/minute\")\n</code></pre>"},{"location":"testing/#3-strategic-test-organization","title":"3. Strategic Test Organization","text":"<p>Tests are strategically organized to prevent interference:</p> <ul> <li>Rate limiting tests are in a separate file (<code>test_rate_limiting.py</code>) that runs in isolated processes</li> <li>Non-rate-limiting tests inherit from <code>NoRateLimitTestBase</code> to automatically disable rate limiting</li> <li>Unit tests have no rate limiting dependencies at all</li> </ul> <p>This organization ensures that rate limiting tests don't interfere with other tests, and vice versa.</p>"},{"location":"testing/#rate-limiting-in-tests","title":"Rate Limiting in Tests","text":""},{"location":"testing/#noratelimittestbase","title":"NoRateLimitTestBase","text":"<p>For tests that don't need rate limiting, inherit from <code>NoRateLimitTestBase</code>:</p> <pre><code>from tests.transport.conftest import NoRateLimitTestBase\n\nclass TestMyFeature(NoRateLimitTestBase):\n    \"\"\"Tests for my feature without rate limiting interference.\"\"\"\n\n    def test_something(self, manifest):\n        # Rate limiting is automatically disabled\n        app = create_app(manifest)\n        # Test your feature without rate limiting concerns\n</code></pre> <p>What it does: - Automatically disables rate limiting for all tests in the class - Replaces module-level limiters with a no-limit limiter - Prevents interference from rate limiting tests - No need to manually configure rate limiting</p> <p>When to use: - Tests that don't test rate limiting functionality - Tests that need to make many requests without hitting limits - Integration tests that test other features (size validation, thread pools, etc.)</p>"},{"location":"testing/#testing-rate-limiting","title":"Testing Rate Limiting","text":"<p>When writing tests specifically for rate limiting functionality:</p> <ol> <li>Use aggressive monkeypatch: Use <code>replace_global_limiter</code> or manually replace module-level limiters</li> <li>Isolate in separate file: Put rate limiting tests in <code>test_rate_limiting.py</code></li> <li>Use isolated limiters: Use <code>isolated_limiter_factory</code> to create fresh limiters</li> </ol> <p>Example:</p> <pre><code>def test_rate_limit_exceeded(\n    monkeypatch,\n    isolated_limiter_factory,\n    rate_limit_manifest,\n):\n    # Create isolated limiter with specific limits\n    limiter = isolated_limiter_factory([\"2/minute\"])\n\n    # Replace global limiter in both modules\n    import asap.transport.middleware as middleware_module\n    import asap.transport.server as server_module\n\n    monkeypatch.setattr(middleware_module, \"limiter\", limiter)\n    monkeypatch.setattr(server_module, \"limiter\", limiter)\n\n    # Create app with rate limiting\n    app = create_app(rate_limit_manifest, rate_limit=\"2/minute\")\n    app.state.limiter = limiter\n\n    client = TestClient(app)\n\n    # Make requests and verify rate limiting behavior\n    # ...\n</code></pre>"},{"location":"testing/#choosing-the-right-test-isolation-strategy","title":"Choosing the Right Test Isolation Strategy","text":"<p>When writing transport layer tests, use this decision tree to choose the appropriate fixtures and test organization:</p> <pre><code>graph TD\n    A[Writing Transport Test] --&gt; B{Testing rate&lt;br/&gt;limiting behavior?}\n    B --&gt;|Yes| C[Create class-level fixture&lt;br/&gt;with aggressive monkeypatch]\n    B --&gt;|No| D[Inherit from&lt;br/&gt;NoRateLimitTestBase]\n\n    C --&gt; E[See test_rate_limiting.py&lt;br/&gt;for examples]\n    C --&gt; F{Need custom&lt;br/&gt;rate limit?}\n    F --&gt;|Yes| G[Create fixture like&lt;br/&gt;isolated_app_5_per_minute]\n    F --&gt;|No| H[Use replace_global_limiter&lt;br/&gt;fixture]\n\n    D --&gt; I[Rate limiting automatically&lt;br/&gt;disabled for all tests]\n    D --&gt; J[Can make unlimited&lt;br/&gt;requests without 429 errors]\n\n    style C fill:#fff3cd,stroke:#856404\n    style D fill:#d4edda,stroke:#155724\n    style E fill:#e7f3ff,stroke:#004085\n    style G fill:#e7f3ff,stroke:#004085\n    style H fill:#e7f3ff,stroke:#004085\n    style I fill:#d1ecf1,stroke:#0c5460\n    style J fill:#d1ecf1,stroke:#0c5460\n</code></pre>"},{"location":"testing/#quick-reference-table","title":"Quick Reference Table","text":"Your Test Needs Recommended Approach Example Testing rate limiting Class-level fixture with aggressive monkeypatch <code>test_rate_limiting.py</code> NOT testing rate limiting Inherit from <code>NoRateLimitTestBase</code> Most integration tests Unit test (no HTTP) No special fixtures needed <code>test_bounded_executor.py</code> Custom rate limit (e.g., 5/min) Create class-level fixture See <code>isolated_app_5_per_minute</code> Testing other features <code>NoRateLimitTestBase</code> + specific fixtures <code>test_request_size_limits.py</code>"},{"location":"testing/#when-to-use-each-fixture","title":"When to Use Each Fixture","text":""},{"location":"testing/#use-noratelimittestbase-when","title":"Use <code>NoRateLimitTestBase</code> when:","text":"<ul> <li>\u2705 Testing features OTHER than rate limiting</li> <li>\u2705 Need to make many requests without hitting limits</li> <li>\u2705 Testing thread pools, request size limits, metrics, etc.</li> <li>\u2705 Running integration tests that involve HTTP but not rate limiting</li> </ul>"},{"location":"testing/#use-aggressive-monkeypatch-fixtures-when","title":"Use Aggressive Monkeypatch Fixtures when:","text":"<ul> <li>\u2705 Explicitly testing rate limiting behavior</li> <li>\u2705 Need precise control over rate limit values</li> <li>\u2705 Testing limit thresholds, resets, or error responses</li> <li>\u2705 Creating rate limiting tests in <code>test_rate_limiting.py</code></li> </ul>"},{"location":"testing/#use-neither-plain-pytest-when","title":"Use Neither (plain pytest) when:","text":"<ul> <li>\u2705 Unit tests with no HTTP dependencies</li> <li>\u2705 Testing pure functions or classes</li> <li>\u2705 No rate limiting or app creation involved</li> </ul>"},{"location":"testing/#example-creating-a-class-level-fixture-for-rate-limiting-tests","title":"Example: Creating a Class-Level Fixture for Rate Limiting Tests","text":"<pre><code>class TestMyRateLimitFeature:\n    \"\"\"Tests for rate limiting with custom limits.\"\"\"\n\n    @pytest.fixture\n    def isolated_app_custom_limit(\n        self,\n        monkeypatch: pytest.MonkeyPatch,\n        isolated_limiter_factory: Callable,\n        manifest: Manifest,\n    ) -&gt; FastAPI:\n        \"\"\"Create app with custom rate limit.\"\"\"\n        # Create isolated limiter\n        limiter = isolated_limiter_factory([\"10/minute\"])\n\n        # Aggressive monkeypatch - replace in BOTH modules\n        import asap.transport.middleware as middleware_module\n        import asap.transport.server as server_module\n\n        monkeypatch.setattr(middleware_module, \"limiter\", limiter)\n        monkeypatch.setattr(server_module, \"limiter\", limiter)\n\n        # Create app\n        app = create_app(manifest, rate_limit=\"10/minute\")\n        app.state.limiter = limiter\n\n        return app\n\n    def test_my_rate_limit_feature(\n        self,\n        isolated_app_custom_limit: FastAPI,\n    ) -&gt; None:\n        \"\"\"Test uses the custom rate-limited app.\"\"\"\n        client = TestClient(isolated_app_custom_limit)\n        # Test implementation...\n</code></pre>"},{"location":"testing/#pytest-fixtures-explained","title":"Pytest Fixtures Explained","text":""},{"location":"testing/#what-are-fixtures","title":"What are Fixtures?","text":"<p>Fixtures are pytest's way of providing test dependencies. They: - Set up test data or objects - Provide reusable test components - Ensure proper cleanup after tests - Can be shared across multiple tests</p>"},{"location":"testing/#factory-fixtures-vs-regular-fixtures","title":"Factory Fixtures vs Regular Fixtures","text":"<p>Regular Fixtures: Return a single value that is reused (or recreated) for each test:</p> <pre><code>@pytest.fixture\ndef manifest() -&gt; Manifest:\n    \"\"\"Returns a single Manifest instance.\"\"\"\n    return Manifest(...)\n</code></pre> <p>Factory Fixtures: Return a function that creates new instances:</p> <pre><code>@pytest.fixture\ndef isolated_limiter_factory():\n    \"\"\"Returns a function that creates new limiters.\"\"\"\n    def _create(limits=None):\n        return Limiter(...)\n    return _create\n</code></pre> <p>Factory fixtures are useful when you need multiple instances with different configurations.</p>"},{"location":"testing/#our-specific-fixtures","title":"Our Specific Fixtures","text":""},{"location":"testing/#isolated_limiter_factory","title":"<code>isolated_limiter_factory</code>","text":"<p>A factory fixture that creates isolated rate limiters with unique storage:</p> <pre><code>def test_something(isolated_limiter_factory):\n    # Create a limiter with specific limits\n    limiter = isolated_limiter_factory([\"10/minute\"])\n\n    # Each call creates a NEW limiter with isolated storage\n    another_limiter = isolated_limiter_factory([\"5/minute\"])\n</code></pre> <p>Why we created it: Ensures each test gets a completely fresh limiter with no shared state.</p>"},{"location":"testing/#replace_global_limiter","title":"<code>replace_global_limiter</code>","text":"<p>A fixture that replaces module-level limiters using aggressive monkeypatch:</p> <pre><code>def test_something(replace_global_limiter):\n    # Global limiter is automatically replaced\n    # Any code using the module-level limiter will use the new one\n    app = create_app(manifest)\n</code></pre> <p>Why we created it: Provides complete isolation by replacing limiters at the module level, not just at the app level.</p>"},{"location":"testing/#create_isolated_app","title":"<code>create_isolated_app</code>","text":"<p>A factory fixture that creates apps with isolated limiters:</p> <pre><code>def test_something(create_isolated_app, manifest):\n    # Create app with isolated limiter\n    app = create_isolated_app(\n        manifest,\n        rate_limit=\"10/minute\",\n        use_monkeypatch=True,  # Use aggressive monkeypatch\n    )\n</code></pre> <p>Why we created it: Simplifies app creation for tests that need complete isolation.</p>"},{"location":"testing/#asap-testing-utilities-asaptesting","title":"ASAP Testing Utilities (<code>asap.testing</code>)","text":"<p>The <code>asap.testing</code> package provides MockAgent, pytest fixtures, context managers, and custom assertions to reduce boilerplate when testing ASAP protocol integrations. Use these utilities to simulate agents, validate envelopes, and assert task outcomes without starting real servers.</p>"},{"location":"testing/#mockagent","title":"MockAgent","text":"<p><code>MockAgent</code> simulates an ASAP agent in memory. Pre-set responses per skill, record incoming requests, and optionally add delay or raise exceptions for error-path tests.</p> <p>Basic usage:</p> <pre><code>from asap.testing import MockAgent\nfrom asap.models.envelope import Envelope\nfrom asap.models.payloads import TaskRequest, TaskResponse\n\nagent = MockAgent(\"urn:asap:agent:mock\")\nagent.set_response(\n    \"echo\",\n    TaskResponse(task_id=\"t1\", status=\"completed\").model_dump(),\n)\n\nreq = Envelope(\n    asap_version=\"0.1\",\n    sender=\"urn:asap:agent:a\",\n    recipient=agent.agent_id,\n    payload_type=\"TaskRequest\",\n    payload=TaskRequest(conversation_id=\"c\", skill_id=\"echo\", input={}).model_dump(),\n)\nout = agent.handle(req)\n\nassert out is not None\nassert out.payload_type == \"TaskResponse\"\nassert len(agent.requests) == 1\nassert agent.requests_for_skill(\"echo\")[0] == req\n</code></pre> <p>Optional behavior:</p> <ul> <li>Default response: <code>agent.set_default_response(payload)</code> \u2014 used when no skill-specific response is set.</li> <li>Delay: <code>agent.set_delay(0.5)</code> \u2014 sleep (seconds) before returning the response (e.g. for timeout tests).</li> <li>Simulated failure: <code>agent.set_failure(ValueError(\"error\"))</code> \u2014 <code>handle()</code> records the request then raises; failure is cleared after one call.</li> <li>Clear: <code>agent.clear()</code> \u2014 clears recorded requests and all pre-set responses.</li> </ul>"},{"location":"testing/#pytest-fixtures-asaptesting","title":"Pytest Fixtures (asap.testing)","text":"<p>These fixtures are loaded via <code>pytest_plugins</code> in <code>tests/conftest.py</code>. Request them by name in your test parameters.</p> Fixture Type Description <code>mock_agent</code> <code>MockAgent</code> Fresh MockAgent per test. <code>mock_snapshot_store</code> <code>InMemorySnapshotStore</code> Empty in-memory snapshot store per test. <code>mock_client</code> async <code>ASAPClient</code> already entered; use in async tests. Base URL: <code>http://localhost:9999</code>. <p>Example using fixtures:</p> <pre><code>def test_echo_roundtrip(mock_agent: MockAgent) -&gt; None:\n    mock_agent.set_response(\n        \"echo\",\n        TaskResponse(task_id=\"t1\", status=\"completed\").model_dump(),\n    )\n    req = Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:a\",\n        recipient=mock_agent.agent_id,\n        payload_type=\"TaskRequest\",\n        payload=TaskRequest(\n            conversation_id=\"c\", skill_id=\"echo\", input={}\n        ).model_dump(),\n    )\n    out = mock_agent.handle(req)\n    assert out is not None\n    assert_task_completed(out)\n</code></pre>"},{"location":"testing/#context-managers","title":"Context Managers","text":"<p>Use context managers when you want an agent or client scoped to a block, with cleanup on exit.</p> <p><code>test_agent(agent_id=\"urn:asap:agent:mock\")</code> \u2014 yields a <code>MockAgent</code> and calls <code>agent.clear()</code> on exit:</p> <pre><code>from asap.testing.fixtures import test_agent\n\nwith test_agent(\"urn:asap:agent:custom\") as agent:\n    agent.set_response(\"echo\", response_payload)\n    out = agent.handle(req)\n    assert out is not None\n# agent is cleared after the block\n</code></pre> <p><code>test_client(base_url=\"http://localhost:9999\")</code> \u2014 async context manager yielding an open <code>ASAPClient</code>:</p> <pre><code>from asap.testing.fixtures import test_client\n\nasync with test_client(\"http://localhost:8000\") as client:\n    response = await client.send(envelope)\n    assert response is not None\n</code></pre>"},{"location":"testing/#custom-assertions","title":"Custom Assertions","text":"<p>Use these instead of ad-hoc <code>assert</code> logic for envelopes and task status.</p> <p><code>assert_envelope_valid(envelope, require_id=True, require_timestamp=True, allowed_payload_types=None)</code></p> <p>Checks that the envelope has required fields and, optionally, that <code>payload_type</code> is in <code>allowed_payload_types</code>. Fails with clear messages.</p> <pre><code>from asap.testing import assert_envelope_valid\n\nassert_envelope_valid(response_envelope)\nassert_envelope_valid(\n    response_envelope,\n    allowed_payload_types=[\"TaskResponse\", \"TaskUpdate\"],\n)\n</code></pre> <p><code>assert_task_completed(payload, status_key=\"status\", completed_value=\"completed\")</code></p> <p>Asserts that a task response (dict or Envelope) indicates completion. Accepts either a payload dict or an Envelope (uses <code>envelope.payload</code>).</p> <pre><code>from asap.testing import assert_task_completed\n\nassert_task_completed({\"status\": \"completed\"})\nassert_task_completed(response_envelope)  # envelope.payload must have status=completed\n</code></pre> <p><code>assert_response_correlates(request_envelope, response_envelope, correlation_id_field=\"correlation_id\")</code></p> <p>Asserts that the response\u2019s correlation id matches the request\u2019s id.</p> <pre><code>from asap.testing import assert_response_correlates\n\nassert_response_correlates(request_envelope, response_envelope)\n</code></pre>"},{"location":"testing/#reducing-test-boilerplate","title":"Reducing Test Boilerplate","text":"<p>Before (manual setup and assertions):</p> <pre><code>def test_echo_response():\n    agent_id = \"urn:asap:agent:echo\"\n    responses = {}\n    responses[\"echo\"] = {\"task_id\": \"t1\", \"status\": \"completed\"}\n    req = Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:a\",\n        recipient=agent_id,\n        payload_type=\"TaskRequest\",\n        payload={\"conversation_id\": \"c\", \"skill_id\": \"echo\", \"input\": {}},\n    )\n    # ... manual handling and building response envelope ...\n    assert response is not None\n    assert response.payload_type == \"TaskResponse\"\n    assert response.sender == agent_id\n    assert response.payload.get(\"status\") == \"completed\"\n    assert response.correlation_id == req.id\n</code></pre> <p>After (using MockAgent and assertions):</p> <pre><code>def test_echo_response(mock_agent: MockAgent) -&gt; None:\n    mock_agent.set_response(\n        \"echo\",\n        TaskResponse(task_id=\"t1\", status=\"completed\").model_dump(),\n    )\n    req = Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:a\",\n        recipient=mock_agent.agent_id,\n        payload_type=\"TaskRequest\",\n        payload=TaskRequest(\n            conversation_id=\"c\", skill_id=\"echo\", input={}\n        ).model_dump(),\n    )\n    out = mock_agent.handle(req)\n\n    assert_envelope_valid(out, allowed_payload_types=[\"TaskResponse\"])\n    assert_task_completed(out)\n    assert_response_correlates(req, out)\n</code></pre> <p>Using <code>mock_agent</code>, <code>assert_envelope_valid</code>, <code>assert_task_completed</code>, and <code>assert_response_correlates</code> keeps tests shorter and failures easier to interpret.</p>"},{"location":"testing/#how-fixtures-provide-test-isolation","title":"How Fixtures Provide Test Isolation","text":"<p>Fixtures ensure test isolation by: 1. Creating fresh instances: Each test gets its own instances of fixtures 2. Using unique identifiers: UUIDs and unique storage URIs prevent state sharing 3. Replacing global state: Monkeypatch fixtures replace module-level state 4. Automatic cleanup: Pytest automatically cleans up fixtures after tests</p>"},{"location":"testing/#running-tests_1","title":"Running Tests","text":""},{"location":"testing/#basic-commands","title":"Basic Commands","text":"<p>Run all tests:</p> <pre><code>uv run pytest\n</code></pre> <p>Run with coverage:</p> <pre><code>uv run pytest --cov=src --cov-report=term-missing\n</code></pre> <p>Run specific test file:</p> <pre><code>uv run pytest tests/transport/unit/test_bounded_executor.py\n</code></pre> <p>Run specific test class:</p> <pre><code>uv run pytest tests/transport/integration/test_rate_limiting.py::TestRateLimiting\n</code></pre> <p>Run specific test method:</p> <pre><code>uv run pytest tests/transport/unit/test_bounded_executor.py::TestBoundedExecutor::test_submit_task\n</code></pre>"},{"location":"testing/#parallel-execution","title":"Parallel Execution","text":"<p>Run tests in parallel with pytest-xdist:</p> <pre><code># Automatic worker count (recommended)\nuv run pytest -n auto\n\n# Specific number of workers\nuv run pytest -n 4\n\n# With coverage (coverage is aggregated automatically)\nuv run pytest -n auto --cov=src --cov-report=term-missing\n</code></pre> <p>Benefits: - Faster execution on multi-core systems - Complete process-level isolation - Automatic worker count based on CPU cores</p>"},{"location":"testing/#running-by-test-type","title":"Running by Test Type","text":"<p>Run only unit tests:</p> <pre><code>uv run pytest tests/transport/unit/\n</code></pre> <p>Run only integration tests:</p> <pre><code>uv run pytest tests/transport/integration/\n</code></pre> <p>Run only E2E tests:</p> <pre><code>uv run pytest tests/transport/e2e/\n</code></pre>"},{"location":"testing/#verbose-output","title":"Verbose Output","text":"<p>For more detailed output:</p> <pre><code># Verbose mode\nuv run pytest -v\n\n# Very verbose (shows each test name)\nuv run pytest -vv\n\n# Show print statements\nuv run pytest -s\n</code></pre>"},{"location":"testing/#writing-new-tests","title":"Writing New Tests","text":""},{"location":"testing/#choosing-the-right-directory","title":"Choosing the Right Directory","text":"<ol> <li>Unit tests (<code>tests/transport/unit/</code>):</li> <li>Test individual classes/functions</li> <li>No HTTP dependencies</li> <li>No rate limiting dependencies</li> <li> <p>Fast and deterministic</p> </li> <li> <p>Integration tests (<code>tests/transport/integration/</code>):</p> </li> <li>Test component interactions</li> <li>May use HTTP clients</li> <li>Use <code>NoRateLimitTestBase</code> if not testing rate limiting</li> <li> <p>Use aggressive monkeypatch if testing rate limiting</p> </li> <li> <p>E2E tests (<code>tests/transport/e2e/</code>):</p> </li> <li>Test complete workflows</li> <li>Use full stack</li> <li>Inherit from <code>NoRateLimitTestBase</code></li> </ol>"},{"location":"testing/#choosing-the-right-base-class","title":"Choosing the Right Base Class","text":"<p>For non-rate-limiting tests:</p> <pre><code>from tests.transport.conftest import NoRateLimitTestBase\n\nclass TestMyFeature(NoRateLimitTestBase):\n    \"\"\"Tests automatically have rate limiting disabled.\"\"\"\n    pass\n</code></pre> <p>For rate limiting tests:</p> <pre><code># Don't inherit from NoRateLimitTestBase\n# Use aggressive monkeypatch instead\ndef test_rate_limiting(monkeypatch, isolated_limiter_factory):\n    # Manual limiter replacement\n    pass\n</code></pre>"},{"location":"testing/#test-structure","title":"Test Structure","text":"<p>Follow this structure for new tests:</p> <pre><code>\"\"\"Brief description of what this test module covers.\"\"\"\n\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom tests.transport.conftest import NoRateLimitTestBase\n\n\nclass TestMyFeature(NoRateLimitTestBase):\n    \"\"\"Tests for my feature.\"\"\"\n\n    @pytest.fixture\n    def manifest(self) -&gt; Manifest:\n        \"\"\"Create test manifest.\"\"\"\n        return Manifest(...)\n\n    def test_specific_behavior(self, manifest: Manifest) -&gt; None:\n        \"\"\"Test a specific behavior.\"\"\"\n        # Arrange\n        app = create_app(manifest)\n        client = TestClient(app)\n\n        # Act\n        response = client.post(\"/asap\", json={...})\n\n        # Assert\n        assert response.status_code == 200\n        assert response.json()[\"result\"] == expected_value\n</code></pre>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints: All test functions should have type annotations</li> <li>Descriptive names: Test names should clearly describe what they test</li> <li>One assertion per concept: Group related assertions, but test one concept per test</li> <li>Use fixtures: Don't duplicate setup code, use fixtures</li> <li>Isolation: Each test should be independent and runnable in isolation</li> <li>Fast tests: Keep tests fast (&lt; 1 second when possible)</li> <li>Deterministic: Tests should produce the same results every time</li> </ol>"},{"location":"testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"testing/#skipped-tests-brotli","title":"Skipped Tests (Brotli)","text":"<p>Some compression tests are conditional on the optional brotli package:</p> <ul> <li>When brotli is installed (default with <code>uv sync --extra dev</code>): Tests that require brotli run (compress/decompress, server brotli). A few tests that verify the \"brotli unavailable\" path are skipped (they run only in envs without brotli).</li> <li>When brotli is not installed: The brotli-dependent tests are skipped; the \"unavailable\" tests run.</li> </ul> <p>To run all brotli-related tests, install dev dependencies (brotli is in <code>[project.optional-dependencies] dev</code>). The remaining skips are intentional: they assert behavior when brotli is missing.</p>"},{"location":"testing/#tests-failing-with-http-429-rate-limit-exceeded","title":"Tests Failing with HTTP 429 (Rate Limit Exceeded)","text":"<p>Symptom: Tests fail with \"429 Too Many Requests\" even when not testing rate limiting.</p> <p>Solution: 1. Inherit from <code>NoRateLimitTestBase</code>:    <code>python    class TestMyFeature(NoRateLimitTestBase):        pass</code></p> <ol> <li>Or use <code>replace_global_limiter</code> fixture:    <code>python    def test_something(replace_global_limiter):        # Rate limiting is now isolated        pass</code></li> </ol>"},{"location":"testing/#tests-interfering-with-each-other","title":"Tests Interfering with Each Other","text":"<p>Symptom: Tests pass individually but fail when run together.</p> <p>Solution: 1. Ensure tests use isolated fixtures (<code>isolated_limiter_factory</code>, <code>replace_global_limiter</code>) 2. Run with pytest-xdist for process isolation: <code>pytest -n auto</code> 3. Check that rate limiting tests are in <code>test_rate_limiting.py</code> 4. Verify non-rate-limiting tests inherit from <code>NoRateLimitTestBase</code></p>"},{"location":"testing/#slow-test-execution","title":"Slow Test Execution","text":"<p>Solution: 1. Use parallel execution: <code>pytest -n auto</code> 2. Run only relevant tests during development 3. Use <code>pytest --lf</code> to run only failed tests from last run 4. Use <code>pytest --ff</code> to run failed tests first, then others</p>"},{"location":"testing/#ci-integration","title":"CI Integration","text":"<p>Tests run automatically in CI with: - Parallel execution (<code>-n auto</code>) - Coverage reporting - All checks (linting, formatting, type checking, security)</p> <p>See <code>.github/workflows/ci.yml</code> for the complete CI configuration.</p>"},{"location":"transport/","title":"Transport Layer Guide","text":"<p>HTTP/JSON-RPC binding details for ASAP protocol communication.</p>"},{"location":"transport/#overview","title":"Overview","text":"<p>ASAP uses HTTP as the transport layer with JSON-RPC 2.0 as the message framing protocol. This provides:</p> <ul> <li>Standard HTTP semantics: Familiar request/response model</li> <li>JSON-RPC 2.0: Structured RPC with error handling and correlation</li> <li>Agent Discovery: Well-known manifest endpoint for capability discovery</li> </ul>"},{"location":"transport/#endpoints","title":"Endpoints","text":""},{"location":"transport/#post-asap-message-endpoint","title":"POST <code>/asap</code> - Message Endpoint","text":"<p>The primary endpoint for all ASAP protocol messages. Accepts JSON-RPC 2.0 wrapped envelopes.</p>"},{"location":"transport/#request-format","title":"Request Format","text":"<pre><code>POST /asap HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"asap.send\",\n  \"params\": {\n    \"envelope\": {\n      \"asap_version\": \"0.1\",\n      \"sender\": \"urn:asap:agent:coordinator\",\n      \"recipient\": \"urn:asap:agent:research-v1\",\n      \"payload_type\": \"task.request\",\n      \"payload\": {\n        \"conversation_id\": \"conv_01HX5K3MQVN8...\",\n        \"skill_id\": \"web_research\",\n        \"input\": {\n          \"query\": \"Latest AI developments\"\n        }\n      }\n    }\n  },\n  \"id\": \"req-123\"\n}\n</code></pre>"},{"location":"transport/#response-format-success","title":"Response Format (Success)","text":"<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"envelope\": {\n      \"id\": \"env_01HX5K4P...\",\n      \"asap_version\": \"0.1\",\n      \"timestamp\": \"2024-01-15T10:30:00Z\",\n      \"sender\": \"urn:asap:agent:research-v1\",\n      \"recipient\": \"urn:asap:agent:coordinator\",\n      \"payload_type\": \"task.response\",\n      \"payload\": {\n        \"task_id\": \"task_01HX5K4N...\",\n        \"status\": \"completed\",\n        \"result\": {\n          \"summary\": \"Recent AI developments include...\"\n        }\n      },\n      \"correlation_id\": \"env_original_request_id\",\n      \"trace_id\": \"trace_01HX5K...\"\n    }\n  },\n  \"id\": \"req-123\"\n}\n</code></pre>"},{"location":"transport/#response-format-error","title":"Response Format (Error)","text":"<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": {\n      \"error\": \"Missing 'envelope' in params\"\n    }\n  },\n  \"id\": \"req-123\"\n}\n</code></pre> <p>Note: JSON-RPC errors always return HTTP 200. The error is in the response body.</p>"},{"location":"transport/#get-well-knownasapmanifestjson-discovery-endpoint","title":"GET <code>/.well-known/asap/manifest.json</code> - Discovery Endpoint","text":"<p>Returns the agent's manifest describing its capabilities and endpoints.</p>"},{"location":"transport/#request","title":"Request","text":"<pre><code>GET /.well-known/asap/manifest.json HTTP/1.1\nHost: agent.example.com\n</code></pre>"},{"location":"transport/#response","title":"Response","text":"<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": \"urn:asap:agent:research-v1\",\n  \"name\": \"Research Agent\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Performs web research and summarization\",\n  \"capabilities\": {\n    \"asap_version\": \"0.1\",\n    \"skills\": [\n      {\n        \"id\": \"web_research\",\n        \"description\": \"Search and synthesize information from the web\",\n        \"input_schema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"query\": {\"type\": \"string\"}\n          },\n          \"required\": [\"query\"]\n        },\n        \"output_schema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"summary\": {\"type\": \"string\"},\n            \"sources\": {\"type\": \"array\"}\n          }\n        }\n      }\n    ],\n    \"state_persistence\": true,\n    \"streaming\": false,\n    \"mcp_tools\": []\n  },\n  \"endpoints\": {\n    \"asap\": \"https://agent.example.com/asap\",\n    \"events\": null\n  },\n  \"auth\": {\n    \"schemes\": [\"bearer\"],\n    \"oauth2\": null\n  },\n  \"signature\": null\n}\n</code></pre>"},{"location":"transport/#json-rpc-20-specification","title":"JSON-RPC 2.0 Specification","text":"<p>ASAP follows the JSON-RPC 2.0 specification.</p>"},{"location":"transport/#request-object","title":"Request Object","text":"Field Type Required Description <code>jsonrpc</code> string Yes Must be exactly <code>\"2.0\"</code> <code>method</code> string Yes Method name (<code>\"asap.send\"</code>) <code>params</code> object Yes Parameters containing the envelope <code>id</code> string|int Yes Request identifier for correlation"},{"location":"transport/#response-object-success","title":"Response Object (Success)","text":"Field Type Required Description <code>jsonrpc</code> string Yes Must be exactly <code>\"2.0\"</code> <code>result</code> object Yes Response data with envelope <code>id</code> string|int Yes Matches request id"},{"location":"transport/#error-object","title":"Error Object","text":"Field Type Required Description <code>jsonrpc</code> string Yes Must be exactly <code>\"2.0\"</code> <code>error</code> object Yes Error details <code>error.code</code> int Yes Error code (negative integer) <code>error.message</code> string Yes Short description <code>error.data</code> any No Additional error information <code>id</code> string|int|null Yes Matches request id, or null"},{"location":"transport/#error-code-mapping","title":"Error Code Mapping","text":""},{"location":"transport/#standard-json-rpc-errors","title":"Standard JSON-RPC Errors","text":"Code Name Description ASAP Context <code>-32700</code> Parse error Invalid JSON Malformed request body <code>-32600</code> Invalid request Invalid JSON-RPC Missing required fields <code>-32601</code> Method not found Unknown method Method is not <code>asap.send</code> <code>-32602</code> Invalid params Invalid parameters Missing envelope, invalid structure <code>-32603</code> Internal error Server error Unhandled exception"},{"location":"transport/#asap-specific-error-mapping","title":"ASAP-Specific Error Mapping","text":"ASAP Error JSON-RPC Code When <code>MalformedEnvelopeError</code> <code>-32602</code> Invalid envelope structure <code>InvalidTransitionError</code> <code>-32602</code> Invalid state transition <code>TaskNotFoundError</code> <code>-32602</code> Task ID not found <code>TaskAlreadyCompletedError</code> <code>-32602</code> Task in terminal state <code>HandlerNotFoundError</code> <code>-32601</code> No handler for payload type"},{"location":"transport/#error-response-examples","title":"Error Response Examples","text":""},{"location":"transport/#parse-error-32700","title":"Parse Error (-32700)","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32700,\n    \"message\": \"Parse error\",\n    \"data\": {\"error\": \"Expecting property name enclosed in double quotes\"}\n  },\n  \"id\": null\n}\n</code></pre>"},{"location":"transport/#invalid-request-32600","title":"Invalid Request (-32600)","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32600,\n    \"message\": \"Invalid request\",\n    \"data\": {\n      \"validation_errors\": [\n        {\"loc\": [\"method\"], \"msg\": \"Field required\", \"type\": \"missing\"}\n      ]\n    }\n  },\n  \"id\": null\n}\n</code></pre>"},{"location":"transport/#method-not-found-32601","title":"Method Not Found (-32601)","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Method not found\",\n    \"data\": {\"method\": \"asap.unknown\"}\n  },\n  \"id\": \"req-123\"\n}\n</code></pre>"},{"location":"transport/#invalid-params-32602","title":"Invalid Params (-32602)","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": {\n      \"error\": \"Invalid envelope structure\",\n      \"validation_errors\": [\n        {\"loc\": [\"sender\"], \"msg\": \"Field required\", \"type\": \"missing\"}\n      ]\n    }\n  },\n  \"id\": \"req-123\"\n}\n</code></pre>"},{"location":"transport/#internal-error-32603","title":"Internal Error (-32603)","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32603,\n    \"message\": \"Internal error\",\n    \"data\": {\n      \"error\": \"Connection to database failed\",\n      \"type\": \"DatabaseError\"\n    }\n  },\n  \"id\": \"req-123\"\n}\n</code></pre>"},{"location":"transport/#using-the-python-implementation","title":"Using the Python Implementation","text":""},{"location":"transport/#creating-a-server","title":"Creating a Server","text":"<pre><code>from asap.models.entities import Manifest, Capability, Endpoint, Skill\nfrom asap.transport.server import create_app\nfrom asap.transport.handlers import HandlerRegistry\n\n# Define agent manifest\nmanifest = Manifest(\n    id=\"urn:asap:agent:my-agent\",\n    name=\"My Agent\",\n    version=\"1.0.0\",\n    description=\"Example ASAP agent\",\n    capabilities=Capability(\n        asap_version=\"0.1\",\n        skills=[Skill(id=\"echo\", description=\"Echo input back\")],\n        state_persistence=False\n    ),\n    endpoints=Endpoint(asap=\"http://localhost:8000/asap\")\n)\n\n# Create custom handler\ndef my_task_handler(envelope, manifest):\n    # Process TaskRequest and return TaskResponse envelope\n    return create_response_envelope(envelope, result={\"echo\": envelope.payload})\n\n# Register handlers\nregistry = HandlerRegistry()\nregistry.register(\"task.request\", my_task_handler)\n\n# Create FastAPI app\napp = create_app(manifest, registry)\n\n# Run with: uvicorn my_module:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"transport/#creating-a-client","title":"Creating a Client","text":"<pre><code>from asap.transport.client import ASAPClient\nfrom asap.models.envelope import Envelope\n\nasync def send_task_request():\n    async with ASAPClient(base_url=\"http://localhost:8000\") as client:\n        # Create envelope\n        envelope = Envelope(\n            asap_version=\"0.1\",\n            sender=\"urn:asap:agent:client\",\n            recipient=\"urn:asap:agent:server\",\n            payload_type=\"task.request\",\n            payload={\n                \"conversation_id\": \"conv_123\",\n                \"skill_id\": \"echo\",\n                \"input\": {\"message\": \"Hello, ASAP!\"}\n            }\n        )\n\n        # Send and receive response\n        response = await client.send(envelope)\n        print(f\"Response: {response.payload}\")\n</code></pre>"},{"location":"transport/#client-configuration","title":"Client Configuration","text":"<pre><code>from asap.transport.client import ASAPClient\n\n# With custom timeout\nasync with ASAPClient(\n    base_url=\"http://localhost:8000\",\n    timeout=30.0  # 30 seconds\n) as client:\n    response = await client.send(envelope)\n\n# With retry configuration\nasync with ASAPClient(\n    base_url=\"http://localhost:8000\",\n    max_retries=3,\n    retry_delay=1.0  # 1 second between retries\n) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"transport/#retry-configuration","title":"Retry Configuration","text":"<p>The ASAP client implements automatic retry logic with exponential backoff to handle transient failures gracefully. This ensures reliable communication even when network conditions are unstable or servers are temporarily overloaded.</p>"},{"location":"transport/#exponential-backoff-strategy","title":"Exponential Backoff Strategy","text":"<p>The client uses exponential backoff with optional jitter to prevent retry storms and reduce server load:</p> <ul> <li>Base Delay: Initial delay before first retry (default: 1.0 seconds)</li> <li>Exponential Growth: Each retry doubles the delay: <code>base_delay * (2 ** attempt)</code></li> <li>Maximum Delay: Delay is capped at 60 seconds to prevent excessively long waits</li> <li>Jitter: Random component (0-10% of delay) to prevent synchronized retries</li> </ul>"},{"location":"transport/#retry-delay-pattern","title":"Retry Delay Pattern","text":"Attempt Delay (with jitter) Delay (without jitter) 1st retry ~1.0-1.1s 1.0s 2nd retry ~2.0-2.2s 2.0s 3rd retry ~4.0-4.4s 4.0s 4th retry ~8.0-8.8s 8.0s 5th retry ~16.0-17.6s 16.0s 6th retry ~32.0-35.2s 32.0s 7th+ retry ~60.0s (capped) 60.0s (capped)"},{"location":"transport/#configuration","title":"Configuration","text":"<pre><code>from asap.transport.client import ASAPClient\nfrom asap.models.constants import DEFAULT_BASE_DELAY, DEFAULT_MAX_DELAY\n\n# Default configuration (exponential backoff with jitter)\nasync with ASAPClient(\n    base_url=\"https://api.example.com\",\n    max_retries=3,\n    base_delay=1.0,      # 1 second base delay\n    max_delay=60.0,      # Cap at 60 seconds\n    jitter=True          # Add random jitter (default)\n) as client:\n    response = await client.send(envelope)\n\n# Custom backoff configuration\nasync with ASAPClient(\n    base_url=\"https://api.example.com\",\n    max_retries=5,\n    base_delay=2.0,      # Start with 2 seconds\n    max_delay=120.0,    # Cap at 2 minutes\n    jitter=False         # Disable jitter for deterministic delays\n) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"transport/#retriable-errors","title":"Retriable Errors","text":"<p>The client automatically retries on:</p> <ul> <li>5xx Server Errors: HTTP 500, 502, 503, 504 (transient server failures)</li> <li>Connection Errors: Network failures, DNS errors, connection timeouts</li> <li>429 Too Many Requests: Rate limit responses (with <code>Retry-After</code> header support)</li> </ul> <p>The client does not retry on:</p> <ul> <li>4xx Client Errors: HTTP 400, 401, 403, 404 (client-side issues)</li> <li>Circuit Breaker Open: When circuit breaker is enabled and circuit is open</li> </ul>"},{"location":"transport/#retry-after-header-support","title":"Retry-After Header Support","text":"<p>When the server returns HTTP 429 (Too Many Requests) with a <code>Retry-After</code> header, the client respects the server-suggested delay instead of using the calculated exponential backoff:</p> <pre><code># Server response includes: Retry-After: 45\n# Client will wait 45 seconds before retrying, regardless of backoff calculation\n</code></pre> <p>This ensures proper integration with rate limiting systems and prevents unnecessary retry attempts.</p>"},{"location":"transport/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>For production deployments with high failure rates, you can enable the circuit breaker pattern to prevent cascading failures:</p> <pre><code>from asap.transport.client import ASAPClient\nfrom asap.models.constants import (\n    DEFAULT_CIRCUIT_BREAKER_THRESHOLD,\n    DEFAULT_CIRCUIT_BREAKER_TIMEOUT,\n)\n\n# Enable circuit breaker\nasync with ASAPClient(\n    base_url=\"https://api.example.com\",\n    circuit_breaker_enabled=True,\n    circuit_breaker_threshold=5,      # Open after 5 consecutive failures\n    circuit_breaker_timeout=60.0      # Wait 60s before half-open test\n) as client:\n    try:\n        response = await client.send(envelope)\n    except CircuitOpenError as e:\n        # Circuit is open, service is unavailable\n        print(f\"Circuit breaker is open: {e.message}\")\n</code></pre>"},{"location":"transport/#circuit-breaker-states","title":"Circuit Breaker States","text":"<ul> <li>CLOSED: Normal operation, all requests allowed</li> <li>OPEN: Circuit is open, requests rejected immediately (raises <code>CircuitOpenError</code>)</li> <li>HALF_OPEN: Testing state, allows one request to test if service recovered</li> </ul>"},{"location":"transport/#when-to-use-circuit-breaker","title":"When to Use Circuit Breaker","text":"<p>Enable circuit breaker when:</p> <ul> <li>High Failure Rates: Service experiences frequent failures</li> <li>Cascading Failures: Failures in one service impact others</li> <li>Resource Protection: Need to prevent overwhelming a failing service</li> <li>Fast Failure: Want immediate feedback instead of waiting for retries</li> </ul>"},{"location":"transport/#circuit-breaker-configuration","title":"Circuit Breaker Configuration","text":"Parameter Default Description <code>circuit_breaker_enabled</code> <code>False</code> Enable circuit breaker pattern <code>circuit_breaker_threshold</code> <code>5</code> Consecutive failures before opening <code>circuit_breaker_timeout</code> <code>60.0</code> Seconds before transitioning OPEN \u2192 HALF_OPEN"},{"location":"transport/#best-practices","title":"Best Practices","text":"<ol> <li>Default Settings: Use default exponential backoff for most use cases</li> <li>Adjust Max Retries: Increase <code>max_retries</code> for critical operations, decrease for low-priority tasks</li> <li>Enable Circuit Breaker: Use circuit breaker for production deployments with multiple services</li> <li>Monitor Retry Metrics: Track retry attempts and failure rates to identify issues</li> <li>Respect Rate Limits: The client automatically respects <code>Retry-After</code> headers from rate-limited responses</li> </ol>"},{"location":"transport/#example-complete-retry-configuration","title":"Example: Complete Retry Configuration","text":"<pre><code>from asap.transport.client import ASAPClient\nfrom asap.errors import CircuitOpenError, ASAPConnectionError\n\nasync def send_with_retry(envelope):\n    \"\"\"Send envelope with comprehensive retry configuration.\"\"\"\n    async with ASAPClient(\n        base_url=\"https://api.example.com\",\n        timeout=30.0,\n        max_retries=5,\n        base_delay=1.0,\n        max_delay=60.0,\n        jitter=True,\n        circuit_breaker_enabled=True,\n        circuit_breaker_threshold=5,\n        circuit_breaker_timeout=60.0,\n    ) as client:\n        try:\n            response = await client.send(envelope)\n            return response\n        except CircuitOpenError:\n            # Circuit is open, service unavailable\n            return None\n        except ASAPConnectionError as e:\n            # Connection failed after all retries\n            print(f\"Connection failed: {e.message}\")\n            raise\n</code></pre>"},{"location":"transport/#manifest-schema-reference","title":"Manifest Schema Reference","text":""},{"location":"transport/#manifest-object","title":"Manifest Object","text":"Field Type Required Description <code>id</code> string Yes Agent URN (<code>urn:asap:agent:{name}</code>) <code>name</code> string Yes Human-readable name <code>version</code> string Yes Semantic version (e.g., <code>\"1.0.0\"</code>) <code>description</code> string Yes Agent description <code>capabilities</code> Capability Yes Agent capabilities <code>endpoints</code> Endpoint Yes Communication endpoints <code>auth</code> AuthScheme No Authentication configuration <code>signature</code> string No Manifest signature for verification"},{"location":"transport/#capability-object","title":"Capability Object","text":"Field Type Required Description <code>asap_version</code> string Yes ASAP protocol version <code>skills</code> Skill[] Yes Available skills <code>state_persistence</code> boolean Yes Supports snapshots <code>streaming</code> boolean Yes Supports streaming <code>mcp_tools</code> string[] Yes Available MCP tools"},{"location":"transport/#skill-object","title":"Skill Object","text":"Field Type Required Description <code>id</code> string Yes Unique skill identifier <code>description</code> string Yes Skill description <code>input_schema</code> object No JSON Schema for input <code>output_schema</code> object No JSON Schema for output"},{"location":"transport/#endpoint-object","title":"Endpoint Object","text":"Field Type Required Description <code>asap</code> string Yes HTTP endpoint for messages <code>events</code> string No WebSocket for streaming"},{"location":"transport/#authscheme-object","title":"AuthScheme Object","text":"Field Type Required Description <code>schemes</code> string[] Yes Supported auth methods <code>oauth2</code> object No OAuth2 configuration"},{"location":"transport/#testing-with-curl","title":"Testing with cURL","text":""},{"location":"transport/#discover-agent","title":"Discover Agent","text":"<pre><code>curl -s http://localhost:8000/.well-known/asap/manifest.json | jq .\n</code></pre>"},{"location":"transport/#send-task-request","title":"Send Task Request","text":"<pre><code>curl -X POST http://localhost:8000/asap \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"asap.send\",\n    \"params\": {\n      \"envelope\": {\n        \"asap_version\": \"0.1\",\n        \"sender\": \"urn:asap:agent:test-client\",\n        \"recipient\": \"urn:asap:agent:default-server\",\n        \"payload_type\": \"task.request\",\n        \"payload\": {\n          \"conversation_id\": \"conv_test\",\n          \"skill_id\": \"echo\",\n          \"input\": {\"message\": \"Hello!\"}\n        }\n      }\n    },\n    \"id\": \"test-1\"\n  }' | jq .\n</code></pre>"},{"location":"transport/#check-server-health","title":"Check Server Health","text":"<pre><code># Start server\nuvicorn asap.transport.server:app --host 0.0.0.0 --port 8000\n\n# Test manifest endpoint\ncurl -I http://localhost:8000/.well-known/asap/manifest.json\n# Expected: HTTP/1.1 200 OK\n</code></pre>"},{"location":"transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security - Authentication and TLS</li> <li>Error Handling - Error taxonomy</li> <li>Observability - Logging and tracing</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and fix common issues when running ASAP agents in development or production. Use it together with Error Handling, Observability, and Deployment (Kubernetes).</p>"},{"location":"troubleshooting/#common-errors","title":"Common Errors","text":"<p>This section lists the most frequent errors you may encounter, with cause and solution. For the full error taxonomy, see Error Handling. All ASAP protocol errors use the code format <code>asap:&lt;domain&gt;/&lt;error&gt;</code>.</p>"},{"location":"troubleshooting/#error-cause-solution","title":"Error \u2192 Cause \u2192 Solution","text":"# Error Cause Solution 1 InvalidTransitionError (<code>asap:protocol/invalid_state</code>) Task state transition not allowed by the state machine (e.g. <code>submitted</code> \u2192 <code>completed</code> without <code>running</code>). Ensure transitions follow the defined state machine; use <code>running</code> before <code>completed</code>/<code>failed</code>. 2 MalformedEnvelopeError (<code>asap:protocol/malformed_envelope</code>) Envelope missing required fields, wrong types, or invalid structure. Validate envelope with Pydantic before sending; check <code>task_id</code>, <code>sender</code>, <code>payload</code>, timestamps. 3 TaskNotFoundError (<code>asap:task/not_found</code>) Requested task ID does not exist or was never created. Verify <code>task_id</code> is correct and the task was created on the target agent; check for typos or wrong agent. 4 TaskAlreadyCompletedError (<code>asap:task/already_completed</code>) Update attempted on a task already in a terminal state (<code>completed</code> or <code>failed</code>). Do not send updates for completed tasks; create a new task if you need a new unit of work. 5 ThreadPoolExhaustedError (<code>asap:transport/thread_pool_exhausted</code>) All worker threads are busy; server cannot accept more synchronous handler work. Increase <code>max_threads</code> in server config (or <code>ASAP_MAX_THREADS</code>), optimize slow handlers, or use async handlers. 6 InvalidTimestampError (<code>asap:protocol/invalid_timestamp</code>) Envelope timestamp too old (replay) or too far in the future (clock skew). Sync clocks (NTP); ensure envelope is sent within the allowed time window (see server config). 7 InvalidNonceError (<code>asap:protocol/invalid_nonce</code>) Duplicate or invalid nonce (replay attack prevention). Generate a unique nonce per envelope; do not reuse nonces within the TTL window. 8 CircuitOpenError (<code>asap:transport/circuit_open</code>) Circuit breaker opened after consecutive failures; requests are rejected. Wait for circuit timeout or fix remote service; check connectivity and remote agent health. 9 UnsupportedAuthSchemeError (<code>asap:auth/unsupported_scheme</code>) Manifest specifies an auth scheme the client does not support. Use a supported scheme (e.g. <code>Bearer</code>) or extend the client to support the required scheme. 10 ASAPConnectionError HTTP connection failed: agent down, wrong URL, network/firewall, or TLS issues. Verify agent is running, URL scheme and port, network/firewall, and SSL certificates. 11 ASAPTimeoutError Request exceeded the configured timeout. Increase client <code>timeout</code>; optimize slow handlers or network; consider smaller payloads or streaming. 12 ASAPRemoteError Remote agent returned a JSON-RPC error (code, message, data). Inspect <code>code</code> and <code>data</code>; fix request (envelope/params) or fix the remote agent implementation. 13 HandlerNotFoundError (<code>asap:transport/handler_not_found</code>) No handler registered for the payload type (e.g. <code>task.request</code>). Register a handler for that payload type in <code>HandlerRegistry</code> before processing requests. 14 JSON-RPC INVALID_REQUEST (-32600) Malformed JSON-RPC request (invalid JSON or missing <code>jsonrpc</code>/<code>method</code>/<code>id</code>). Ensure request is valid JSON-RPC 2.0; include <code>jsonrpc</code>, <code>method</code>, <code>id</code>, and <code>params</code> where required. 15 JSON-RPC INVALID_PARAMS (-32602) Invalid <code>params</code> (e.g. envelope validation failed). Validate envelope structure and types before sending; check server logs for validation details. 16 JSON-RPC METHOD_NOT_FOUND (-32601) Unknown method or payload type. Use a supported method/payload type; ensure client and server versions and APIs are compatible. 17 JSON-RPC INTERNAL_ERROR (-32603) Unexpected server-side exception. Check server logs and traces; fix bug in handler or server code; report if persistent. 18 Pydantic ValidationError Envelope or model validation failed when building/serializing. Fix field types and required fields; use <code>model_dump()</code>/<code>model_validate()</code> and handle validation in code. 19 Connection refused / OSError TCP connection to host:port failed (e.g. nothing listening). Start the agent; confirm host and port; check firewall and security groups. 20 Path traversal / security Invalid or suspicious <code>FilePart</code> URI (e.g. <code>../</code> outside allowed base). Use only allowed URIs; ensure server validates paths and rejects traversal attempts."},{"location":"troubleshooting/#example-stack-traces","title":"Example stack traces","text":"<p>InvalidTransitionError (state machine):</p> <pre><code>asap.errors.InvalidTransitionError: Invalid transition from 'submitted' to 'completed'\n\n  details: {\"from_state\": \"submitted\", \"to_state\": \"completed\"}\n  code: asap:protocol/invalid_state\n</code></pre> <p>Fix: Transition through <code>running</code> (e.g. <code>submitted</code> \u2192 <code>running</code> \u2192 <code>completed</code>).</p> <p>ASAPConnectionError (agent unreachable):</p> <pre><code>asap.transport.client.ASAPConnectionError: Connection failed to http://localhost:8000.\nTroubleshooting: Connection failed to http://localhost:8000. Verify the agent is running...\n  url: http://localhost:8000\n  cause: [Errno 61] Connection refused\n</code></pre> <p>Fix: Start the agent on the given URL or correct the URL/port.</p>"},{"location":"troubleshooting/#chaos-failure-modes","title":"Chaos Failure Modes","text":"<p>This section describes failure modes validated by chaos testing (Sprint 8). It helps you tell network vs agent issues and what to expect in logs. See ADR-017 Failure Injection and Building Resilient Agents.</p>"},{"location":"troubleshooting/#scenarios-from-chaos-tests","title":"Scenarios from chaos tests","text":"Scenario What is simulated Expected client behavior Typical error / log Message loss Response never arrives (black hole, dropped response) Retries up to <code>max_retries</code>, then raises <code>ASAPTimeoutError</code> <code>Request to ... timed out after N seconds</code> Intermittent loss Some requests succeed, some time out Retries; eventual success or <code>ASAPTimeoutError</code> after retries Mix of success logs and timeout on final attempt Network partition Connection refused or unreachable Retries with backoff, then <code>ASAPConnectionError</code> <code>Connection failed to ... Connection refused</code> Circuit open Many consecutive failures Client stops sending, raises <code>CircuitOpenError</code> <code>Circuit breaker is OPEN for ... Too many consecutive failures</code> Clock skew (old) Envelope timestamp too old Server rejects with <code>InvalidTimestampError</code> <code>asap:protocol/invalid_timestamp</code>, <code>age_seconds</code> in details Clock skew (future) Envelope timestamp in the future Server rejects with <code>InvalidTimestampError</code> <code>asap:protocol/invalid_timestamp</code>, <code>future_offset_seconds</code> in details Server crash Server dies mid-request (connection reset) Retries, then <code>ASAPConnectionError</code> (e.g. \"Connection reset by peer\") <code>Connection reset by peer</code> or <code>Connection failed</code> Server 503 Server shutting down or overloaded Retries; may eventually get response or timeout/connection error HTTP 503 in logs; client retries then may raise <code>ASAPConnectionError</code> or succeed"},{"location":"troubleshooting/#expected-logs-vs-actual-failures","title":"Expected logs vs actual failures","text":"<p>When the network drops the response (message loss):</p> <ul> <li>Expected: Client logs retries, then a single final timeout.</li> <li>Actual failure: You see <code>ASAPTimeoutError</code> with <code>timeout</code> set; no response body. Server logs may show the request as received and processed\u2014so the agent is fine, the network or path back to the client dropped the response.</li> </ul> <p>When the agent is down or unreachable (partition/crash):</p> <ul> <li>Expected: Connection errors, possibly retries then <code>ASAPConnectionError</code> or <code>CircuitOpenError</code>.</li> <li>Actual failure: <code>ASAPConnectionError</code> with cause like \"Connection refused\" or \"Connection reset by peer\". Server logs may show nothing (crashed) or \"connection closed\". So the network path or the agent is the problem.</li> </ul> <p>When clocks are wrong (clock skew):</p> <ul> <li>Expected: Server rejects envelope with <code>InvalidTimestampError</code>; client gets <code>ASAPRemoteError</code> with code/data indicating <code>asap:protocol/invalid_timestamp</code>.</li> <li>Actual failure: No retry will fix this; agent logic is fine, clock sync (NTP, container time) is wrong on sender or receiver.</li> </ul>"},{"location":"troubleshooting/#is-it-the-network-or-the-agent","title":"Is it the network or the agent?","text":"Symptom Likely cause What to check <code>ASAPTimeoutError</code> after retries, server log shows \"request received\" Network (response path): response lost or very slow Client/server network path, load balancer timeouts, proxy. <code>ASAPConnectionError</code> (refused, reset, unreachable) Network or agent: server down, partition, or crash Agent process up? Port open? Firewall? Restart/crash logs on server. <code>CircuitOpenError</code> Network or agent: many consecutive failures Check why each request failed (timeout vs connection vs 5xx). Fix agent or network, then wait for circuit to half-open. <code>InvalidTimestampError</code> / <code>InvalidNonceError</code> Agent/config: bad clock or duplicate nonce NTP on both sides; single source of nonces per sender. <code>ASAPRemoteError</code> with <code>asap:task/not_found</code> or <code>asap:protocol/...</code> Agent: business or protocol error on server Server logs and error <code>data</code>; fix handler or request. <code>HandlerNotFoundError</code> or JSON-RPC <code>METHOD_NOT_FOUND</code> Agent: payload type not registered or wrong method Register handler for that payload type or fix client method/params. <p>Use trace_id and correlation_id in logs on both client and server to match a single request across the path and see whether the server saw it and how it responded.</p>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":"<p>Use this checklist and the tools below to debug ASAP issues systematically. See Observability and Metrics for configuration details.</p>"},{"location":"troubleshooting/#step-by-step-debugging-checklist","title":"Step-by-step debugging checklist","text":"<ol> <li>Reproduce the issue</li> <li>Note the exact operation (e.g. <code>client.send(envelope)</code>, specific payload type).</li> <li>Capture the full error message, exception type, and stack trace.</li> <li> <p>If intermittent, try to reproduce under load or with the same sequence of requests.</p> </li> <li> <p>Check server and client logs</p> </li> <li>Enable structured logs (JSON in production) and set <code>ASAP_LOG_LEVEL=DEBUG</code> if needed.</li> <li>Look for <code>asap.request.received</code>, <code>asap.request.processed</code>, and any <code>error</code> or <code>exception</code> entries.</li> <li> <p>Match requests across services using <code>trace_id</code> and <code>correlation_id</code> (see Observability).</p> </li> <li> <p>Correlate with trace_id / correlation_id</p> </li> <li>Extract <code>trace_id</code> from the failing request (envelope or log line).</li> <li>Search server logs for the same <code>trace_id</code> to see if the request arrived and how it was processed.</li> <li> <p>If the server never logged the request, the failure is likely network or client-side. If the server logged an error, focus on agent/handler logic.</p> </li> <li> <p>Inspect metrics</p> </li> <li>Query <code>/asap/metrics</code> on the agent: <code>curl http://&lt;agent&gt;:8000/asap/metrics</code>.</li> <li>Check <code>asap_requests_error_total</code> by <code>error_type</code> and <code>payload_type</code>.</li> <li>Check <code>asap_request_duration_seconds</code> for latency spikes or timeouts.</li> <li> <p>Compare with Chaos Failure Modes to see if the pattern matches network vs agent.</p> </li> <li> <p>Visualize request flow (trace command)</p> </li> <li>If logs are in ASAP JSON format, use the CLI to visualize a single trace:</li> <li><code>asap trace &lt;trace-id&gt; [--log-file asap.log] [--format ascii|json]</code></li> <li> <p>This shows request flow and latency per hop (e.g. <code>agent_a -&gt; agent_b (15ms) -&gt; agent_c (23ms)</code>).</p> </li> <li> <p>Classify the failure</p> </li> <li>Use the table Is it the network or the agent? in Chaos Failure Modes.</li> <li>Apply the suggested checks (URL, firewall, handler registration, clock sync, etc.).</li> </ol>"},{"location":"troubleshooting/#tools","title":"Tools","text":"Tool Purpose Reference Structured logs Request/response events, errors, trace context Observability; <code>ASAP_LOG_LEVEL</code>, <code>ASAP_LOG_FORMAT</code> trace_id / correlation_id Correlate a request across client and server Observability; bind in logs and search by ID asap trace (CLI) Visualize request flow and latency from JSON logs <code>asap trace &lt;trace-id&gt; --log-file asap.log</code> Metrics Counts and latency histograms per payload type and error type Metrics; <code>GET /asap/metrics</code> Health endpoints Agent liveness and readiness <code>GET /health</code>, <code>GET /ready</code>; see Deployment (Kubernetes)"},{"location":"troubleshooting/#example-debugging-a-timeout","title":"Example: debugging a timeout","text":"<p>Symptom: Client raises <code>ASAPTimeoutError</code> after 30 seconds.</p> <ol> <li>Reproduce: Same envelope, same agent URL; happens every time (or only under load).</li> <li>Logs: Client log shows retries and final timeout. Search server logs for the client\u2019s <code>trace_id</code>.</li> <li>If server log has the request: Server received it; slow handler or overload. Check <code>asap_request_duration_seconds</code> and handler code. Consider increasing timeout or optimizing the handler.</li> <li>If server log has no request: Request never reached the server (network, LB, or wrong URL). Check URL, firewall, and agent reachability.</li> <li>Metrics: High <code>asap_request_duration_seconds</code> or many timeouts in <code>asap_requests_error_total</code> suggest server-side slowness or overload.</li> </ol>"},{"location":"troubleshooting/#example-debugging-connection-refused","title":"Example: debugging \"Connection refused\"","text":"<p>Symptom: <code>ASAPConnectionError</code> with \"Connection refused\".</p> <ol> <li>Reproduce: Note the exact URL (host and port).</li> <li>Check agent: Is the process running? <code>curl -I http://&lt;host&gt;:&lt;port&gt;/health</code>. If 200, the agent is up; then check path (e.g. correct port and no typo in URL).</li> <li>Check network: From the client host, <code>curl http://&lt;host&gt;:&lt;port&gt;/health</code>. If this fails, the issue is network or firewall, not application code.</li> <li>Logs: Server may have no log for the request (connection never established). Fix connectivity or URL, then retry.</li> </ol>"},{"location":"troubleshooting/#example-debugging-invalidtransitionerror","title":"Example: debugging InvalidTransitionError","text":"<p>Symptom: <code>InvalidTransitionError: Invalid transition from 'submitted' to 'completed'</code>.</p> <ol> <li>Reproduce: Same sequence of payloads (e.g. sending a task update without a prior \"running\" update).</li> <li>Classify: This is an agent/protocol error: the state machine disallows that transition.</li> <li>Fix: Ensure state transitions follow the model (e.g. <code>submitted</code> \u2192 <code>running</code> \u2192 <code>completed</code>). Check client or orchestrator logic that sends status updates.</li> <li>Logs: Server log should show the invalid transition; use <code>trace_id</code> to find the exact request and payload.</li> </ol>"},{"location":"troubleshooting/#performance-tuning","title":"Performance Tuning","text":"<p>This section covers connection pools, manifest caching, compression, and batch operations. For full benchmark results, see benchmarks/RESULTS.md in the repository, or run <code>uv run pytest benchmarks/benchmark_transport.py --benchmark-only -v</code>.</p>"},{"location":"troubleshooting/#connection-pools","title":"Connection pools","text":"<p>The ASAP client uses httpx connection pooling. Tuning pool size improves throughput when you have many concurrent requests to the same agent.</p> Parameter Default When to increase pool_connections 100 More idle keep-alive connections; use 200\u2013500 for small clusters. pool_maxsize 100 More concurrent connections; use 500\u20131000 for large clusters if OS limits allow. pool_timeout 5.0 Increase if you see pool timeout errors under load (e.g. 30.0). <p>Before/after: With default <code>pool_maxsize=100</code>, the client supports 1000+ concurrent requests to the same host via connection reuse (benchmark: 1000 concurrent <code>send()</code> all succeed). Without pooling, each request would open a new connection and latency would increase under load.</p> <pre><code># Higher concurrency (e.g. many workers calling same agent)\nasync with ASAPClient(\n    base_url=\"https://api.example.com\",\n    pool_connections=200,\n    pool_maxsize=200,\n    pool_timeout=30.0,\n) as client:\n    ...\n</code></pre> <p>Keep HTTP/2 enabled (default) for multiplexing; it improves batch throughput.</p>"},{"location":"troubleshooting/#manifest-caching","title":"Manifest caching","text":"<p>The client caches agent manifests in memory with a TTL to avoid repeated GETs to <code>/.well-known/asap/manifest.json</code>.</p> Setting Default Effect default_ttl 300 s (5 min) Longer TTL = fewer manifest requests, slightly staler manifest. <p>Before/after: With caching, repeated <code>get_manifest()</code> calls for the same URL yield &gt;90% cache hit rate (benchmark: 99% with 100 requests). Without cache, every call would trigger an HTTP GET.</p> <p>Increase TTL if agents change manifest rarely; shorten it if you need quick reflection of manifest changes.</p>"},{"location":"troubleshooting/#compression","title":"Compression","text":"<p>Requests and responses can be compressed (gzip or Brotli) when the payload exceeds 1 KB (configurable). This reduces bandwidth and can help on slow or costly links.</p> Setting Default Effect COMPRESSION_THRESHOLD 1024 (1 KB) Payloads smaller than this are sent uncompressed. Algorithm gzip (br if available) Brotli typically gives 10\u201320% better ratio than gzip for JSON. <p>Before/after (benchmarks):</p> <ul> <li>1 MB JSON payload: gzip achieves ~70% size reduction (compressed \u226430% of original); Brotli often 10\u201320% better.</li> <li>Large envelopes: End-to-end compress \u2192 decompress \u2192 deserialize is benchmarked; enable compression for large payloads to cut bandwidth.</li> </ul> <p>Ensure the server supports <code>Content-Encoding: gzip</code> (or <code>br</code>); the ASAP server decompresses automatically.</p>"},{"location":"troubleshooting/#batch-operations","title":"Batch operations","text":"<p>Use <code>send_batch()</code> instead of sequential <code>send()</code> when you have many envelopes for the same or multiple agents.</p> <p>Before/after: With real HTTP/2, batch send gives roughly 10x throughput vs sequential <code>send()</code> (benchmark target). With in-process or mock transport the speedup is lower; the gain is largest when network latency is significant.</p> <pre><code># Prefer batch when sending many envelopes\nresults = await client.send_batch(envelopes)  # parallel over HTTP/2\n</code></pre>"},{"location":"troubleshooting/#quick-reference-tuning-checklist","title":"Quick reference: tuning checklist","text":"Goal Action Higher throughput to one agent Increase <code>pool_maxsize</code>; keep HTTP/2 on; use <code>send_batch()</code> where applicable. Fewer manifest round-trips Rely on default cache (5 min TTL); increase TTL if manifests change rarely. Lower bandwidth Use default compression (auto for payloads &gt;1 KB); install <code>brotli</code> for better ratio. Lower latency under load Horizontal scaling (multiple server instances); see Deployment (Kubernetes)."},{"location":"troubleshooting/#faq","title":"FAQ","text":"<p>Frequently asked questions grouped by category. For more detail, see the linked guides.</p>"},{"location":"troubleshooting/#setup","title":"Setup","text":"<p>Q: How do I install ASAP? A: <code>uv add asap-protocol</code> or <code>pip install asap-protocol</code>. See index.</p> <p>Q: What Python version is required? A: Python 3.13+. See ADR-010 Python 3.13+.</p> <p>Q: How do I run my first agent? A: Follow Building Your First Agent: create a server with a handler, then use <code>ASAPClient</code> to send envelopes.</p> <p>Q: How do I start the ASAP server? A: <code>uv run uvicorn asap.transport.server:app --host 0.0.0.0 --port 8000</code>. Or use <code>create_app()</code> and mount it in your own ASGI app.</p> <p>Q: Can I use ASAP over HTTP (not HTTPS)? A: Yes for local development. Set <code>require_https=False</code> on the client. In production use HTTPS; see Security.</p> <p>Q: How do I deploy ASAP in Kubernetes? A: See Deployment (Kubernetes): Dockerfile, k8s manifests, Helm chart, health checks.</p> <p>Q: Where is the agent manifest? A: <code>GET /.well-known/asap/manifest.json</code> on the agent base URL. The client uses it for discovery.</p> <p>Q: How do I register a handler for a payload type? A: Use <code>HandlerRegistry.register(payload_type, handler)</code> before starting the server. Unregistered types raise <code>HandlerNotFoundError</code>.</p> <p>Q: Can I use ASAP with FastAPI/Starlette? A: Yes. The ASAP server is FastAPI-based; you can mount it or reuse its <code>create_app()</code> and add your own routes.</p> <p>Q: How do I run the CLI? A: <code>asap --version</code>, <code>asap list-schemas</code>, <code>asap trace &lt;trace-id&gt; [--log-file PATH]</code>. See index.</p>"},{"location":"troubleshooting/#config","title":"Config","text":"<p>Q: What environment variables does ASAP use? A: Server: <code>ASAP_RATE_LIMIT</code>, <code>ASAP_MAX_REQUEST_SIZE</code>, <code>ASAP_MAX_THREADS</code>, <code>ASAP_HOT_RELOAD</code>, <code>ASAP_DEBUG</code>. Logging: <code>ASAP_LOG_LEVEL</code>, <code>ASAP_LOG_FORMAT</code>, <code>ASAP_SERVICE_NAME</code>, <code>ASAP_DEBUG</code>, <code>ASAP_DEBUG_LOG</code>. See Observability and server docstrings.</p> <p>Q: How do I increase the rate limit? A: Set <code>ASAP_RATE_LIMIT</code> (e.g. <code>100/second;1000/minute</code>) or pass <code>rate_limit</code> to <code>create_app()</code>. See Security.</p> <p>Q: How do I enable debug logging? A: <code>ASAP_LOG_LEVEL=DEBUG</code>. For full request/response bodies use <code>ASAP_DEBUG_LOG=true</code> (development only). For full data and stack traces use <code>ASAP_DEBUG=true</code>.</p> <p>Q: How do I increase the request size limit? A: Set <code>ASAP_MAX_REQUEST_SIZE</code> (bytes) or pass <code>max_request_size</code> to <code>create_app()</code>. Default is 10 MB.</p> <p>Q: How do I increase the number of worker threads? A: Set <code>ASAP_MAX_THREADS</code> or pass <code>max_threads</code> to <code>create_app()</code>. Default is <code>min(32, cpu_count + 4)</code>.</p> <p>Q: How do I tune the connection pool? A: Pass <code>pool_connections</code>, <code>pool_maxsize</code>, <code>pool_timeout</code> to <code>ASAPClient</code>. See Performance Tuning above.</p> <p>Q: How do I change the client timeout? A: Pass <code>timeout=&lt;seconds&gt;</code> to <code>ASAPClient</code>. Default is 60.0.</p> <p>Q: How do I configure retries? A: Use <code>RetryConfig</code> and pass it to <code>ASAPClient(retry_config=...)</code>. See Building Resilient Agents.</p> <p>Q: How do I enable or disable the circuit breaker? A: Pass <code>circuit_breaker_enabled=True/False</code> to <code>ASAPClient</code>. You can also set threshold and timeout.</p> <p>Q: How long is the manifest cached? A: Default TTL is 5 minutes (300 s). The client uses an in-memory cache; TTL is configurable on the cache.</p> <p>Q: How do I allow HTTP in production? A: Not recommended. Use HTTPS. For local-only agents you can set <code>require_https=False</code> on the client.</p>"},{"location":"troubleshooting/#errors","title":"Errors","text":"<p>Q: What does InvalidTransitionError mean? A: You tried an invalid task state transition (e.g. <code>submitted</code> \u2192 <code>completed</code>). Use allowed transitions (e.g. <code>submitted</code> \u2192 <code>running</code> \u2192 <code>completed</code>). See Common Errors.</p> <p>Q: What does MalformedEnvelopeError mean? A: The envelope is invalid (missing fields, wrong types). Validate with Pydantic before sending.</p> <p>Q: What does TaskNotFoundError mean? A: The requested task ID does not exist on the agent. Check <code>task_id</code> and that the task was created on the right agent.</p> <p>Q: What does ASAPConnectionError mean? A: The HTTP connection failed (agent down, wrong URL, network/firewall). See Error Handling and Common Errors.</p> <p>Q: What does ASAPTimeoutError mean? A: The request took longer than the client timeout. Increase <code>timeout</code> or optimize the handler/network.</p> <p>Q: What does CircuitOpenError mean? A: The circuit breaker opened after consecutive failures. Wait for the timeout or fix the remote service; see Chaos Failure Modes.</p> <p>Q: What does InvalidTimestampError mean? A: Envelope timestamp is too old (replay) or too far in the future (clock skew). Sync clocks (NTP) and stay within the allowed window.</p> <p>Q: What does InvalidNonceError mean? A: Duplicate or invalid nonce (replay protection). Use a unique nonce per envelope; do not reuse within the TTL window.</p> <p>Q: What does HandlerNotFoundError mean? A: No handler is registered for that payload type. Register one with <code>HandlerRegistry.register(payload_type, handler)</code>.</p> <p>Q: What does ThreadPoolExhaustedError mean? A: All server worker threads are busy. Increase <code>max_threads</code> or optimize/use async handlers.</p> <p>Q: How do I know if the failure is network or agent? A: Use the table Is it the network or the agent? in Chaos Failure Modes and correlate logs with <code>trace_id</code>/<code>correlation_id</code>.</p> <p>Q: Why do I get JSON-RPC INVALID_PARAMS? A: The server rejected the envelope (validation failed). Check envelope structure and server logs for details.</p>"},{"location":"troubleshooting/#best-practices","title":"Best practices","text":"<p>Q: Should I set trace_id and correlation_id? A: Yes. They help correlate requests across client and server. Bind them in logs; see Observability.</p> <p>Q: Should I use retries? A: Yes for transient failures. Use <code>RetryConfig</code> and optionally a circuit breaker. See Building Resilient Agents.</p> <p>Q: When should I use send_batch()? A: When sending many envelopes to one or more agents; it improves throughput with HTTP/2. See Performance Tuning.</p> <p>Q: When is compression used? A: Automatically for payloads larger than 1 KB (configurable). Use default settings for large payloads to reduce bandwidth.</p> <p>Q: How do I secure tokens in logs? A: Do not set <code>ASAP_DEBUG</code>/<code>ASAP_DEBUG_LOG</code> in production; sensitive fields are redacted unless debug is on. See Observability.</p> <p>Q: What rate limit should I use in production? A: Depends on load. Default <code>10/second;100/minute</code> allows bursts; for high throughput use a higher limit (e.g. from benchmarks). See Security.</p> <p>Q: How do I monitor ASAP in production? A: Use <code>/asap/metrics</code> (Prometheus), <code>/health</code> and <code>/ready</code>, and structured logs with trace_id. See Metrics and Deployment.</p> <p>Q: Where can I find a production checklist? A: See Production Deployment Checklist.</p> <p>Q: How do I test resilience? A: Use retries, circuit breaker, and timeouts; run chaos tests. See Building Resilient Agents and Testing.</p> <p>Q: What state transitions are allowed for tasks? A: Follow the task state machine (e.g. submitted \u2192 running \u2192 completed/failed). See State Management and ADR-005.</p>"},{"location":"adr/","title":"Architecture Decision Records","text":"<p>Architecture Decision Records (ADRs) document key design decisions for the ASAP protocol.</p>"},{"location":"adr/#index","title":"Index","text":"ADR Title Status ADR-001 ULID for ID Generation Accepted ADR-002 Async-First API Design Accepted ADR-003 JSON-RPC 2.0 Binding Accepted ADR-004 Pydantic for Models Accepted ADR-005 State Machine Design for Task Lifecycle Accepted ADR-006 Security Defaults Accepted ADR-007 FastAPI for Server Accepted ADR-008 httpx for Client Accepted ADR-009 Snapshot vs Event-Sourced State Persistence Accepted ADR-010 Python 3.13+ Requirement Accepted ADR-011 Per-Sender Rate Limiting Accepted ADR-012 Error Taxonomy Accepted ADR-013 MCP Integration Approach Accepted ADR-014 Testing Strategy (TDD, Property-Based) Accepted ADR-015 Observability Design (trace_id, correlation_id) Accepted ADR-016 Versioning Policy (SemVer, Contract Tests) Accepted ADR-017 Failure Injection Strategy (Chaos Testing) Accepted"},{"location":"adr/#template","title":"Template","text":"<p>To create a new ADR, copy template.md and fill in the sections. Use MADR format.</p>"},{"location":"adr/#status-legend","title":"Status Legend","text":"<ul> <li>Accepted: Decision implemented and in use</li> <li>Superseded: Replaced by another ADR</li> <li>Deprecated: No longer applicable</li> <li>Proposed: Under discussion</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/","title":"ADR-001: ULID for ID Generation","text":""},{"location":"adr/ADR-001-ulid-for-id-generation/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents need unique identifiers for envelopes, tasks, conversations, and snapshots. These IDs must be globally unique, sortable for indexing/logging, and URL-safe for transport.</p>"},{"location":"adr/ADR-001-ulid-for-id-generation/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Need globally unique IDs across distributed agents</li> <li>Sortability by creation time simplifies indexing and debugging</li> <li>URL-safe encoding for JSON-RPC and HTTP</li> <li>Minimal dependencies and simple API</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#considered-options","title":"Considered Options","text":"<ul> <li>UUID v4</li> <li>UUID v7 (time-ordered)</li> <li>ULID</li> <li>Snowflake-style IDs (Twitter, Discord)</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"ULID\", because it provides lexicographic sortability, 128-bit uniqueness, Crockford's Base32 encoding (URL-safe), and wide library support (e.g., python-ulid).</p>"},{"location":"adr/ADR-001-ulid-for-id-generation/#consequences","title":"Consequences","text":"<ul> <li>Good, because IDs are sortable by creation time for logging and indexing</li> <li>Good, because 26-character string is compact and human-readable</li> <li>Good, because monotonic within same millisecond for ordering</li> <li>Bad, because ULID is less known than UUID; requires documentation</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#confirmation","title":"Confirmation","text":"<p>All IDs in <code>asap.models.ids.generate_id()</code> return ULID strings. Tests verify format and sortability.</p>"},{"location":"adr/ADR-001-ulid-for-id-generation/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-001-ulid-for-id-generation/#uuid-v4","title":"UUID v4","text":"<ul> <li>Good, because universally recognized</li> <li>Bad, because random; no sortability by time</li> <li>Bad, because hyphenated format less compact</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#uuid-v7","title":"UUID v7","text":"<ul> <li>Good, because time-ordered</li> <li>Bad, because newer; fewer implementations at decision time</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#ulid","title":"ULID","text":"<ul> <li>Good, because lexicographically sortable</li> <li>Good, because Crockford Base32 (no ambiguous chars)</li> <li>Good, because python-ulid is mature</li> <li>Neutral, because 26 chars vs UUID's 36</li> </ul>"},{"location":"adr/ADR-001-ulid-for-id-generation/#more-information","title":"More Information","text":"<ul> <li>ULID specification</li> <li>Implementation: <code>src/asap/models/ids.py</code></li> <li><code>extract_timestamp(ulid)</code> for debugging/analytics</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/","title":"ADR-002: Async-First API Design","text":""},{"location":"adr/ADR-002-async-first-api-design/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents communicate over the network. Synchronous blocking calls would block the event loop and limit throughput. We need an API design that scales for high concurrency and integrates with modern Python async ecosystems.</p>"},{"location":"adr/ADR-002-async-first-api-design/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Network I/O is the primary bottleneck</li> <li>Support for high concurrency (1000+ connections per client)</li> <li>Compatibility with asyncio, FastAPI, and async HTTP clients</li> <li>Non-blocking handlers for scalable server processing</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/#considered-options","title":"Considered Options","text":"<ul> <li>Sync-only API</li> <li>Async-only API</li> <li>Sync with optional async wrapper</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Async-only API\", because ASAP's primary operations (send envelope, receive response) are I/O-bound and benefit from async/await. Clients use <code>async with ASAPClient(...)</code> and handlers run in async context.</p>"},{"location":"adr/ADR-002-async-first-api-design/#consequences","title":"Consequences","text":"<ul> <li>Good, because single-threaded concurrency scales for many connections</li> <li>Good, because aligns with FastAPI and httpx async patterns</li> <li>Bad, because callers must use <code>asyncio.run()</code> or be in async context</li> <li>Neutral, because sync handlers are supported via bounded executor in HandlerRegistry</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/#confirmation","title":"Confirmation","text":"<p>ASAPClient and server handlers use async signatures. Tests use pytest-asyncio.</p>"},{"location":"adr/ADR-002-async-first-api-design/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-002-async-first-api-design/#sync-only-api","title":"Sync-only API","text":"<ul> <li>Good, because simpler for basic scripts</li> <li>Bad, because blocks event loop; poor scalability</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/#async-only-api","title":"Async-only API","text":"<ul> <li>Good, because non-blocking; high throughput</li> <li>Good, because matches FastAPI/uvicorn model</li> <li>Bad, because steeper learning curve for sync-only developers</li> </ul>"},{"location":"adr/ADR-002-async-first-api-design/#more-information","title":"More Information","text":"<ul> <li>Client: <code>asap.transport.client.ASAPClient</code></li> <li>Server: <code>asap.transport.server.create_app</code> (FastAPI/ASGI)</li> <li>Sync handlers: <code>HandlerRegistry(executor=...)</code> for sync callables</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/","title":"ADR-003: JSON-RPC 2.0 Binding","text":""},{"location":"adr/ADR-003-jsonrpc20-binding/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP envelopes must be transported over HTTP. We need a standard framing protocol for request/response correlation, error handling, and interoperability.</p>"},{"location":"adr/ADR-003-jsonrpc20-binding/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Standard protocol for RPC over HTTP</li> <li>Request/response correlation via <code>id</code> field</li> <li>Structured error format (code, message, data)</li> <li>Wide tooling support (clients, proxies, debuggers)</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#considered-options","title":"Considered Options","text":"<ul> <li>Raw JSON POST (custom format)</li> <li>JSON-RPC 2.0</li> <li>gRPC</li> <li>GraphQL</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"JSON-RPC 2.0\", because it provides a well-defined envelope (<code>method</code>, <code>params</code>, <code>id</code>), standard error structure, and broad ecosystem support. ASAP envelopes are wrapped in <code>params.envelope</code> and <code>method: asap.send</code>.</p>"},{"location":"adr/ADR-003-jsonrpc20-binding/#consequences","title":"Consequences","text":"<ul> <li>Good, because interoperable with existing JSON-RPC tooling</li> <li>Good, because clear error taxonomy (code, message, data)</li> <li>Good, because batch requests possible (future)</li> <li>Bad, because extra wrapping layer; slightly larger payloads</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#confirmation","title":"Confirmation","text":"<p>Transport layer uses <code>asap.send</code> method. See <code>asap.transport.jsonrpc</code> and integration tests.</p>"},{"location":"adr/ADR-003-jsonrpc20-binding/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-003-jsonrpc20-binding/#raw-json-post","title":"Raw JSON POST","text":"<ul> <li>Good, because minimal overhead</li> <li>Bad, because no standard for errors or correlation</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#json-rpc-20","title":"JSON-RPC 2.0","text":"<ul> <li>Good, because RFC-standard; tooling exists</li> <li>Good, because supports batching for future use</li> <li>Neutral, because one extra wrapper object</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#grpc","title":"gRPC","text":"<ul> <li>Good, because binary efficiency</li> <li>Bad, because different ecosystem; HTTP/1.1 and browser support weaker</li> </ul>"},{"location":"adr/ADR-003-jsonrpc20-binding/#more-information","title":"More Information","text":"<ul> <li>JSON-RPC 2.0 spec</li> <li>Implementation: <code>src/asap/transport/jsonrpc.py</code></li> <li>Endpoint: <code>POST /asap</code></li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/","title":"ADR-004: Pydantic for Models","text":""},{"location":"adr/ADR-004-pydantic-for-models/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP defines structured message types (Envelope, TaskRequest, TaskResponse, Manifest, etc.). We need validation, serialization, and type safety for these models.</p>"},{"location":"adr/ADR-004-pydantic-for-models/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Strong typing and runtime validation</li> <li>JSON serialization/deserialization</li> <li>Clear error messages for invalid payloads</li> <li>Integration with FastAPI (Pydantic-native)</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#considered-options","title":"Considered Options","text":"<ul> <li>dataclasses + manual validation</li> <li>Pydantic v2</li> <li>attrs</li> <li>Marshmallow</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Pydantic v2\", because it provides validation, serialization, and type hints out of the box. FastAPI uses Pydantic for request/response models, so the stack is consistent.</p>"},{"location":"adr/ADR-004-pydantic-for-models/#consequences","title":"Consequences","text":"<ul> <li>Good, because automatic validation on parse; clear ValidationError messages</li> <li>Good, because <code>model_dump()</code> and <code>model_validate()</code> for JSON round-trip</li> <li>Good, because IDE support and mypy compatibility</li> <li>Bad, because Pydantic adds dependency and learning curve</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#confirmation","title":"Confirmation","text":"<p>All models in <code>asap.models</code> use Pydantic BaseModel. Tests verify validation and serialization.</p>"},{"location":"adr/ADR-004-pydantic-for-models/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-004-pydantic-for-models/#dataclasses-manual-validation","title":"dataclasses + manual validation","text":"<ul> <li>Good, because stdlib; no extra dep</li> <li>Bad, because no built-in validation or JSON schema</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#pydantic-v2","title":"Pydantic v2","text":"<ul> <li>Good, because validation, serialization, performance (Rust core)</li> <li>Good, because FastAPI integration</li> <li>Bad, because external dependency</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#attrs","title":"attrs","text":"<ul> <li>Good, because lightweight</li> <li>Bad, because less ecosystem for OpenAPI/JSON schema</li> </ul>"},{"location":"adr/ADR-004-pydantic-for-models/#more-information","title":"More Information","text":"<ul> <li>Models: <code>src/asap/models/</code></li> <li>Base: <code>asap.models.base.ASAPBaseModel</code></li> <li>Requires: <code>pydantic&gt;=2.12.5</code></li> </ul>"},{"location":"adr/ADR-005-state-machine-design/","title":"ADR-005: State Machine Design for Task Lifecycle","text":""},{"location":"adr/ADR-005-state-machine-design/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>Tasks in ASAP have a lifecycle (submitted \u2192 working \u2192 completed/failed/cancelled). We need explicit states and valid transitions to avoid invalid state changes and support resumable workflows.</p>"},{"location":"adr/ADR-005-state-machine-design/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Prevent invalid transitions (e.g., submitted \u2192 completed without working)</li> <li>Support observable task lifecycle for UI and debugging</li> <li>Enable state persistence and recovery</li> <li>Clear semantics for terminal states</li> </ul>"},{"location":"adr/ADR-005-state-machine-design/#considered-options","title":"Considered Options","text":"<ul> <li>Free-form status string</li> <li>Enum with validation</li> <li>State machine with explicit transition rules</li> <li>Event-sourced state (replay events)</li> </ul>"},{"location":"adr/ADR-005-state-machine-design/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"State machine with explicit transition rules\", because it enforces valid transitions via <code>can_transition()</code> and <code>transition()</code>, provides <code>TaskStatus</code> enum, and supports snapshot-based persistence.</p>"},{"location":"adr/ADR-005-state-machine-design/#consequences","title":"Consequences","text":"<ul> <li>Good, because invalid transitions raise <code>InvalidTransitionError</code></li> <li>Good, because terminal states (COMPLETED, FAILED, CANCELLED) are explicit</li> <li>Good, because integrates with StateSnapshot for resumable tasks</li> <li>Bad, because requires discipline; new states need transition matrix updates</li> </ul>"},{"location":"adr/ADR-005-state-machine-design/#confirmation","title":"Confirmation","text":"<p><code>asap.state.machine</code> defines transitions. Tests in <code>tests/state/</code> verify valid and invalid transitions.</p>"},{"location":"adr/ADR-005-state-machine-design/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-005-state-machine-design/#free-form-status-string","title":"Free-form status string","text":"<ul> <li>Good, because flexible</li> <li>Bad, because no validation; prone to invalid states</li> </ul>"},{"location":"adr/ADR-005-state-machine-design/#state-machine-with-transitions","title":"State machine with transitions","text":"<ul> <li>Good, because validated transitions; clear lifecycle</li> <li>Good, because immutable transitions (return new Task)</li> <li>Bad, because more code to maintain</li> </ul>"},{"location":"adr/ADR-005-state-machine-design/#more-information","title":"More Information","text":"<ul> <li><code>asap.models.enums.TaskStatus</code></li> <li><code>asap.state.machine.transition</code>, <code>can_transition</code></li> <li>State Management Guide</li> </ul>"},{"location":"adr/ADR-006-security-defaults/","title":"ADR-006: Security Defaults","text":""},{"location":"adr/ADR-006-security-defaults/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents may handle sensitive data. Defaults should favor security over convenience to avoid accidental exposure in production.</p>"},{"location":"adr/ADR-006-security-defaults/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Secure by default</li> <li>Minimize misconfiguration risk</li> <li>Support development workflows (localhost exceptions)</li> </ul>"},{"location":"adr/ADR-006-security-defaults/#considered-options","title":"Considered Options","text":"<ul> <li>Permissive defaults (opt-in security)</li> <li>Secure defaults (opt-out for development)</li> <li>No defaults (explicit configuration required)</li> </ul>"},{"location":"adr/ADR-006-security-defaults/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Secure defaults\", because rate limiting, request size limits, timestamp validation, and HTTPS enforcement are enabled by default. Development uses localhost exceptions (e.g., HTTP allowed for localhost).</p>"},{"location":"adr/ADR-006-security-defaults/#consequences","title":"Consequences","text":"<ul> <li>Good, because production deployments are secure without extra config</li> <li>Good, because explicit opt-out for development (e.g., <code>require_https=False</code>)</li> <li>Bad, because developers must know how to relax for local testing</li> <li>Neutral, because authentication is opt-in (manifest.auth)</li> </ul>"},{"location":"adr/ADR-006-security-defaults/#confirmation","title":"Confirmation","text":"<p>Server defaults: rate_limit, max_request_size, timestamp validation. Client: require_https=True, rejects HTTP for non-localhost. See Security Guide.</p>"},{"location":"adr/ADR-006-security-defaults/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-006-security-defaults/#permissive-defaults","title":"Permissive defaults","text":"<ul> <li>Good, because easier to get started</li> <li>Bad, because production misconfiguration risk</li> </ul>"},{"location":"adr/ADR-006-security-defaults/#secure-defaults","title":"Secure defaults","text":"<ul> <li>Good, because production-safe</li> <li>Good, because clear exceptions for localhost</li> <li>Bad, because developers must read docs for local setup</li> </ul>"},{"location":"adr/ADR-006-security-defaults/#more-information","title":"More Information","text":"<ul> <li>Security Guide</li> <li><code>asap.models.constants</code> (MAX_ENVELOPE_AGE_SECONDS, etc.)</li> <li><code>ASAPClient(require_https=True)</code> default</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/","title":"ADR-007: FastAPI for Server","text":""},{"location":"adr/ADR-007-fastapi-for-server/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP needs an HTTP server for the <code>/asap</code> endpoint and manifest discovery. We need async support, JSON handling, and OpenAPI/docs for developer experience.</p>"},{"location":"adr/ADR-007-fastapi-for-server/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Async ASGI server</li> <li>Automatic JSON parsing/validation</li> <li>OpenAPI/Swagger for API exploration</li> <li>Widely adopted and maintained</li> <li>Performance for high concurrency</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#considered-options","title":"Considered Options","text":"<ul> <li>FastAPI</li> <li>Starlette (raw)</li> <li>aiohttp</li> <li>Django ASGI</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"FastAPI\", because it provides async routing, Pydantic integration, automatic OpenAPI docs, and is built on Starlette/Uvicorn. Aligns with Pydantic models and JSON-RPC handling.</p>"},{"location":"adr/ADR-007-fastapi-for-server/#consequences","title":"Consequences","text":"<ul> <li>Good, because Pydantic request/response validation</li> <li>Good, because OpenAPI at <code>/docs</code> for debugging</li> <li>Good, because middleware support (rate limit, auth, CORS)</li> <li>Bad, because adds dependency; Starlette alone would be lighter</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#confirmation","title":"Confirmation","text":"<p><code>asap.transport.server.create_app()</code> returns a FastAPI app. Runs with Uvicorn.</p>"},{"location":"adr/ADR-007-fastapi-for-server/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-007-fastapi-for-server/#fastapi","title":"FastAPI","text":"<ul> <li>Good, because async, Pydantic, OpenAPI</li> <li>Good, because ecosystem and community</li> <li>Bad, because heavier than Starlette alone</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#starlette","title":"Starlette","text":"<ul> <li>Good, because minimal</li> <li>Bad, because no built-in validation or OpenAPI</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#aiohttp","title":"aiohttp","text":"<ul> <li>Good, because async</li> <li>Bad, because different request model; less Pydantic integration</li> </ul>"},{"location":"adr/ADR-007-fastapi-for-server/#more-information","title":"More Information","text":"<ul> <li><code>src/asap/transport/server.py</code></li> <li><code>create_app(manifest, registry)</code></li> <li>Uvicorn for ASGI serving</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/","title":"ADR-008: httpx for Client","text":""},{"location":"adr/ADR-008-httpx-for-client/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP clients send envelopes over HTTP. We need an async HTTP client with connection pooling, HTTP/2 support, and retry/timeout configuration.</p>"},{"location":"adr/ADR-008-httpx-for-client/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Async HTTP client</li> <li>Connection pooling for high concurrency</li> <li>HTTP/2 support for multiplexing</li> <li>Timeout, retry, and compression support</li> <li>API compatibility with requests for familiarity</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#considered-options","title":"Considered Options","text":"<ul> <li>httpx</li> <li>aiohttp</li> <li>requests + grequests/threading</li> <li>urllib3</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"httpx\", because it provides async API, connection pooling, HTTP/2 (via httpx[http2]), and a requests-like interface. Used as the transport for ASAPClient.</p>"},{"location":"adr/ADR-008-httpx-for-client/#consequences","title":"Consequences","text":"<ul> <li>Good, because async-native; integrates with asyncio</li> <li>Good, because connection pooling and HTTP/2 for throughput</li> <li>Good, because timeout, retry, and compression built-in</li> <li>Bad, because adds dependency; aiohttp has different API</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#confirmation","title":"Confirmation","text":"<p>ASAPClient uses <code>httpx.AsyncClient</code> under the hood. See <code>asap.transport.client</code>.</p>"},{"location":"adr/ADR-008-httpx-for-client/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-008-httpx-for-client/#httpx","title":"httpx","text":"<ul> <li>Good, because async, pooling, HTTP/2</li> <li>Good, because requests-like API</li> <li>Neutral, because newer than aiohttp</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#aiohttp","title":"aiohttp","text":"<ul> <li>Good, because mature async client</li> <li>Bad, because different API; less requests familiarity</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#requests","title":"requests","text":"<ul> <li>Good, because widely known</li> <li>Bad, because sync-only; blocks event loop</li> </ul>"},{"location":"adr/ADR-008-httpx-for-client/#more-information","title":"More Information","text":"<ul> <li><code>src/asap/transport/client.py</code></li> <li>Dependencies: <code>httpx[http2]&gt;=0.28.1</code></li> <li>Pool limits: DEFAULT_POOL_CONNECTIONS, DEFAULT_POOL_MAXSIZE</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/","title":"ADR-009: Snapshot vs Event-Sourced State Persistence","text":""},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>Long-running tasks need state persistence for resume after crash or restart. We must choose between snapshot-based and event-sourced persistence.</p>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Resume from last known good state</li> <li>Storage efficiency</li> <li>Implementation complexity</li> <li>Debugging and audit trail needs</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#considered-options","title":"Considered Options","text":"<ul> <li>Snapshot-based (periodic full state save)</li> <li>Event-sourced (append-only event log, replay to restore)</li> <li>Hybrid (snapshot + incremental events)</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Snapshot-based\", because it is simpler to implement and use. StateSnapshot stores versioned snapshots; <code>InMemorySnapshotStore</code> and custom stores (Redis, PostgreSQL) implement the SnapshotStore protocol. Event-sourcing deferred for future consideration.</p>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#consequences","title":"Consequences","text":"<ul> <li>Good, because simple API: save snapshot, get latest, resume</li> <li>Good, because flexible data shape (JSON-serializable dict)</li> <li>Bad, because no full audit trail; only checkpoints</li> <li>Neutral, because event-sourcing could be added later for audit</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#confirmation","title":"Confirmation","text":"<p><code>asap.models.entities.StateSnapshot</code> and <code>asap.state.snapshot.InMemorySnapshotStore</code>. See State Management Guide.</p>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#snapshot-based","title":"Snapshot-based","text":"<ul> <li>Good, because simple; easy to reason about</li> <li>Good, because checkpoint flag for significant states</li> <li>Bad, because no replay; no full history</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#event-sourced","title":"Event-sourced","text":"<ul> <li>Good, because full audit trail; replay for debugging</li> <li>Bad, because more complex; storage growth</li> <li>Bad, because schema evolution harder</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#hybrid","title":"Hybrid","text":"<ul> <li>Good, because best of both</li> <li>Bad, because higher complexity</li> </ul>"},{"location":"adr/ADR-009-snapshot-vs-event-sourced/#more-information","title":"More Information","text":"<ul> <li><code>asap.models.entities.StateSnapshot</code></li> <li><code>asap.state.snapshot.InMemorySnapshotStore</code>, <code>SnapshotStore</code> protocol</li> <li>State Management Guide</li> <li>Stateful Workflows tutorial</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/","title":"ADR-010: Python 3.13+ Requirement","text":""},{"location":"adr/ADR-010-python-313-requirement/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP protocol must target a Python version that provides modern features (type hints, async, performance) while balancing adoption and ecosystem support.</p>"},{"location":"adr/ADR-010-python-313-requirement/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Type system (PEP 484, ParamSpec, TypeAlias)</li> <li>Async/await maturity</li> <li>Performance (faster interpreter)</li> <li>Ecosystem support (dependencies)</li> <li>Long-term support horizon</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/#considered-options","title":"Considered Options","text":"<ul> <li>Python 3.10</li> <li>Python 3.11</li> <li>Python 3.12</li> <li>Python 3.13</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Python 3.13+\", because it provides the latest performance improvements, type system features, and ensures ASAP targets a modern baseline. pyproject.toml specifies <code>requires-python = \"&gt;=3.13\"</code>.</p>"},{"location":"adr/ADR-010-python-313-requirement/#consequences","title":"Consequences","text":"<ul> <li>Good, because access to latest language features</li> <li>Good, because better performance for high-throughput agents</li> <li>Bad, because narrower install base; some users on older Python</li> <li>Neutral, because uv/pip handle version checks</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/#confirmation","title":"Confirmation","text":"<p>pyproject.toml: <code>requires-python = \"&gt;=3.13\"</code>. CI tests on 3.13.</p>"},{"location":"adr/ADR-010-python-313-requirement/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-010-python-313-requirement/#python-310","title":"Python 3.10","text":"<ul> <li>Good, because wider adoption</li> <li>Bad, because misses 3.11+ performance and features</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/#python-313","title":"Python 3.13","text":"<ul> <li>Good, because latest performance and features</li> <li>Bad, because newer; some distros may not ship it yet</li> </ul>"},{"location":"adr/ADR-010-python-313-requirement/#more-information","title":"More Information","text":"<ul> <li>pyproject.toml: <code>requires-python = \"&gt;=3.13\"</code></li> <li>CI: .github/workflows/ci.yml</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/","title":"ADR-011: Per-Sender Rate Limiting","text":""},{"location":"adr/ADR-011-per-sender-rate-limiting/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents must protect against denial-of-service and abusive clients. Rate limiting should be applied per sender (agent URN or fallback to client IP) to allow fair multi-tenant usage.</p>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Protect server from overload</li> <li>Fair usage across multiple clients</li> <li>Per-sender isolation (one abusive client doesn't affect others)</li> <li>Configurable limits (env var or create_app param)</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#considered-options","title":"Considered Options","text":"<ul> <li>No rate limiting</li> <li>Global rate limit (all requests)</li> <li>Per-IP rate limit</li> <li>Per-sender (envelope.sender) rate limit with IP fallback</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Per-sender rate limit with IP fallback\", because envelope.sender identifies the agent; when envelope is not yet parsed, fallback to client IP. Default: 10/second;100/minute per sender. Configurable via ASAP_RATE_LIMIT or create_app(rate_limit=...).</p>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#consequences","title":"Consequences","text":"<ul> <li>Good, because per-sender fairness; one client cannot starve others</li> <li>Good, because slowapi integration; supports Redis for multi-instance</li> <li>Bad, because IP fallback can be spoofed (use behind trusted proxy)</li> <li>Neutral, because memory storage is per-process; Redis needed for shared limits</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#confirmation","title":"Confirmation","text":"<p>Rate limiting in <code>asap.transport.middleware</code>. Key: sender from envelope or client IP. See Security Guide.</p>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-011-per-sender-rate-limiting/#global-rate-limit","title":"Global rate limit","text":"<ul> <li>Good, because simple</li> <li>Bad, because one client can starve others</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#per-sender-with-ip-fallback","title":"Per-sender with IP fallback","text":"<ul> <li>Good, because fairness; identifies agent when available</li> <li>Good, because fallback for unauthenticated requests</li> <li>Bad, because IP can be spoofed without proxy</li> </ul>"},{"location":"adr/ADR-011-per-sender-rate-limiting/#more-information","title":"More Information","text":"<ul> <li>Security Guide</li> <li>slowapi integration in middleware</li> <li>ASAP_RATE_LIMIT env var; format: \"10/second;100/minute\"</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/","title":"ADR-012: Error Taxonomy","text":""},{"location":"adr/ADR-012-error-taxonomy/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents and clients need a consistent way to classify and handle errors. We need machine-readable error codes and human-readable messages for debugging and recovery.</p>"},{"location":"adr/ADR-012-error-taxonomy/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Client retry decisions (transient vs permanent)</li> <li>Structured logging and observability</li> <li>Clear error messages for developers</li> <li>JSON-RPC error compatibility</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/#considered-options","title":"Considered Options","text":"<ul> <li>Free-form error strings</li> <li>Numeric codes only (JSON-RPC standard)</li> <li>Structured errors with code, message, data</li> <li>ASAP-specific error hierarchy (ASAPError base)</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Structured errors with ASAP-specific hierarchy\", because ASAPError base class and subclasses (InvalidTransitionError, CircuitOpenError, ASAPConnectionError, etc.) provide consistent structure. JSON-RPC errors use code, message, data with ASAP codes (e.g., asap:protocol/invalid_timestamp).</p>"},{"location":"adr/ADR-012-error-taxonomy/#consequences","title":"Consequences","text":"<ul> <li>Good, because clients can match error types for retry logic</li> <li>Good, because structured data (e.g., retry_after, envelope_id)</li> <li>Good, because consistent with JSON-RPC error format</li> <li>Bad, because more classes to maintain</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/#confirmation","title":"Confirmation","text":"<p><code>asap.errors</code> module. Tests verify error structure and codes. See Error Handling.</p>"},{"location":"adr/ADR-012-error-taxonomy/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-012-error-taxonomy/#free-form-strings","title":"Free-form strings","text":"<ul> <li>Good, because simple</li> <li>Bad, because no machine-readable classification</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/#structured-asap-errors","title":"Structured ASAP errors","text":"<ul> <li>Good, because hierarchy; code, message, data</li> <li>Good, because JSON-RPC compatibility</li> <li>Bad, because more boilerplate</li> </ul>"},{"location":"adr/ADR-012-error-taxonomy/#more-information","title":"More Information","text":"<ul> <li><code>src/asap/errors.py</code></li> <li>Error Handling</li> <li>ASAPConnectionError, ASAPTimeoutError, ASAPRemoteError, CircuitOpenError</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/","title":"ADR-013: MCP Integration Approach","text":""},{"location":"adr/ADR-013-mcp-integration-approach/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP aims to integrate with the Model Context Protocol (MCP) for tool invocation. We need a strategy for MCP tool calls and results within ASAP envelopes.</p>"},{"location":"adr/ADR-013-mcp-integration-approach/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Interoperability with MCP ecosystem</li> <li>ASAP envelope structure (payload_type, payload)</li> <li>Tool call/result as first-class payload types</li> <li>Preserve ASAP semantics (sender, recipient, trace_id)</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/#considered-options","title":"Considered Options","text":"<ul> <li>MCP-native transport only (no ASAP)</li> <li>ASAP wraps MCP messages (McpToolCall, McpToolResult payloads)</li> <li>Parallel protocols (ASAP and MCP coexist)</li> <li>ASAP as MCP transport adapter</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"ASAP wraps MCP messages\", because ASAP envelopes can carry MCP tool call and result payloads. Payload types like mcp.tool_call and mcp.tool_result allow agents to invoke MCP tools via ASAP. Preserves trace_id, correlation_id for observability.</p>"},{"location":"adr/ADR-013-mcp-integration-approach/#consequences","title":"Consequences","text":"<ul> <li>Good, because single transport (ASAP) for agent and MCP flows</li> <li>Good, because trace context flows through tool calls</li> <li>Bad, because MCP spec may evolve; requires sync</li> <li>Neutral, because MCP tool discovery separate from ASAP manifest</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/#confirmation","title":"Confirmation","text":"<p>Examples in <code>asap.examples.mcp_integration</code>. Payload types for MCP tool invocation. See MCP spec for tool schema.</p>"},{"location":"adr/ADR-013-mcp-integration-approach/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-013-mcp-integration-approach/#asap-wraps-mcp","title":"ASAP wraps MCP","text":"<ul> <li>Good, because unified transport; trace context</li> <li>Good, because ASAPClient can send MCP payloads</li> <li>Bad, because double wrapping (ASAP + MCP)</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/#parallel-protocols","title":"Parallel protocols","text":"<ul> <li>Good, because native MCP where needed</li> <li>Bad, because two transports; no unified tracing</li> </ul>"},{"location":"adr/ADR-013-mcp-integration-approach/#more-information","title":"More Information","text":"<ul> <li><code>asap.examples.mcp_integration</code></li> <li>MCP specification</li> <li>Payload types: mcp.tool_call, mcp.tool_result (or equivalent)</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/","title":"ADR-014: Testing Strategy (TDD, Property-Based)","text":""},{"location":"adr/ADR-014-testing-strategy/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP must be reliable and maintainable. We need a testing strategy that catches regressions, edge cases, and contract violations across versions.</p>"},{"location":"adr/ADR-014-testing-strategy/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>High confidence in correctness</li> <li>Edge case coverage (invalid inputs, boundary conditions)</li> <li>Backward compatibility (contract tests)</li> <li>Performance regression detection</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/#considered-options","title":"Considered Options","text":"<ul> <li>Unit tests only</li> <li>Unit + integration tests</li> <li>Unit + integration + property-based tests</li> <li>Full TDD with property-based and contract tests</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"Unit + integration + property-based + contract tests\", because unit tests cover logic, integration tests cover transport/server, property-based tests (Hypothesis) cover envelope/payload edge cases, and contract tests validate backward compatibility (v0.1.0, v0.5.0). Chaos tests verify resilience.</p>"},{"location":"adr/ADR-014-testing-strategy/#consequences","title":"Consequences","text":"<ul> <li>Good, because property-based tests find edge cases automatically</li> <li>Good, because contract tests catch breaking changes</li> <li>Good, because chaos tests validate failure handling</li> <li>Bad, because more test code; longer CI</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/#confirmation","title":"Confirmation","text":"<p>Tests in <code>tests/</code>: unit, integration, properties, contract, chaos. Hypothesis in <code>tests/properties/</code> and <code>tests/fuzz/</code>. See Testing.</p>"},{"location":"adr/ADR-014-testing-strategy/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-014-testing-strategy/#unit-only","title":"Unit only","text":"<ul> <li>Good, because fast</li> <li>Bad, because misses integration and edge cases</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/#unit-property-based-contract","title":"Unit + property-based + contract","text":"<ul> <li>Good, because broad coverage; edge cases; compatibility</li> <li>Bad, because maintenance cost</li> </ul>"},{"location":"adr/ADR-014-testing-strategy/#more-information","title":"More Information","text":"<ul> <li>Testing Guide</li> <li>tests/properties/, tests/contract/, tests/chaos/</li> <li>Rate limiting and integration test patterns (see test conftest)</li> </ul>"},{"location":"adr/ADR-015-observability-design/","title":"ADR-015: Observability Design (trace_id, correlation_id)","text":""},{"location":"adr/ADR-015-observability-design/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>Distributed agent communication requires tracing requests across services. We need standard fields for correlation and distributed tracing.</p>"},{"location":"adr/ADR-015-observability-design/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Trace requests across agents</li> <li>Correlate request/response pairs</li> <li>Structured logging with context</li> <li>Compatibility with OpenTelemetry and tracing backends</li> </ul>"},{"location":"adr/ADR-015-observability-design/#considered-options","title":"Considered Options","text":"<ul> <li>No standard fields</li> <li>Single request ID</li> <li>trace_id + correlation_id (request ID)</li> <li>Full OpenTelemetry context propagation</li> </ul>"},{"location":"adr/ADR-015-observability-design/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"trace_id + correlation_id\", because trace_id identifies the full workflow across agents; correlation_id links request and response envelopes. Envelope model includes trace_id; response includes correlation_id pointing to request. bind_context/clear_context for log correlation.</p>"},{"location":"adr/ADR-015-observability-design/#consequences","title":"Consequences","text":"<ul> <li>Good, because trace_id flows through multi-agent workflows</li> <li>Good, because correlation_id links request/response for debugging</li> <li>Good, because structlog + bind_context for log enrichment</li> <li>Bad, because manual propagation; OTel auto-instrumentation deferred</li> </ul>"},{"location":"adr/ADR-015-observability-design/#confirmation","title":"Confirmation","text":"<p>Envelope.trace_id, response.correlation_id. bind_context(trace_id=..., correlation_id=...). See Observability.</p>"},{"location":"adr/ADR-015-observability-design/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-015-observability-design/#single-request-id","title":"Single request ID","text":"<ul> <li>Good, because simple</li> <li>Bad, because no workflow-level trace</li> </ul>"},{"location":"adr/ADR-015-observability-design/#trace_id-correlation_id","title":"trace_id + correlation_id","text":"<ul> <li>Good, because workflow + request/response correlation</li> <li>Good, because aligns with OTel concepts</li> <li>Neutral, because OTel full propagation future work</li> </ul>"},{"location":"adr/ADR-015-observability-design/#more-information","title":"More Information","text":"<ul> <li>Observability</li> <li><code>asap.observability.logging.bind_context</code>, <code>clear_context</code></li> <li>Envelope.trace_id, correlation_id</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/","title":"ADR-016: Versioning Policy (SemVer, Contract Tests)","text":""},{"location":"adr/ADR-016-versioning-policy/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP protocol and library will evolve. We need a versioning strategy that signals breaking changes and allows clients to upgrade safely.</p>"},{"location":"adr/ADR-016-versioning-policy/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Clear semantic versioning (MAJOR.MINOR.PATCH)</li> <li>Backward compatibility guarantees</li> <li>Contract tests for compatibility</li> <li>Protocol version (asap_version) vs library version</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/#considered-options","title":"Considered Options","text":"<ul> <li>No formal versioning</li> <li>SemVer for library only</li> <li>SemVer + protocol version + contract tests</li> <li>CalVer</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"SemVer for library + asap_version in envelope + contract tests\", because library follows SemVer; envelope has asap_version (e.g., \"0.1\") for protocol evolution. Contract tests (tests/contract/, tests/compatibility/) validate backward compatibility (v0.1.0, v0.5.0, v1.0.0).</p>"},{"location":"adr/ADR-016-versioning-policy/#consequences","title":"Consequences","text":"<ul> <li>Good, because SemVer signals breaking (MAJOR), additive (MINOR), patch (PATCH)</li> <li>Good, because contract tests catch accidental breaks</li> <li>Good, because asap_version allows protocol evolution</li> <li>Bad, because contract test maintenance across versions</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/#confirmation","title":"Confirmation","text":"<p>pyproject.toml version. Contract tests in tests/contract/, tests/compatibility/. Envelope.asap_version.</p>"},{"location":"adr/ADR-016-versioning-policy/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-016-versioning-policy/#semver-only","title":"SemVer only","text":"<ul> <li>Good, because standard</li> <li>Bad, because no automated compatibility checks</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/#semver-contract-tests","title":"SemVer + contract tests","text":"<ul> <li>Good, because automated compatibility verification</li> <li>Bad, because test matrix growth</li> </ul>"},{"location":"adr/ADR-016-versioning-policy/#more-information","title":"More Information","text":"<ul> <li>Migration Guide</li> <li>tests/compatibility/test_v0_1_0_compatibility.py, test_v0_3_0_compatibility.py</li> <li>Envelope.asap_version field</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/","title":"ADR-017: Failure Injection Strategy (Chaos Testing)","text":""},{"location":"adr/ADR-017-failure-injection-strategy/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>ASAP agents must handle failures gracefully (server crashes, message loss, network partition). We need a strategy to validate resilience through controlled failure injection.</p>"},{"location":"adr/ADR-017-failure-injection-strategy/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>Validate retry, circuit breaker, timeout behavior</li> <li>Simulate real-world failures (crashes, drops, partitions)</li> <li>Reproducible tests in CI</li> <li>Document expected behavior under failure</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#considered-options","title":"Considered Options","text":"<ul> <li>No chaos testing</li> <li>Manual chaos (external tools)</li> <li>In-process chaos (mocked transport, controlled failures)</li> <li>Dedicated chaos test suite with simulated failures</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"In-process chaos tests with mocked transport\", because tests in tests/chaos/ use httpx.MockTransport to simulate server crash, message loss, 503, network partition, clock skew. Validates ASAPClient retry, circuit breaker, timeout. No external chaos tools required for CI.</p>"},{"location":"adr/ADR-017-failure-injection-strategy/#consequences","title":"Consequences","text":"<ul> <li>Good, because reproducible; runs in CI</li> <li>Good, because covers message loss, crashes, circuit open</li> <li>Good, because documents expected client behavior</li> <li>Bad, because mocked; may miss real network behavior</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#confirmation","title":"Confirmation","text":"<p>tests/chaos/: test_crashes.py, test_message_reliability.py, test_network_partition.py, test_clock_skew.py. See Building Resilient Agents.</p>"},{"location":"adr/ADR-017-failure-injection-strategy/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/ADR-017-failure-injection-strategy/#no-chaos-testing","title":"No chaos testing","text":"<ul> <li>Good, because no extra tests</li> <li>Bad, because no resilience validation</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#in-process-chaos-with-mocks","title":"In-process chaos with mocks","text":"<ul> <li>Good, because CI-friendly; deterministic</li> <li>Good, because covers key scenarios</li> <li>Bad, because mocks may not reflect real failures</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#external-chaos-chaos-monkey-etc","title":"External chaos (Chaos Monkey, etc.)","text":"<ul> <li>Good, because real failures</li> <li>Bad, because complex; not suitable for unit CI</li> </ul>"},{"location":"adr/ADR-017-failure-injection-strategy/#more-information","title":"More Information","text":"<ul> <li>tests/chaos/</li> <li>Building Resilient Agents</li> <li>ASAPClient retry, circuit breaker, timeout behavior</li> </ul>"},{"location":"adr/template/","title":"{short title, representative of solved problem and found solution}","text":""},{"location":"adr/template/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>{Describe the context and problem statement, e.g., in free form using two to three sentences or in the form of an illustrative story.}</p>"},{"location":"adr/template/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>{decision driver 1, e.g., a force, facing concern}</li> <li>{decision driver 2}</li> <li>\u2026</li> </ul>"},{"location":"adr/template/#considered-options","title":"Considered Options","text":"<ul> <li>{title of option 1}</li> <li>{title of option 2}</li> <li>{title of option 3}</li> <li>\u2026</li> </ul>"},{"location":"adr/template/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: \"{title of option 1}\", because {justification}.</p>"},{"location":"adr/template/#consequences","title":"Consequences","text":"<ul> <li>Good, because {positive consequence}</li> <li>Bad, because {negative consequence}</li> <li>\u2026</li> </ul>"},{"location":"adr/template/#confirmation","title":"Confirmation","text":"<p>{Describe how compliance with the ADR can/will be confirmed.}</p>"},{"location":"adr/template/#pros-and-cons-of-the-options","title":"Pros and Cons of the Options","text":""},{"location":"adr/template/#title-of-option-1","title":"{title of option 1}","text":"<ul> <li>Good, because {argument a}</li> <li>Good, because {argument b}</li> <li>Bad, because {argument c}</li> <li>\u2026</li> </ul>"},{"location":"adr/template/#title-of-other-option","title":"{title of other option}","text":"<ul> <li>Good, because {argument a}</li> <li>Bad, because {argument b}</li> <li>\u2026</li> </ul>"},{"location":"adr/template/#more-information","title":"More Information","text":"<p>{Links to related decisions, implementation details, or team agreement.}</p>"},{"location":"best-practices/agent-failover-migration/","title":"Best Practices: Agent Failover &amp; Migration","text":"<p>Formal patterns for transferring task state between agents and recovering from failures. Purpose: Ensure interoperability so all ASAP implementations handle handover and failover consistently.</p>"},{"location":"best-practices/agent-failover-migration/#overview","title":"Overview","text":"<p>ASAP provides protocol primitives for state persistence and transfer:</p> <ul> <li>StateSnapshot: Checkpoint of task state (versioned, JSON-portable).</li> <li>StateQuery: Request to obtain a task's state snapshot from an agent.</li> <li>StateRestore: Request to restore a task from a snapshot (by snapshot ID).</li> </ul> <p>Without a common approach, implementations diverge and failover/migration breaks across vendors. This document is prescriptive: follow these patterns for interoperable agent failover and migration.</p> <p>Related: State Management Guide, state_migration example, agent_failover example.</p>"},{"location":"best-practices/agent-failover-migration/#1-context-handover-pattern-statequery-staterestore","title":"1. Context Handover Pattern (StateQuery \u2192 StateRestore)","text":"<p>Use this pattern whenever task ownership or location changes: handover, failover, or migration.</p>"},{"location":"best-practices/agent-failover-migration/#flow","title":"Flow","text":"<ol> <li>Obtain state from the current holder:</li> <li>Option A (protocol): Send a <code>StateQuery</code> envelope to the agent that holds the task. It responds with the snapshot (or you read from a shared store it uses).</li> <li>Option B (shared storage): If both agents use the same store (e.g. shared SQLite path or Redis), the coordinator (or new agent) reads the snapshot directly with <code>store.get(task_id, version)</code>.</li> <li>Restore on the new agent:</li> <li>Option A (protocol): Ensure the snapshot is available to the target agent (e.g. save it to the target\u2019s store or a shared store), then send a <code>StateRestore</code> envelope to the target with <code>task_id</code> and <code>snapshot_id</code>.</li> <li>Option B (shared storage): If the target uses the same store, it can load by <code>task_id</code>/version; no <code>StateRestore</code> needed if you only need to \u201cpoint\u201d the worker at the same store.</li> </ol> <p>For cross-process / cross-host handover, use the protocol: send <code>StateQuery</code> (or read from shared storage), then send <code>StateRestore</code> (or write snapshot to a store the target can read).</p>"},{"location":"best-practices/agent-failover-migration/#envelope-construction","title":"Envelope construction","text":"<pre><code>from asap.models.envelope import Envelope\nfrom asap.models.payloads import StateQuery, StateRestore\nfrom asap.models.ids import generate_id\n\n# Request state from Agent A (e.g. primary)\ndef build_state_query(task_id: str, version: int | None = None) -&gt; Envelope:\n    return Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:coordinator\",\n        recipient=\"urn:asap:agent:primary\",\n        payload_type=\"state_query\",\n        payload=StateQuery(task_id=task_id, version=version).model_dump(),\n        trace_id=generate_id(),\n    )\n\n# Tell Agent B (backup) to restore from a snapshot\ndef build_state_restore(task_id: str, snapshot_id: str) -&gt; Envelope:\n    return Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:coordinator\",\n        recipient=\"urn:asap:agent:backup\",\n        payload_type=\"state_restore\",\n        payload=StateRestore(task_id=task_id, snapshot_id=snapshot_id).model_dump(),\n        trace_id=generate_id(),\n    )\n</code></pre> <p>The agent that receives <code>StateQuery</code> must respond with the snapshot (e.g. from its <code>SnapshotStore</code>). The agent that receives <code>StateRestore</code> must load the snapshot by <code>snapshot_id</code> from its store and resume the task from that state.</p>"},{"location":"best-practices/agent-failover-migration/#2-failover-scenario-primary-fails-backup-takes-over","title":"2. Failover Scenario (Primary Fails, Backup Takes Over)","text":"<p>Scenario: Agent A (primary) is processing a task; Agent A fails (crash, OOM, network). A coordinator or orchestrator must move the task to Agent B (backup) so work can resume.</p>"},{"location":"best-practices/agent-failover-migration/#steps","title":"Steps","text":"<ol> <li> <p>Detect failure    Use the ASAP health endpoint (e.g. <code>GET /.well-known/asap/health</code>) or your orchestration layer to detect that Agent A is unhealthy (SD-10).</p> </li> <li> <p>Obtain latest state </p> </li> <li>If Agent A is still reachable: send <code>StateQuery</code> to A, get the snapshot from the response.  </li> <li> <p>If Agent A is down but state is in shared storage (e.g. Redis, shared SQLite): read <code>store.get(task_id)</code> (latest) or <code>store.get(task_id, version=version)</code> from that store.</p> </li> <li> <p>Make snapshot available to Agent B </p> </li> <li>If B uses the same shared store and the snapshot is already there: no copy needed.  </li> <li> <p>Otherwise: push the snapshot to B\u2019s store (e.g. via an API that accepts a snapshot, or by sending the snapshot in a message and B saves it), or write it to a store B can read.</p> </li> <li> <p>Restore on Agent B </p> </li> <li>Send <code>StateRestore(task_id=..., snapshot_id=...)</code> to B (so B loads that snapshot and continues), or </li> <li> <p>If B reads from shared store, ensure B is told to resume <code>task_id</code> (and optionally which version). B then calls <code>store.get(task_id)</code> and resumes.</p> </li> <li> <p>Route new work to B    Update routing so subsequent requests for that task (or conversation) go to Agent B.</p> </li> </ol>"},{"location":"best-practices/agent-failover-migration/#coordinator-responsibilities","title":"Coordinator responsibilities","text":"<ul> <li>Poll or subscribe to health (e.g. <code>/.well-known/asap/health</code>).</li> <li>On primary failure, decide which task(s) to fail over.</li> <li>For each task: get snapshot (StateQuery or shared store), provide snapshot to backup (StateRestore or shared store), then route traffic to backup.</li> </ul>"},{"location":"best-practices/agent-failover-migration/#3-migration-scenario-different-host-or-version","title":"3. Migration Scenario (Different Host or Version)","text":"<p>Scenario: You are moving an agent to a new host or upgrading to a new version; you want to move in-flight task state to the new process.</p>"},{"location":"best-practices/agent-failover-migration/#steps_1","title":"Steps","text":"<ol> <li> <p>Drain / pause    Stop assigning new work to the old agent (or mark it draining). Let in-flight tasks reach a checkpoint if possible.</p> </li> <li> <p>Export state    For each active task, get the latest snapshot:</p> </li> <li>From the old agent via <code>StateQuery</code>, or  </li> <li> <p>From the old agent\u2019s store (e.g. read from its DB or shared store).</p> </li> <li> <p>Import into new agent </p> </li> <li>Write snapshots into the new agent\u2019s store (or shared store the new agent uses).  </li> <li> <p>Optionally send <code>StateRestore</code> to the new agent for each task so it loads the snapshot and resumes.</p> </li> <li> <p>Switch traffic    Point clients/coordinators to the new agent. Retire the old agent.</p> </li> </ol>"},{"location":"best-practices/agent-failover-migration/#version-compatibility","title":"Version compatibility","text":"<ul> <li><code>StateSnapshot.data</code> is a JSON-serializable <code>dict</code>. Keep schema stable across versions so old snapshots can be restored by new code.</li> <li>Prefer adding optional fields and ignoring unknown fields when restoring.</li> </ul>"},{"location":"best-practices/agent-failover-migration/#4-artifact-portability-conventions","title":"4. Artifact Portability Conventions","text":"<p>Task state (e.g. <code>StateSnapshot.data</code>) often references artifacts by URI (files, blobs, outputs). Whether those references remain valid after failover or migration depends on the URI scheme. Follow these conventions so artifacts behave correctly when the task moves to another agent.</p>"},{"location":"best-practices/agent-failover-migration/#41-uri-schemes-and-portability","title":"4.1 URI schemes and portability","text":"Scheme Portable across agents? Use case <code>https://</code> Yes Shared object storage (S3, GCS, Azure Blob), CDN URLs, presigned URLs. Resolvable by any agent with network access. Use for any artifact that may need to survive failover. <code>asap://</code> No (agent-local) References local to a single agent instance (e.g. <code>asap://artifact/abc</code>). The new agent cannot resolve them after failover unless you copy the resource and expose it (e.g. via <code>https://</code>) or replicate it locally. <code>data:</code> Yes Inline small payloads (e.g. <code>data:application/json;base64,...</code>). No network or local storage required; always portable."},{"location":"best-practices/agent-failover-migration/#42-what-happens-during-failover","title":"4.2 What happens during failover","text":"<ul> <li><code>https://</code>: After failover, the backup agent (or any other agent) can fetch the artifact using the same URL. No extra step required as long as the URL remains valid (e.g. presigned URL not expired).</li> <li><code>asap://</code>: After failover, the URL points to the old (possibly dead) agent. The backup cannot resolve it. Either avoid <code>asap://</code> for state that may fail over, or ensure the coordinator (or old agent before shutdown) copies the artifact to shared storage and rewrites the reference to <code>https://</code> before handing over.</li> <li><code>data:</code>: The payload is embedded in the state; it moves with the snapshot. No change in behavior after failover.</li> </ul>"},{"location":"best-practices/agent-failover-migration/#43-recommendation","title":"4.3 Recommendation","text":"<ul> <li>For tasks that might be failed over or migrated, store artifact references as <code>https://</code> (or <code>data:</code> for small inline data).</li> <li>Avoid relying on <code>asap://</code> for any state that must move to another agent. Reserve <code>asap://</code> for agent-local references that will never be transferred (e.g. transient scratch paths).</li> <li>When generating artifact URIs in task handlers, prefer writing to object storage (or a shared volume) and storing the resulting <code>https://</code> (or presigned) URL in <code>StateSnapshot.data</code>, so that failover and migration work without extra copy steps.</li> </ul>"},{"location":"best-practices/agent-failover-migration/#5-state-export-convention","title":"5. State Export Convention","text":"<p>To export <code>StateSnapshot</code> for external systems (backups, analytics, or another platform):</p> <ul> <li>Format: JSON. Use <code>StateSnapshot.model_dump()</code> (Pydantic v2) for a dict, or <code>StateSnapshot.model_dump_json()</code> for a string.</li> <li>Fields: <code>id</code>, <code>task_id</code>, <code>version</code>, <code>data</code>, <code>checkpoint</code>, <code>created_at</code>. All are JSON-serializable; <code>data</code> is already <code>dict[str, Any]</code>.</li> <li>Idempotency: When re-importing, use the same <code>id</code> and <code>task_id</code>/<code>version</code> if you need to avoid duplicates. New IDs can be generated for \u201ccopy\u201d migrations.</li> </ul> <p>Example:</p> <pre><code>from asap.models.entities import StateSnapshot\n\nsnapshot: StateSnapshot = store.get(task_id)\nif snapshot:\n    export_dict = snapshot.model_dump()\n    # Persist export_dict to file, blob store, or send over the wire\n    # Later: snapshot = StateSnapshot.model_validate(export_dict); store.save(snapshot)\n</code></pre>"},{"location":"best-practices/agent-failover-migration/#6-code-examples","title":"6. Code Examples","text":""},{"location":"best-practices/agent-failover-migration/#61-moving-state-between-two-stores-in-process","title":"6.1 Moving state between two stores (in-process)","text":"<p>This mirrors the official state_migration example: export from one store, import into another (e.g. primary vs backup store).</p> <pre><code>from datetime import datetime, timezone\nfrom asap.models.entities import StateSnapshot\nfrom asap.models.ids import generate_id\nfrom asap.state import InMemorySnapshotStore, SnapshotStore\n\ndef move_state(\n    source: SnapshotStore,\n    target: SnapshotStore,\n    task_id: str,\n    version: int | None = None,\n    new_task_id: str | None = None,\n) -&gt; StateSnapshot | None:\n    snapshot = source.get(task_id, version=version)\n    if not snapshot:\n        return None\n    target_task_id = new_task_id or task_id\n    migrated = StateSnapshot(\n        id=generate_id(),\n        task_id=target_task_id,\n        version=snapshot.version,\n        data=dict(snapshot.data),\n        checkpoint=snapshot.checkpoint,\n        created_at=snapshot.created_at,\n    )\n    target.save(migrated)\n    return migrated\n</code></pre> <p>Run the full demo:</p> <pre><code>uv run python -m asap.examples.state_migration\n</code></pre>"},{"location":"best-practices/agent-failover-migration/#62-coordinator-detect-failure-and-trigger-handover","title":"6.2 Coordinator: detect failure and trigger handover","text":"<p>Pseudocode for a coordinator that uses health checks and shared storage (conceptual; adapt to your transport).</p> <pre><code># 1. Periodically check health\nprimary_healthy = await check_health(primary_url)  # GET /.well-known/asap/health\n\n# 2. If primary unhealthy, for each in-flight task_id:\nif not primary_healthy:\n    for task_id in in_flight_tasks:\n        # 3. Get snapshot from shared store (primary wrote there)\n        snapshot = shared_store.get(task_id)\n        if not snapshot:\n            continue  # or try StateQuery to primary as last resort\n        # 4. Ensure backup has the snapshot (if different store)\n        if backup_store != shared_store:\n            backup_store.save(snapshot)  # or send snapshot to backup via API\n        # 5. Tell backup to restore\n        await send_envelope_to_agent(backup_url, build_state_restore(task_id, snapshot.id))\n        # 6. Update routing: task_id -&gt; backup\n        routing[task_id] = backup_url\n</code></pre>"},{"location":"best-practices/agent-failover-migration/#63-worker-save-checkpoints-and-resume-from-store","title":"6.3 Worker: save checkpoints and resume from store","text":"<p>Worker agents should save snapshots at checkpoints and, on startup or when receiving <code>StateRestore</code>, load from the store and resume.</p> <pre><code>from asap.models.entities import StateSnapshot\nfrom asap.state import SnapshotStore\n\ndef resume_or_start(store: SnapshotStore, task_id: str) -&gt; dict:\n    snapshot = store.get(task_id)\n    if snapshot:\n        return snapshot.data  # Resume from this state\n    return {}  # Fresh start\n\n# In task handler: periodically\ndef on_checkpoint(store: SnapshotStore, task_id: str, state: dict) -&gt; None:\n    snapshot = StateSnapshot(\n        id=generate_id(),\n        task_id=task_id,\n        version=state[\"step\"],\n        data=state,\n        checkpoint=True,\n        created_at=datetime.now(timezone.utc),\n    )\n    store.save(snapshot)\n</code></pre>"},{"location":"best-practices/agent-failover-migration/#summary","title":"Summary","text":"Scenario Obtain state Restore on new agent Failover StateQuery or shared store StateRestore or shared store Migration Export from old store Import into new store + StateRestore (optional) Handover StateQuery or shared store StateRestore or shared store <ul> <li>Use StateQuery / StateRestore (or shared storage) so state transfer is consistent across implementations.</li> <li>Use https:// (or data:) for artifact URIs that must survive failover.</li> <li>Export StateSnapshot as JSON via <code>model_dump()</code> / <code>model_dump_json()</code> for backups or external systems.</li> <li>Run the state_migration example to validate the pattern end-to-end.</li> </ul>"},{"location":"deployment/kubernetes/","title":"Deploy ASAP Agent on Kubernetes","text":"<p>This guide walks through testing and deploying an ASAP Protocol agent on Kubernetes using minikube or kind, with Helm. Target: deploy and verify in under 10 minutes.</p>"},{"location":"deployment/kubernetes/#published-docker-images","title":"Published Docker images","text":"<p>On each release (git tag <code>v*</code>), the project builds and pushes a Docker image to GitHub Container Registry:</p> <ul> <li>Image: <code>ghcr.io/adriannoes/asap-protocol</code></li> <li>Tags: <code>latest</code>, <code>v1.0.0</code>, <code>v1.0</code>, <code>v1</code> (for release v1.0.0; other releases get <code>latest</code> and semver tags)</li> </ul> <p>To use the published image with Helm (no local build):</p> <pre><code>helm install asap-agent ./helm/asap-agent \\\n  --set image.repository=ghcr.io/adriannoes/asap-protocol \\\n  --set image.tag=v1.0.0\n</code></pre> <p>To pull locally: <code>docker pull ghcr.io/adriannoes/asap-protocol:latest</code></p>"},{"location":"deployment/kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker (for building the image and for kind/minikube)</li> <li>kubectl (install)</li> <li>Helm 3 (install)</li> <li>kind or minikube (one is enough):</li> <li>kind: <code>brew install kind</code> or see kind docs</li> <li>minikube: <code>brew install minikube</code> or see minikube docs</li> </ul>"},{"location":"deployment/kubernetes/#option-a-kind-recommended-for-ci-and-local-test","title":"Option A: kind (recommended for CI and local test)","text":""},{"location":"deployment/kubernetes/#1-create-cluster-and-build-image","title":"1. Create cluster and build image","text":"<pre><code># From repo root\ncd /path/to/asap-protocol\n\n# Create kind cluster (usually &lt; 1 min)\nkind create cluster --name asap-test\n\n# Build the Docker image\ndocker build -t asap-protocol:latest .\n\n# Load image into kind (no registry needed)\nkind load docker-image asap-protocol:latest --name asap-test\n</code></pre>"},{"location":"deployment/kubernetes/#2-install-with-helm","title":"2. Install with Helm","text":"<pre><code># Install the chart (release name = asap-agent)\nhelm install asap-agent ./helm/asap-agent \\\n  --set image.repository=asap-protocol \\\n  --set image.tag=latest \\\n  --set image.pullPolicy=IfNotPresent\n</code></pre>"},{"location":"deployment/kubernetes/#3-wait-for-pod-and-verify","title":"3. Wait for pod and verify","text":"<pre><code># Wait for deployment to be ready (default timeout 120s)\nkubectl wait --for=condition=ready pod -l app=asap-agent --timeout=120s\n\n# Port-forward and hit health endpoint\nkubectl port-forward svc/asap-agent 8000:8000 &amp;\nsleep 2\ncurl -s http://localhost:8000/health\n# Expected: {\"status\":\"ok\"}\n\ncurl -s http://localhost:8000/ready\n# Expected: {\"status\":\"ok\"}\n\n# Optional: manifest\ncurl -s http://localhost:8000/.well-known/asap/manifest.json | head -5\n\n# Stop port-forward\nkill %1 2&gt;/dev/null || true\n</code></pre>"},{"location":"deployment/kubernetes/#4-cleanup","title":"4. Cleanup","text":"<pre><code>kind delete cluster --name asap-test\n</code></pre>"},{"location":"deployment/kubernetes/#option-b-minikube","title":"Option B: minikube","text":""},{"location":"deployment/kubernetes/#1-start-minikube-and-build-image","title":"1. Start minikube and build image","text":"<pre><code>cd /path/to/asap-protocol\n\n# Start minikube (use docker driver; first run may take a few minutes)\nminikube start\n\n# Build image inside minikube's Docker daemon so no need to push\neval $(minikube docker-env)\ndocker build -t asap-protocol:latest .\n</code></pre>"},{"location":"deployment/kubernetes/#2-install-with-helm_1","title":"2. Install with Helm","text":"<pre><code>helm install asap-agent ./helm/asap-agent \\\n  --set image.repository=asap-protocol \\\n  --set image.tag=latest \\\n  --set image.pullPolicy=IfNotPresent\n</code></pre>"},{"location":"deployment/kubernetes/#3-wait-and-verify","title":"3. Wait and verify","text":"<pre><code>kubectl wait --for=condition=ready pod -l app=asap-agent --timeout=120s\nminikube service asap-agent --url\n# Or: kubectl port-forward svc/asap-agent 8000:8000\n# Then: curl http://localhost:8000/health\n</code></pre>"},{"location":"deployment/kubernetes/#4-cleanup_1","title":"4. Cleanup","text":"<pre><code>helm uninstall asap-agent\nminikube stop\n</code></pre>"},{"location":"deployment/kubernetes/#validating-the-chart-without-a-cluster","title":"Validating the chart without a cluster","text":"<p>To only check that the Helm chart renders valid manifests (no Docker/Kubernetes needed):</p> <pre><code># From repo root\nhelm template asap-agent ./helm/asap-agent\n</code></pre> <p>Exit code 0 means the chart is valid. You can also run the script:</p> <pre><code>./scripts/test_k8s_deploy.sh\n</code></pre> <p>That script runs <code>helm template</code> and, if <code>kind</code> and <code>helm</code> are available, optionally runs a full deploy test (create cluster, build image, load, install, verify /health, delete cluster) and reports elapsed time (target &lt; 10 minutes).</p>"},{"location":"deployment/kubernetes/#summary","title":"Summary","text":"Step kind minikube Create/start <code>kind create cluster</code> <code>minikube start</code> Build image <code>docker build</code> <code>eval $(minikube docker-env)</code> then <code>docker build</code> Load image <code>kind load docker-image</code> (built in minikube) Install <code>helm install ...</code> <code>helm install ...</code> Verify <code>kubectl wait</code> + <code>curl /health</code> same Cleanup <code>kind delete cluster</code> <code>helm uninstall</code> + <code>minikube stop</code> <p>Target: from zero to a working agent responding on <code>/health</code> and <code>/ready</code> in under 10 minutes.</p>"},{"location":"guides/compliance-testing/","title":"Compliance Testing (v1.2)","text":"<p>The asap-compliance package validates that ASAP agents follow the protocol specification. Use it to certify your agents are ASAP-compliant and interoperable.</p>"},{"location":"guides/compliance-testing/#installation","title":"Installation","text":"<pre><code>uv add asap-compliance\n# or\npip install asap-compliance\n</code></pre>"},{"location":"guides/compliance-testing/#quick-start","title":"Quick Start","text":"<p>Run compliance tests against a running agent:</p> <pre><code>pytest --asap-agent-url https://your-agent.example.com -m asap_compliance\n</code></pre> <p>Or set the URL via environment variable:</p> <pre><code>ASAP_AGENT_URL=https://your-agent.example.com pytest -m asap_compliance\n</code></pre>"},{"location":"guides/compliance-testing/#test-categories","title":"Test Categories","text":"Category What it validates handshake Agent reachable, health endpoint (200, application/json), manifest schema, signed manifest verification, version compatibility schema Envelope, TaskRequest, TaskResponse, McpToolResult, MessageAck; <code>extra=\"forbid\"</code> compliance state Task state machine transitions (PENDING \u2192 RUNNING \u2192 COMPLETED/FAILED) sla Task completes within timeout; progress schema valid (optional, requires echo skill)"},{"location":"guides/compliance-testing/#programmatic-usage","title":"Programmatic Usage","text":""},{"location":"guides/compliance-testing/#handshake-validation-against-live-agent","title":"Handshake validation (against live agent)","text":"<pre><code>from asap_compliance import ComplianceConfig, validate_handshake\n\nconfig = ComplianceConfig(agent_url=\"https://your-agent.example.com\")\nresult = validate_handshake(config)\nif result.passed:\n    print(\"Agent is compliant\")\nelse:\n    for check in result.checks:\n        if not check.passed:\n            print(f\"FAIL: {check.name} - {check.message}\")\n</code></pre>"},{"location":"guides/compliance-testing/#schema-validation-static-for-envelopepayload-dicts","title":"Schema validation (static, for envelope/payload dicts)","text":"<pre><code>from asap_compliance import validate_schema\n\nenvelope_dict = {\n    \"asap_version\": \"0.1\",\n    \"sender\": \"urn:asap:agent:a\",\n    \"recipient\": \"urn:asap:agent:b\",\n    \"payload_type\": \"task.request\",\n    \"payload\": {\"conversation_id\": \"conv-1\", \"skill_id\": \"echo\", \"input\": {}},\n}\nresult = validate_schema(envelope_dict)\nif result.passed:\n    print(\"Envelope and payload schema valid\")\n</code></pre>"},{"location":"guides/compliance-testing/#state-machine-validation","title":"State machine validation","text":"<pre><code>from asap_compliance import ComplianceConfig, validate_state_machine_async\n\nconfig = ComplianceConfig(\n    agent_url=\"https://your-agent.example.com\",\n    sla_skill_id=\"echo\",  # Agent must implement this skill\n)\nresult = await validate_state_machine_async(config)\nif result.passed:\n    print(\"State transitions correct\")\n</code></pre>"},{"location":"guides/compliance-testing/#configuration","title":"Configuration","text":"Option Default Description <code>agent_url</code> Required Base URL of the agent under test <code>timeout_seconds</code> 30.0 HTTP timeout <code>test_categories</code> handshake, schema, state Categories to run <code>sla_skill_id</code> echo Skill ID for SLA and state validation <code>skip_checks</code> [] Check names to skip (e.g. <code>sla</code>)"},{"location":"guides/compliance-testing/#requirements-for-compliance","title":"Requirements for Compliance","text":"<ol> <li>Health endpoint: <code>GET /.well-known/asap/health</code> returns 200 with <code>application/json</code></li> <li>Manifest endpoint: <code>GET /.well-known/asap/manifest.json</code> returns valid manifest (plain or signed)</li> <li>ASAP endpoint: <code>POST /asap</code> accepts JSON-RPC with envelope, returns valid response</li> <li>Echo skill: For full pipeline, agent must implement <code>echo</code> skill (or set <code>sla_skill_id</code> to match)</li> <li>Schema: Envelope and payloads must pass Pydantic validation with <code>extra=\"forbid\"</code></li> </ol>"},{"location":"guides/compliance-testing/#signed-manifests","title":"Signed Manifests","text":"<p>The handshake validator accepts both plain and signed manifests. If the agent returns a signed manifest (v1.2), the harness verifies the Ed25519 signature before proceeding.</p>"},{"location":"guides/compliance-testing/#see-also","title":"See Also","text":"<ul> <li>asap-compliance README \u2014 Package overview</li> <li>Identity Signing \u2014 How to sign manifests</li> <li>Testing \u2014 General testing guide for ASAP development</li> </ul>"},{"location":"guides/identity-signing/","title":"Identity Signing (v1.2)","text":"<p>Ed25519 signed manifests provide verifiable agent identity. Agents can sign their manifests so that clients can verify authenticity and detect tampering.</p>"},{"location":"guides/identity-signing/#overview","title":"Overview","text":"<ul> <li>Algorithm: Ed25519 (64-byte signatures)</li> <li>Canonicalization: JCS (RFC 8785) for deterministic JSON before signing</li> <li>Trust levels: Self-signed, Verified (simulated), Enterprise</li> </ul>"},{"location":"guides/identity-signing/#quick-start","title":"Quick Start","text":""},{"location":"guides/identity-signing/#1-generate-a-keypair","title":"1. Generate a keypair","text":"<pre><code>asap keys generate -o agent-key.pem\n</code></pre> <p>The key file is created with mode <code>0600</code> (owner read/write only).</p>"},{"location":"guides/identity-signing/#2-sign-a-manifest","title":"2. Sign a manifest","text":"<pre><code>asap manifest sign -k agent-key.pem manifest.json -o signed-manifest.json\n</code></pre> <p>Or output to stdout:</p> <pre><code>asap manifest sign -k agent-key.pem manifest.json\n</code></pre>"},{"location":"guides/identity-signing/#3-verify-a-signed-manifest","title":"3. Verify a signed manifest","text":"<pre><code>asap manifest verify signed-manifest.json\n</code></pre> <p>If the manifest includes <code>public_key</code>, verification uses it. Otherwise, pass <code>--public-key</code>:</p> <pre><code>asap manifest verify signed-manifest.json --public-key agent-key.pem\n</code></pre>"},{"location":"guides/identity-signing/#4-show-manifest-info-trust-level","title":"4. Show manifest info (trust level)","text":"<pre><code>asap manifest info signed-manifest.json\n</code></pre> <p>Output includes Manifest ID, name, trust level, and ASAP version.</p>"},{"location":"guides/identity-signing/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>from asap.crypto.keys import generate_keypair, load_private_key_from_file_sync\nfrom asap.crypto.signing import sign_manifest, verify_manifest\nfrom asap.models.entities import Manifest, Capability, Endpoint, Skill, SLADefinition\n\nmanifest = Manifest(\n    id=\"urn:asap:agent:my-agent\",\n    name=\"My Agent\",\n    version=\"1.0.0\",\n    description=\"Signed agent\",\n    capabilities=Capability(\n        asap_version=\"0.1\",\n        skills=[Skill(id=\"echo\", description=\"Echo\")],\n        state_persistence=False,\n    ),\n    endpoints=Endpoint(asap=\"https://api.example.com/asap\"),\n    sla=SLADefinition(availability=\"99.5%\", max_latency_p95_ms=500, support_hours=\"24/7\"),\n)\n\n# Sign\nprivate_key, _ = generate_keypair()\nsigned = sign_manifest(manifest, private_key)\n\n# Verify\nverify_manifest(signed)  # Uses public_key from signed manifest\n</code></pre>"},{"location":"guides/identity-signing/#client-side-verification","title":"Client-Side Verification","text":"<p><code>ASAPClient</code> can optionally verify signed manifests when fetching:</p> <pre><code>from asap.transport.client import ASAPClient\n\n# With trusted public key for a specific URL\ntrusted = {\n    \"https://api.example.com/.well-known/asap/manifest.json\": \"base64-public-key\",\n}\nasync with ASAPClient(\n    \"https://api.example.com\",\n    verify_signatures=True,\n    trusted_manifest_keys=trusted,\n) as client:\n    manifest = await client.get_manifest()\n</code></pre> <p>If the manifest is signed and includes <code>public_key</code>, the client can verify without pre-configuring trusted keys (trust level is still self-signed unless the key is in an allowlist).</p>"},{"location":"guides/identity-signing/#trust-levels","title":"Trust Levels","text":"Level Description self-signed Agent signs with its own key; <code>public_key</code> in manifest verified Simulated in v1.2; actual verification service in v2.0 enterprise CA-signed; requires <code>sign_with_ca</code> and enterprise PKI"},{"location":"guides/identity-signing/#cli-reference","title":"CLI Reference","text":"Command Description <code>asap keys generate -o FILE</code> Generate Ed25519 keypair, write private key to FILE <code>asap manifest sign -k KEY MANIFEST [--out FILE]</code> Sign manifest JSON; output to file or stdout <code>asap manifest verify SIGNED [--public-key KEY]</code> Verify Ed25519 signature <code>asap manifest info SIGNED</code> Show manifest ID, name, trust level, ASAP version"},{"location":"guides/identity-signing/#see-also","title":"See Also","text":"<ul> <li>mTLS \u2014 Optional mutual TLS for transport security</li> <li>v1.1 Security Model \u2014 OAuth2 trust limitations</li> <li>Compliance Testing \u2014 Validate agents with asap-compliance</li> </ul>"},{"location":"guides/migration-v1.1-to-v1.2/","title":"Migration Guide: v1.1 \u2192 v1.2","text":"<p>Upgrade steps for moving from ASAP Protocol v1.1.0 to v1.2.0.</p>"},{"location":"guides/migration-v1.1-to-v1.2/#overview","title":"Overview","text":"<p>v1.2.0 adds Verified Identity features while remaining backward compatible with v1.1.0:</p> <ul> <li>Ed25519 signed manifests</li> <li>Trust levels (self-signed, verified, enterprise)</li> <li>Optional mTLS for transport</li> <li>Compliance harness (<code>asap-compliance</code> package)</li> </ul> <p>No breaking changes. Existing agents and clients continue to work without modification.</p>"},{"location":"guides/migration-v1.1-to-v1.2/#upgrade-steps","title":"Upgrade Steps","text":""},{"location":"guides/migration-v1.1-to-v1.2/#1-update-dependencies","title":"1. Update dependencies","text":"<pre><code>uv add \"asap-protocol&gt;=1.2.0\"\n# or\npip install --upgrade asap-protocol\n</code></pre>"},{"location":"guides/migration-v1.1-to-v1.2/#2-optional-add-signed-manifests","title":"2. (Optional) Add signed manifests","text":"<p>If you want verifiable agent identity:</p> <ol> <li>Generate a keypair: <code>asap keys generate -o agent-key.pem</code></li> <li>Sign your manifest: <code>asap manifest sign -k agent-key.pem manifest.json -o signed.json</code></li> <li>Serve the signed manifest from <code>GET /.well-known/asap/manifest.json</code></li> </ol> <p>The server's <code>create_app(manifest)</code> accepts a plain <code>Manifest</code>. To serve a signed manifest, you need to return the signed JSON from the well-known endpoint (e.g. by using a custom route or extending the server).</p>"},{"location":"guides/migration-v1.1-to-v1.2/#3-optional-enable-client-side-verification","title":"3. (Optional) Enable client-side verification","text":"<p>If you want clients to verify signed manifests:</p> <pre><code>from asap.transport.client import ASAPClient\n\ntrusted_keys = {\n    \"https://agent.example.com/.well-known/asap/manifest.json\": \"base64-public-key\",\n}\nasync with ASAPClient(\n    \"https://agent.example.com\",\n    verify_signatures=True,\n    trusted_manifest_keys=trusted_keys,\n) as client:\n    manifest = await client.get_manifest()\n</code></pre>"},{"location":"guides/migration-v1.1-to-v1.2/#4-optional-add-mtls","title":"4. (Optional) Add mTLS","text":"<p>For enterprise deployments with mutual TLS:</p> <pre><code>from asap.transport.mtls import MTLSConfig, create_ssl_context\nfrom asap.transport.server import create_app\n\nmtls_config = MTLSConfig(\n    cert_file=\"/path/to/cert.pem\",\n    key_file=\"/path/to/key.pem\",\n    ca_certs=\"/path/to/ca.pem\",  # Optional\n)\napp = create_app(manifest, mtls_config=mtls_config)\n</code></pre>"},{"location":"guides/migration-v1.1-to-v1.2/#5-optional-run-compliance-tests","title":"5. (Optional) Run compliance tests","text":"<p>Validate your agent with the compliance harness:</p> <pre><code>uv add asap-compliance\npytest --asap-agent-url https://your-agent.example.com -m asap_compliance\n</code></pre>"},{"location":"guides/migration-v1.1-to-v1.2/#what-stays-the-same","title":"What Stays the Same","text":"<ul> <li>All v1.1 APIs (OAuth2, WebSocket, Discovery, State Storage, Webhooks)</li> <li>Envelope and payload schemas</li> <li>JSON-RPC binding</li> <li>Lite Registry and well-known discovery</li> <li>Plain (unsigned) manifests still accepted everywhere</li> </ul>"},{"location":"guides/migration-v1.1-to-v1.2/#deferred-items-not-in-v12","title":"Deferred Items (not in v1.2)","text":"<ul> <li>Registry API: Centralized agent registry backend (v2.1)</li> <li>DeepEval integration: Intelligence layer for compliance (v2.2+)</li> </ul>"},{"location":"guides/migration-v1.1-to-v1.2/#see-also","title":"See Also","text":"<ul> <li>Identity Signing \u2014 How to sign manifests</li> <li>Compliance Testing \u2014 Validate agents</li> <li>mTLS \u2014 Mutual TLS configuration</li> </ul>"},{"location":"guides/registry-verification-review/","title":"Registry Verification Review (Admin Guide)","text":"<p>This guide is for maintainers who review Verified badge requests for agents in the ASAP Lite Registry. Verification is manual: requests arrive as GitHub issues; after review, you approve or reject via issue comments and (once the protocol schema supports it) update <code>registry.json</code>.</p>"},{"location":"guides/registry-verification-review/#finding-verification-requests","title":"Finding verification requests","text":"<ol> <li>Open the repository\u2019s Issues tab.</li> <li>Filter by labels: <code>verification-request</code> and <code>pending-review</code>.</li> <li>Each issue is created from the Request Verification form and contains:</li> <li>Agent ID (URN) \u2014 must already exist in the registry.</li> <li>Why should this agent be verified? \u2014 justification and trust signals.</li> <li>How long has it been running? \u2014 approximate duration.</li> <li>Evidence of reliability \u2014 links to uptime, dashboards, SLA.</li> <li>Contact info \u2014 how to reach the submitter.</li> </ol>"},{"location":"guides/registry-verification-review/#review-checklist","title":"Review checklist","text":"<p>Use this to decide whether to approve or reject a verification request.</p>"},{"location":"guides/registry-verification-review/#1-agent-is-listed","title":"1. Agent is listed","text":"<ul> <li>Confirm the Agent ID appears in <code>registry.json</code> (or the current registry source).</li> <li>If the agent is not listed, close the issue and comment that they must register the agent first (via the registration flow).</li> </ul>"},{"location":"guides/registry-verification-review/#2-uptime-and-reliability","title":"2. Uptime and reliability","text":"<ul> <li>If the issue includes evidence (uptime URLs, status pages, dashboards), open the links and check they work and support the claims.</li> <li>Prefer agents that have been running for a meaningful period (e.g. weeks or months) and can show stability (e.g. uptime %, SLA).</li> </ul>"},{"location":"guides/registry-verification-review/#3-code-and-transparency-if-open-source","title":"3. Code and transparency (if open source)","text":"<ul> <li>If the agent has a repository_url in the registry (or linked in the issue), do a lightweight review:</li> <li>Repo is accessible and looks like a real project.</li> <li>No obvious security or abuse concerns (e.g. hardcoded secrets, obviously malicious behavior).</li> <li>You are not required to do a full code audit; focus on basic trust and hygiene.</li> </ul>"},{"location":"guides/registry-verification-review/#4-contact-and-legitimacy","title":"4. Contact and legitimacy","text":"<ul> <li>Use contact info from the issue to confirm the submitter is reachable (e.g. GitHub user, email).</li> <li>If the request is vague, lacks evidence, or the agent is very new with no history, you may request more information in a comment or reject.</li> </ul>"},{"location":"guides/registry-verification-review/#5-decision","title":"5. Decision","text":"<ul> <li>Approve: Comment on the issue that the agent is approved for the Verified badge. Once the protocol schema supports a <code>verification</code> field (see below), add the verification details to the agent in <code>registry.json</code>.</li> <li>Reject: Comment clearly why (e.g. \u201cAgent not listed\u201d, \u201cInsufficient evidence of uptime\u201d, \u201cCould not verify contact\u201d). Close the issue.</li> </ul>"},{"location":"guides/registry-verification-review/#updating-the-registry-with-verification-after-schema-support","title":"Updating the registry with verification (after schema support)","text":"<p>Today, the registry and protocol schema do not yet define a <code>verification</code> field. When they do (see Task 3.6 in the v2.0 roadmap):</p> <ol> <li>Open <code>registry.json</code> in the repo.</li> <li>Find the agent entry by id (URN).</li> <li>Add a <code>verification</code> object, for example:</li> </ol> <p><code>json    {      \"id\": \"urn:asap:agent:username:agent-name\",      \"name\": \"My Agent\",      \"verification\": {        \"status\": \"verified\",        \"verified_at\": \"2025-02-21T12:00:00Z\"      }    }</code></p> <ol> <li>Commit and push (or open a PR). The web app and clients can then show the Verified badge for that agent.</li> </ol> <p>Until the schema is updated, recording approval in the issue comment is sufficient; you can add the <code>verification</code> block to <code>registry.json</code> once the codebase supports it.</p>"},{"location":"guides/registry-verification-review/#summary","title":"Summary","text":"Step Action Find requests Issues with labels <code>verification-request</code>, <code>pending-review</code> Vet Uptime/reliability evidence, code review if open source, contact/legitimacy Respond Comment approve or reject; close the issue Persist (later) After 3.6, add <code>verification</code> to the agent in <code>registry.json</code>"},{"location":"security/mtls/","title":"mTLS (Mutual TLS) Setup","text":"<p>Optional mutual TLS for ASAP transport (SD-6). mTLS provides certificate-based authentication for both client and server in enterprise deployments. mTLS is optional and never required.</p>"},{"location":"security/mtls/#overview","title":"Overview","text":"<ul> <li>Server: Presents its certificate to clients; optionally requires client certificates.</li> <li>Client: Presents its certificate to the server; verifies the server's certificate.</li> <li>Use cases: Enterprise networks, zero-trust architectures, regulated industries.</li> </ul>"},{"location":"security/mtls/#certificate-generation","title":"Certificate Generation","text":""},{"location":"security/mtls/#self-signed-ca-and-certificates-developmenttesting","title":"Self-Signed CA and Certificates (Development/Testing)","text":"<pre><code># Create CA\nopenssl genrsa -out ca.key 4096\nopenssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt \\\n  -subj \"/CN=ASAP-Test-CA\"\n\n# Server certificate\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -out server.csr -subj \"/CN=localhost\"\nopenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\\n  -out server.crt -days 365 -sha256\n\n# Client certificate\nopenssl genrsa -out client.key 2048\nopenssl req -new -key client.key -out client.csr -subj \"/CN=asap-client\"\nopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\\n  -out client.crt -days 365 -sha256\n</code></pre>"},{"location":"security/mtls/#production","title":"Production","text":"<p>Use your organization's PKI or a public CA. Ensure: - Server cert has correct SAN (Subject Alternative Name) for your hostname. - Client certs are issued by a CA the server trusts. - Keys are stored with restrictive permissions (e.g. <code>chmod 600</code>).</p>"},{"location":"security/mtls/#server-configuration","title":"Server Configuration","text":""},{"location":"security/mtls/#1-create-mtls-config","title":"1. Create mTLS Config","text":"<pre><code>from asap.transport.mtls import MTLSConfig\nfrom asap.transport.server import create_app\nfrom asap.models.entities import Manifest, Capability, Endpoint, Skill\n\nmtls_config = MTLSConfig(\n    cert_file=\"server.crt\",\n    key_file=\"server.key\",\n    ca_certs=\"ca.crt\",  # CA to verify client certs; omit to skip client verification\n)\n\nmanifest = Manifest(\n    id=\"urn:asap:agent:my-agent\",\n    name=\"My Agent\",\n    version=\"1.0.0\",\n    description=\"mTLS-protected agent\",\n    capabilities=Capability(\n        asap_version=\"0.1\",\n        skills=[Skill(id=\"echo\", description=\"Echo\")],\n        state_persistence=False,\n    ),\n    endpoints=Endpoint(asap=\"https://localhost:8443/asap\"),\n)\napp = create_app(manifest, mtls_config=mtls_config)\n</code></pre>"},{"location":"security/mtls/#2-run-uvicorn-with-ssl","title":"2. Run Uvicorn with SSL","text":"<pre><code>import uvicorn\nfrom asap.transport.mtls import mtls_config_to_uvicorn_kwargs\n\n# Get uvicorn SSL kwargs from mtls_config\nssl_kwargs = mtls_config_to_uvicorn_kwargs(mtls_config)\n\nuvicorn.run(\n    app,\n    host=\"0.0.0.0\",\n    port=8443,\n    **ssl_kwargs,\n)\n</code></pre> <p>Or via CLI:</p> <pre><code>uvicorn asap.transport.server:app --host 0.0.0.0 --port 8443 \\\n  --ssl-keyfile server.key \\\n  --ssl-certfile server.crt \\\n  --ssl-ca-certs ca.crt \\\n  --ssl-cert-reqs 2\n</code></pre> <p>(<code>--ssl-cert-reqs 2</code> = <code>CERT_REQUIRED</code>)</p>"},{"location":"security/mtls/#client-configuration","title":"Client Configuration","text":"<pre><code>from asap.transport.client import ASAPClient\nfrom asap.transport.mtls import MTLSConfig\n\nmtls_config = MTLSConfig(\n    cert_file=\"client.crt\",\n    key_file=\"client.key\",\n    ca_certs=\"ca.crt\",  # CA to verify server; omit for system default\n)\n\nasync with ASAPClient(\n    \"https://localhost:8443\",\n    mtls_config=mtls_config,\n) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"security/mtls/#websocket-with-mtls","title":"WebSocket with mTLS","text":"<p>Both HTTP and WebSocket transports support mTLS. When <code>mtls_config</code> is provided to <code>ASAPClient</code>, it applies to: - HTTP requests (POST /asap) - WebSocket connections (wss://) - Manifest fetches</p>"},{"location":"security/mtls/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Servers without <code>mtls_config</code> run as before (plain HTTP or TLS without client certs).</li> <li>Clients without <code>mtls_config</code> connect without presenting a client certificate.</li> <li>mTLS is opt-in; existing deployments are unaffected.</li> </ul>"},{"location":"security/mtls/#security-notes","title":"Security Notes","text":"<ul> <li>Store private keys with <code>chmod 600</code>; never commit them.</li> <li>Use environment variables or secrets managers for paths in production.</li> <li>Rotate certificates before expiry; monitor expiration dates.</li> <li>For <code>ca_certs</code>, use a CA that only signs known clients/servers.</li> </ul>"},{"location":"security/v1.1-security-model/","title":"v1.1 Security Model","text":"<p>Trust model, identity binding, and security limitations for ASAP Protocol v1.1. See ADR-17 for the decision record.</p>"},{"location":"security/v1.1-security-model/#summary","title":"Summary","text":"What v1.1 provides What v1.1 does NOT provide Authentication \u2014 valid credentials from an IdP (OAuth2/OIDC) Identity verification \u2014 proof that the client is the agent it claims to be Authorization \u2014 scopes (e.g. <code>asap:execute</code>) Cryptographic binding \u2014 that binding comes in v1.2 (Ed25519 signed manifests) Identity mapping \u2014 Custom Claims or allowlist to map JWT \u2192 agent URN Impersonation prevention \u2014 without signed manifests, trust is \u201cvalid token + claim/match\u201d only <p>This is the same trust model as most web APIs today: OAuth2 is analogous to API keys with scopes. Real identity verification (PKI) is layered in later (v1.2).</p>"},{"location":"security/v1.1-security-model/#v11-trust-model","title":"v1.1 Trust Model","text":""},{"location":"security/v1.1-security-model/#authentication-what-you-get","title":"Authentication (what you get)","text":"<ul> <li>The server validates the Bearer JWT using the IdP\u2019s JWKS (signature, expiry, issuer/audience if configured).</li> <li>If the token is valid, the request is authenticated: the caller has valid credentials from the IdP.</li> <li>Optional scope checks (e.g. <code>required_scope=\"asap:execute\"</code>) enforce authorization.</li> </ul>"},{"location":"security/v1.1-security-model/#what-is-not-guaranteed","title":"What is NOT guaranteed","text":"<ul> <li>Identity verification: v1.1 does not prove that the caller \u201cis\u201d the agent URN it sends in the envelope. It only proves \u201cthis token was issued by the IdP and (optionally) carries a claim or allowlist mapping to this agent.\u201d</li> <li>Impersonation: A compromised token or a misconfigured IdP could allow one agent to act under another\u2019s URN until you add v1.2 signed manifests and (optionally) mTLS.</li> </ul>"},{"location":"security/v1.1-security-model/#analogy-stripe-style-trust","title":"Analogy: Stripe-style trust","text":"<ul> <li>v1.0: API key \u2192 \u201cwhoever has the key can call the API.\u201d</li> <li>v1.1: OAuth2 + Custom Claims \u2192 \u201cwhoever has a valid token with the right claim/allowlist can act as this agent.\u201d (Same as \u201cAPI key + scope\u201d in practice.)</li> <li>v1.2: Signed manifests (Ed25519) \u2192 \u201conly the holder of the private key for this manifest can prove they are this agent.\u201d (KYC/identity layer.)</li> </ul> <p>Documenting this explicitly avoids false expectations that v1.1 alone gives \u201cverified agent identity.\u201d</p>"},{"location":"security/v1.1-security-model/#threat-model-v11","title":"Threat Model (v1.1)","text":""},{"location":"security/v1.1-security-model/#in-scope-and-mitigated","title":"In scope and mitigated","text":"Threat Mitigation Forged or expired tokens JWT validation (signature, <code>exp</code>); JWKS from IdP Missing or insufficient scope <code>required_scope</code> in OAuth2Config Sender \u2260 authenticated agent Envelope <code>sender</code> must match authenticated agent (Custom Claim or allowlist) Replay (optional) Nonce validation when <code>require_nonce=True</code> SSRF on webhooks URL validation (private IPs, localhost blocked; HTTPS in production) Abuse / DoS Rate limiting (per-sender, configurable)"},{"location":"security/v1.1-security-model/#known-limitations-v11","title":"Known limitations (v1.1)","text":"Limitation Mitigation No cryptographic proof of agent identity Use v1.2 signed manifests (Ed25519) when available IdP misconfiguration can map wrong <code>sub</code> to agent Rely on Custom Claims where possible; restrict allowlist; audit IdP config Token theft = full agent capability Short-lived tokens; secure storage; consider v1.2 + mTLS for high-assurance"},{"location":"security/v1.1-security-model/#configuring-custom-claims","title":"Configuring Custom Claims","text":"<p>Identity binding maps the JWT to the ASAP agent URN so that the server can enforce \u201cenvelope <code>sender</code> = authenticated agent.\u201d</p>"},{"location":"security/v1.1-security-model/#option-1-custom-claim-recommended","title":"Option 1: Custom Claim (recommended)","text":"<ul> <li>The IdP adds a custom claim to the JWT whose value is the agent URN (e.g. <code>urn:asap:agent:research-v1</code>).</li> <li>The ASAP server reads this claim and checks it equals the manifest <code>id</code>. If not, the request is rejected (403).</li> </ul> <p>Environment variable</p> <ul> <li><code>ASAP_AUTH_CUSTOM_CLAIM</code>: JWT claim key (URI or string).  </li> <li>Default (if unset): <code>https://github.com/adriannoes/asap-protocol/agent_id</code></li> <li>Example: <code>ASAP_AUTH_CUSTOM_CLAIM=https://github.com/adriannoes/asap-protocol/agent_id</code></li> <li>Future namespace: <code>https://asap-protocol.com/agent_id</code> will be the canonical claim URI when the domain is available; until then, the GitHub URL is used.</li> </ul> <p>Code</p> <p>When creating the app, pass <code>OAuth2Config(..., manifest_id=manifest.id)</code>. The middleware uses <code>manifest_id</code> for this check. You can override the claim key with <code>OAuth2Config(..., custom_claim=\"https://github.com/adriannoes/asap-protocol/agent_id\")</code>.</p>"},{"location":"security/v1.1-security-model/#option-2-allowlist-fallback","title":"Option 2: Allowlist fallback","text":"<p>When the IdP cannot add custom claims, you can map \u201cmanifest id \u2192 allowed <code>sub</code> (or list of subs)\u201d via environment.</p> <p>Environment variable</p> <ul> <li><code>ASAP_AUTH_SUBJECT_MAP</code>: JSON object. Keys = agent URNs (manifest id), values = single <code>sub</code> string or list of <code>sub</code> strings.</li> </ul> <p>Example</p> <pre><code>export ASAP_AUTH_SUBJECT_MAP='{\"urn:asap:agent:research-v1\":\"auth0|abc123\"}'\n</code></pre> <p>Multiple subs for one agent:</p> <pre><code>export ASAP_AUTH_SUBJECT_MAP='{\"urn:asap:agent:bot\":[\"auth0|id1\",\"auth0|id2\"]}'\n</code></pre> <p>If the JWT has no custom claim (or the claim key is missing), the server falls back to this map. If <code>sub</code> is in the allowlist for this manifest id, the request is accepted. Prefer Custom Claims where possible; allowlist is for environments that cannot emit custom claims.</p>"},{"location":"security/v1.1-security-model/#custom-claims-provider-specific-guides","title":"Custom Claims: Provider-specific guides","text":""},{"location":"security/v1.1-security-model/#auth0","title":"Auth0","text":"<ol> <li>In the Auth0 Dashboard, go to Applications \u2192 your Application \u2192 Settings.</li> <li>Use Rules (Classic) or Actions (recommended) to add a claim to the token.</li> <li>Add the agent URN to <code>idToken</code> and/or <code>accessToken</code> under the claim name that matches <code>ASAP_AUTH_CUSTOM_CLAIM</code> (default: <code>https://github.com/adriannoes/asap-protocol/agent_id</code>).</li> </ol> <p>Example Rule (Classic):</p> <pre><code>function addAgentId(user, context, callback) {\n  context.idToken['https://github.com/adriannoes/asap-protocol/agent_id'] = 'urn:asap:agent:my-bot';\n  context.accessToken['https://github.com/adriannoes/asap-protocol/agent_id'] = 'urn:asap:agent:my-bot';\n  callback(null, user, context);\n}\n</code></pre> <p>Actions: Create an Action that runs at \u201cLogin / Post Login\u201d, and set <code>event.idToken['https://github.com/adriannoes/asap-protocol/agent_id'] = 'urn:asap:agent:my-bot'</code> (and same for <code>event.accessToken</code> if you use access tokens for ASAP). See Auth0 Rules and Actions.</p>"},{"location":"security/v1.1-security-model/#keycloak","title":"Keycloak","text":"<ol> <li>Go to Client Scopes (or your client\u2019s scopes).</li> <li>Create or select a scope and add a Mapper (e.g. \u201cBy configuration\u201d \u2192 \u201cUser Attribute\u201d or \u201cHardcoded claim\u201d).</li> <li>Set Token Claim Name to the same value as <code>ASAP_AUTH_CUSTOM_CLAIM</code> (default: <code>https://github.com/adriannoes/asap-protocol/agent_id</code>).</li> <li>Set the claim value to the agent URN (e.g. from a user attribute or hardcoded for machine-to-machine).</li> </ol> <p>For client credentials / service accounts, a \u201cHardcoded claim\u201d mapper with value <code>urn:asap:agent:my-bot</code> is typical. See Keycloak Client Scopes and Protocol Mappers.</p>"},{"location":"security/v1.1-security-model/#azure-ad-microsoft-entra-id","title":"Azure AD (Microsoft Entra ID)","text":"<ol> <li>App registration \u2192 your app \u2192 Token configuration (or Optional claims for ID tokens).</li> <li>Add an optional claim or use App roles to encode which agent can act.</li> <li>For a custom claim name matching <code>ASAP_AUTH_CUSTOM_CLAIM</code>, you can use Application claims (e.g. via custom security attributes or claims mapping).</li> </ol> <p>Alternatively, use App roles (e.g. role name = agent URN or a short id) and map that role to a claim; then in ASAP you could use the allowlist to map <code>sub</code> + role to agent URN. For a direct custom claim: - Optional claims: Add a custom claim (name = your <code>ASAP_AUTH_CUSTOM_CLAIM</code> URI) if your tenant supports it. - Claims mapping: In the app manifest, define <code>optionalClaims</code> or use claims mapping policies to emit <code>https://github.com/adriannoes/asap-protocol/agent_id</code> (or your chosen URI) with value <code>urn:asap:agent:my-bot</code>.</p> <p>See Optional claims and App roles.</p>"},{"location":"security/v1.1-security-model/#migration-path-to-v12","title":"Migration path to v1.2","text":"<ul> <li>v1.1: Identity is \u201cvalid token + Custom Claim or allowlist.\u201d No cryptographic proof of agent identity.</li> <li>v1.2: Signed manifests (Ed25519) allow the registry and other agents to verify that a given manifest (and thus agent URN) is bound to a key. That adds identity verification on top of OAuth2.</li> <li>Recommendation: Use v1.1 OAuth2 + Custom Claims (or allowlist) now; plan to adopt v1.2 signed manifests and (optionally) mTLS for high-assurance deployments.</li> </ul>"},{"location":"security/v1.1-security-model/#references","title":"References","text":"<ul> <li>ADR-17: Trust Model and Identity Binding</li> <li>Security Guide \u2014 general ASAP security (rate limits, nonce, HTTPS, etc.)</li> <li>Transport \u2014 OAuth2 middleware and <code>create_app</code> usage</li> </ul>"},{"location":"tutorials/first-agent/","title":"Building Your First Agent","text":"<p>Time: ~15 minutes | Level: Beginner</p> <p>This tutorial walks you through building and running your first ASAP agent: an echo agent that receives task requests and echoes the input back. You will set up the server, send a request from a client, and verify it works.</p>"},{"location":"tutorials/first-agent/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.13 or later</li> <li>uv (recommended) or pip</li> </ul>"},{"location":"tutorials/first-agent/#step-1-install-asap","title":"Step 1: Install ASAP","text":"<p>From your project directory:</p> <pre><code># Using uv (recommended)\nuv add asap-protocol\n\n# Using pip\npip install asap-protocol\n</code></pre>"},{"location":"tutorials/first-agent/#step-2-run-the-echo-agent-server","title":"Step 2: Run the Echo Agent Server","text":"<p>ASAP includes a minimal echo agent. Start it on port 8001:</p> <pre><code>uv run python -m asap.examples.echo_agent --host 127.0.0.1 --port 8001\n</code></pre> <p>Keep this terminal open. You should see the server start and listen on <code>http://127.0.0.1:8001</code>.</p>"},{"location":"tutorials/first-agent/#step-3-write-your-first-client","title":"Step 3: Write Your First Client","text":"<p>In a new terminal, create a file <code>my_client.py</code>:</p> <pre><code>import asyncio\nfrom asap.models.envelope import Envelope\nfrom asap.models.ids import generate_id\nfrom asap.models.payloads import TaskRequest\nfrom asap.transport.client import ASAPClient\n\n\nasync def main() -&gt; None:\n    # 1. Build the task request\n    request = TaskRequest(\n        conversation_id=generate_id(),\n        skill_id=\"echo\",\n        input={\"message\": \"Hello from my first ASAP client!\"},\n    )\n\n    # 2. Wrap it in an envelope\n    envelope = Envelope(\n        asap_version=\"0.1\",\n        sender=\"urn:asap:agent:my-client\",\n        recipient=\"urn:asap:agent:echo-agent\",\n        payload_type=\"task.request\",\n        payload=request.model_dump(),\n        trace_id=generate_id(),\n    )\n\n    # 3. Send and get the response\n    async with ASAPClient(\"http://127.0.0.1:8001\") as client:\n        response = await client.send(envelope)\n\n    print(\"Response:\", response.payload)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Run it:</p> <pre><code>uv run python my_client.py\n</code></pre> <p>You should see the echoed payload printed.</p>"},{"location":"tutorials/first-agent/#step-4-understand-the-server","title":"Step 4: Understand the Server","text":"<p>The echo agent has three main pieces:</p>"},{"location":"tutorials/first-agent/#manifest","title":"Manifest","text":"<p>The manifest describes the agent and its capabilities. The echo agent exposes:</p> <ul> <li>ID: <code>urn:asap:agent:echo-agent</code></li> <li>Skill: <code>echo</code> \u2014 echoes the input</li> <li>Endpoint: <code>http://127.0.0.1:8001/asap</code> \u2014 where it receives messages</li> </ul>"},{"location":"tutorials/first-agent/#handler-registry","title":"Handler Registry","text":"<p>The server registers a handler for <code>task.request</code> messages:</p> <pre><code>from asap.transport.handlers import HandlerRegistry, create_echo_handler\n\nregistry = HandlerRegistry()\nregistry.register(\"task.request\", create_echo_handler())\n</code></pre>"},{"location":"tutorials/first-agent/#fastapi-app","title":"FastAPI App","text":"<p>The server uses <code>create_app(manifest, registry)</code> to build a FastAPI app with:</p> <ul> <li><code>POST /asap</code> \u2014 receives ASAP envelopes (JSON-RPC 2.0)</li> <li><code>GET /.well-known/asap/manifest.json</code> \u2014 agent manifest for discovery</li> </ul>"},{"location":"tutorials/first-agent/#step-5-build-your-own-echo-agent-optional","title":"Step 5: Build Your Own Echo Agent (Optional)","text":"<p>Create <code>my_echo_agent.py</code>:</p> <pre><code>from fastapi import FastAPI\nimport uvicorn\n\nfrom asap.models.entities import Capability, Endpoint, Manifest, Skill\nfrom asap.transport.handlers import HandlerRegistry, create_echo_handler\nfrom asap.transport.server import create_app\n\nmanifest = Manifest(\n    id=\"urn:asap:agent:my-echo\",\n    name=\"My Echo Agent\",\n    version=\"0.1.0\",\n    description=\"Echoes task input\",\n    capabilities=Capability(\n        asap_version=\"0.1\",\n        skills=[Skill(id=\"echo\", description=\"Echo back the input\")],\n        state_persistence=False,\n    ),\n    endpoints=Endpoint(asap=\"http://127.0.0.1:8002/asap\"),\n)\n\nregistry = HandlerRegistry()\nregistry.register(\"task.request\", create_echo_handler())\n\napp = create_app(manifest, registry)\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8002)\n</code></pre> <p>Run it and point your client at <code>http://127.0.0.1:8002</code> to use your custom agent.</p>"},{"location":"tutorials/first-agent/#step-6-test-with-the-full-demo","title":"Step 6: Test With the Full Demo","text":"<p>ASAP includes a full demo that starts the echo agent and sends a task:</p> <pre><code>uv run python -m asap.examples.run_demo\n</code></pre> <p>This runs the agent in a subprocess, sends a task, and prints the response. Use it to validate your setup.</p>"},{"location":"tutorials/first-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Stateful Workflows \u2014 Long-running tasks with snapshots</li> <li>Multi-Agent Orchestration \u2014 Multiple agents working together</li> <li>API Reference \u2014 Full protocol and types</li> </ul>"},{"location":"tutorials/multi-agent/","title":"Multi-Agent Orchestration","text":"<p>Time: ~25 minutes | Level: Advanced</p> <p>This tutorial shows how to coordinate multiple ASAP agents: an orchestrator delegates tasks to sub-agents, collects results, and tracks progress. You will build a workflow where three agents collaborate (orchestrator + two workers).</p> <p>Prerequisites: Building Your First Agent, Stateful Workflows</p>"},{"location":"tutorials/multi-agent/#overview","title":"Overview","text":"<p>In multi-agent systems, one agent often acts as an orchestrator that:</p> <ul> <li>Receives a high-level task</li> <li>Splits it into sub-tasks</li> <li>Delegates each sub-task to a specialized agent</li> <li>Collects results and tracks state</li> <li>Combines outputs into a final response</li> </ul> <p>ASAP supports this pattern via <code>TaskRequest</code>, <code>ASAPClient</code>, and shared <code>conversation_id</code> / <code>trace_id</code> for correlation.</p>"},{"location":"tutorials/multi-agent/#step-1-start-the-worker-agents","title":"Step 1: Start the Worker Agents","text":"<p>You need at least two worker agents (echo agents or custom). In separate terminals:</p> <pre><code># Terminal 1: Worker A on port 8001\nuv run python -m asap.examples.echo_agent --host 127.0.0.1 --port 8001\n\n# Terminal 2: Worker B on port 8002\nuv run python -m asap.examples.echo_agent --host 127.0.0.1 --port 8002\n</code></pre> <p>Keep both running.</p>"},{"location":"tutorials/multi-agent/#step-2-run-the-orchestration-demo","title":"Step 2: Run the Orchestration Demo","text":"<p>ASAP includes a multi-agent orchestration example:</p> <pre><code>uv run python -m asap.examples.orchestration --worker-a-url http://127.0.0.1:8001 --worker-b-url http://127.0.0.1:8002\n</code></pre> <p>What happens:</p> <ol> <li>Orchestrator builds two <code>TaskRequest</code> envelopes (one for each worker).</li> <li>Sends the first task to Worker A; waits for the response.</li> <li>Sends the second task to Worker B; waits for the response.</li> <li>Aggregates both results and reports completion.</li> </ol> <p>Check the logs for <code>asap.orchestration.sent_to_a</code>, <code>asap.orchestration.sent_to_b</code>, and <code>asap.orchestration.complete</code>.</p>"},{"location":"tutorials/multi-agent/#step-3-build-an-orchestrator","title":"Step 3: Build an Orchestrator","text":""},{"location":"tutorials/multi-agent/#orchestration-state","title":"Orchestration State","text":"<p>Track progress across sub-agents with a simple state object:</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any\n\n\n@dataclass\nclass OrchestrationState:\n    conversation_id: str\n    trace_id: str\n    step: str = \"init\"\n    result_a: dict[str, Any] | None = None\n    result_b: dict[str, Any] | None = None\n    error: str | None = None\n    completed: bool = False\n</code></pre>"},{"location":"tutorials/multi-agent/#task-envelope-builder","title":"Task Envelope Builder","text":"<p>Build envelopes for sub-agents with shared <code>conversation_id</code> and <code>trace_id</code>:</p> <pre><code>from asap.models.envelope import Envelope\nfrom asap.models.ids import generate_id\nfrom asap.models.payloads import TaskRequest\n\nORCHESTRATOR_ID = \"urn:asap:agent:orchestrator\"\nWORKER_A_ID = \"urn:asap:agent:worker-a\"\nWORKER_B_ID = \"urn:asap:agent:worker-b\"\n\n\ndef build_task_envelope(\n    recipient_id: str,\n    skill_id: str,\n    input_payload: dict[str, Any],\n    conversation_id: str,\n    trace_id: str,\n) -&gt; Envelope:\n    request = TaskRequest(\n        conversation_id=conversation_id,\n        skill_id=skill_id,\n        input=input_payload,\n    )\n    return Envelope(\n        asap_version=\"0.1\",\n        sender=ORCHESTRATOR_ID,\n        recipient=recipient_id,\n        payload_type=\"task.request\",\n        payload=request.model_dump(),\n        trace_id=trace_id,\n    )\n</code></pre>"},{"location":"tutorials/multi-agent/#run-orchestration","title":"Run Orchestration","text":"<p>Use one <code>ASAPClient</code> per worker for efficient connection reuse:</p> <pre><code>import asyncio\nfrom asap.transport.client import ASAPClient\n\n\nasync def run_orchestration(\n    worker_a_url: str = \"http://127.0.0.1:8001\",\n    worker_b_url: str = \"http://127.0.0.1:8002\",\n) -&gt; OrchestrationState:\n    conversation_id = generate_id()\n    trace_id = generate_id()\n    state = OrchestrationState(conversation_id=conversation_id, trace_id=trace_id)\n\n    async with ASAPClient(worker_a_url) as client_a, ASAPClient(worker_b_url) as client_b:\n        # Step 1: delegate to Worker A\n        envelope_a = build_task_envelope(\n            recipient_id=WORKER_A_ID,\n            skill_id=\"echo\",\n            input_payload={\"step\": \"a\", \"message\": \"task for worker A\"},\n            conversation_id=conversation_id,\n            trace_id=trace_id,\n        )\n        response_a = await client_a.send(envelope_a)\n        state.result_a = response_a.payload\n\n        # Step 2: delegate to Worker B\n        envelope_b = build_task_envelope(\n            recipient_id=WORKER_B_ID,\n            skill_id=\"echo\",\n            input_payload={\"step\": \"b\", \"message\": \"task for worker B\"},\n            conversation_id=conversation_id,\n            trace_id=trace_id,\n        )\n        response_b = await client_b.send(envelope_b)\n        state.result_b = response_b.payload\n\n    state.completed = True\n    return state\n\n\nif __name__ == \"__main__\":\n    state = asyncio.run(run_orchestration())\n    print(\"Result A:\", state.result_a)\n    print(\"Result B:\", state.result_b)\n</code></pre>"},{"location":"tutorials/multi-agent/#step-4-task-coordination-patterns","title":"Step 4: Task Coordination Patterns","text":""},{"location":"tutorials/multi-agent/#sequential-a-then-b","title":"Sequential (A then B)","text":"<p>The orchestrator sends to A, waits for the response, then sends to B. Output of A can be passed to B:</p> <pre><code># A's output feeds B's input\nresponse_a = await client_a.send(envelope_a)\ninput_b = {\"previous_result\": response_a.payload, \"step\": \"b\"}\nenvelope_b = build_task_envelope(..., input_payload=input_b)\nresponse_b = await client_b.send(envelope_b)\n</code></pre>"},{"location":"tutorials/multi-agent/#parallel-a-and-b-concurrently","title":"Parallel (A and B concurrently)","text":"<p>Use <code>asyncio.gather</code> for concurrent delegation:</p> <pre><code>async with ASAPClient(worker_a_url) as client_a, ASAPClient(worker_b_url) as client_b:\n    envelope_a = build_task_envelope(...)\n    envelope_b = build_task_envelope(...)\n    response_a, response_b = await asyncio.gather(\n        client_a.send(envelope_a),\n        client_b.send(envelope_b),\n    )\n</code></pre>"},{"location":"tutorials/multi-agent/#error-handling","title":"Error Handling","text":"<p>Wrap sub-agent calls in try/except to avoid failing the whole orchestration:</p> <pre><code>try:\n    response_a = await client_a.send(envelope_a)\n    state.result_a = response_a.payload\nexcept Exception as e:\n    state.error = f\"worker_a: {e}\"\n    state.step = \"failed_at_a\"\n    return state  # Abort early\n</code></pre>"},{"location":"tutorials/multi-agent/#step-5-shared-context-for-observability","title":"Step 5: Shared Context for Observability","text":"<p>Use <code>conversation_id</code> and <code>trace_id</code> consistently so logs and traces correlate:</p> <pre><code>from asap.observability.logging import bind_context, clear_context\n\nbind_context(trace_id=trace_id, correlation_id=conversation_id)\ntry:\n    # All logs within this block will include trace_id and correlation_id\n    response_a = await client_a.send(envelope_a)\nfinally:\n    clear_context()\n</code></pre> <p>Distributed tracing tools can use these IDs to follow a request across agents.</p>"},{"location":"tutorials/multi-agent/#best-practices","title":"Best Practices","text":"<ol> <li>One client per worker \u2014 Reuse <code>ASAPClient</code> instances for multiple requests; avoid creating a new client per call.</li> <li>Shared IDs \u2014 Use the same <code>conversation_id</code> and <code>trace_id</code> for all envelopes in a workflow.</li> <li>State tracking \u2014 Maintain <code>OrchestrationState</code> or similar to inspect progress and handle failures.</li> <li>Error boundaries \u2014 Catch exceptions from sub-agents and decide: retry, fallback, or fail the orchestration.</li> </ol>"},{"location":"tutorials/multi-agent/#related-patterns","title":"Related Patterns","text":"<ul> <li>Multi-step workflow \u2014 The <code>multi_step_workflow</code> example shows an in-process pipeline (fetch \u2192 transform \u2192 summarize). Each step could be delegated to a different agent.</li> <li>State migration \u2014 For long-running multi-agent tasks, use <code>StateSnapshot</code> and <code>SnapshotStore</code> to persist and resume orchestration state.</li> </ul>"},{"location":"tutorials/multi-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Building Resilient Agents \u2014 Retries, circuit breakers, recovery</li> <li>Production Deployment Checklist \u2014 Security, monitoring, scaling</li> <li>State Management Guide \u2014 Task lifecycle, snapshots</li> </ul>"},{"location":"tutorials/production-checklist/","title":"Production Deployment Checklist","text":"<p>Time: ~15 minutes | Level: DevOps</p> <p>Use this checklist before deploying ASAP agents to production. Covers security, monitoring, and scaling.</p> <p>Prerequisites: Building Your First Agent, Building Resilient Agents</p>"},{"location":"tutorials/production-checklist/#security","title":"Security","text":""},{"location":"tutorials/production-checklist/#tls-and-https","title":"TLS and HTTPS","text":"<ul> <li>[ ] Use HTTPS for all production endpoints (no HTTP)</li> <li>[ ] Configure valid SSL certificates (not self-signed)</li> <li>[ ] Enable TLS 1.2+ (1.3 recommended)</li> <li>[ ] Set HSTS header: <code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></li> <li>[ ] Redirect HTTP to HTTPS at reverse proxy (nginx, traefik, etc.)</li> </ul>"},{"location":"tutorials/production-checklist/#authentication","title":"Authentication","text":"<ul> <li>[ ] Enable authentication in manifest (<code>auth=AuthScheme(schemes=[\"bearer\"])</code> or <code>[\"basic\"]</code>)</li> <li>[ ] Implement and wire <code>token_validator</code> to <code>create_app()</code></li> <li>[ ] Store tokens in environment variables (never hardcode)</li> <li>[ ] Rotate tokens regularly; use short-lived tokens (15\u201360 min)</li> <li>[ ] Ensure clients send <code>Authorization</code> header (Bearer or Basic)</li> </ul>"},{"location":"tutorials/production-checklist/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>[ ] Configure rate limits via <code>ASAP_RATE_LIMIT</code> or <code>rate_limit</code> in <code>create_app()</code></li> <li>[ ] Tune limits for your workload (e.g. <code>10/second;100/minute</code>)</li> <li>[ ] For multi-instance deployments, use Redis-backed rate limiting (slowapi)</li> <li>[ ] Monitor <code>asap_rate_limit_exceeded_total</code> (or equivalent) for abuse</li> </ul>"},{"location":"tutorials/production-checklist/#request-size-limits","title":"Request Size Limits","text":"<ul> <li>[ ] Set <code>max_request_size</code> or <code>ASAP_MAX_REQUEST_SIZE</code> (default 10MB)</li> <li>[ ] Align with reverse proxy (<code>client_max_body_size</code>) and ASGI server limits</li> <li>[ ] Monitor 413 (Payload Too Large) responses</li> </ul>"},{"location":"tutorials/production-checklist/#handler-security","title":"Handler Security","text":"<ul> <li>[ ] Validate all payloads with Pydantic models (e.g. <code>TaskRequest</code>)</li> <li>[ ] Use <code>FilePart</code> (or equivalent) for file URIs; block path traversal (<code>../</code>)</li> <li>[ ] Use <code>sanitize_for_logging()</code> before logging envelope/payload</li> <li>[ ] Never log secrets or PII</li> <li>[ ] Use <code>validate_handler()</code> or equivalent before registering handlers</li> </ul>"},{"location":"tutorials/production-checklist/#replay-protection","title":"Replay Protection","text":"<ul> <li>[ ] Keep timestamp validation enabled (default)</li> <li>[ ] Consider <code>require_nonce=True</code> for high-security flows</li> <li>[ ] Use a shared nonce store (Redis, DB) for multi-instance deployments</li> </ul>"},{"location":"tutorials/production-checklist/#monitoring","title":"Monitoring","text":""},{"location":"tutorials/production-checklist/#metrics","title":"Metrics","text":"<ul> <li>[ ] Expose metrics at <code>/asap/metrics</code> (Prometheus format)</li> <li>[ ] Configure Prometheus to scrape <code>/asap/metrics</code></li> <li>[ ] Track: <code>asap_requests_total</code>, <code>asap_requests_error_total</code>, <code>asap_request_duration_seconds</code></li> <li>[ ] Add custom metrics for business logic (e.g. tasks per skill)</li> </ul>"},{"location":"tutorials/production-checklist/#logging","title":"Logging","text":"<ul> <li>[ ] Use structured logging (<code>configure_logging</code>, <code>get_logger</code>)</li> <li>[ ] Set <code>ASAP_LOG_FORMAT=json</code> for production</li> <li>[ ] Bind <code>trace_id</code> and <code>correlation_id</code> for distributed tracing</li> <li>[ ] Ensure logs are aggregated (e.g. ELK, Loki, CloudWatch)</li> </ul>"},{"location":"tutorials/production-checklist/#health-and-readiness","title":"Health and Readiness","text":"<ul> <li>[ ] Implement <code>/health</code> (liveness) and <code>/ready</code> (readiness) endpoints</li> <li>[ ] Wire readiness to dependencies (DB, Redis, downstream agents)</li> <li>[ ] Configure Kubernetes liveness/readiness probes</li> <li>[ ] Test graceful shutdown (SIGTERM) and drain in-flight requests</li> </ul>"},{"location":"tutorials/production-checklist/#alerting","title":"Alerting","text":"<ul> <li>[ ] Alert on high error rate (e.g. &gt;10% for 5 min)</li> <li>[ ] Alert on high latency (e.g. P99 &gt; 1s)</li> <li>[ ] Alert on agent down (scrape failures)</li> <li>[ ] Alert on rate limit hits above threshold</li> </ul>"},{"location":"tutorials/production-checklist/#scaling","title":"Scaling","text":""},{"location":"tutorials/production-checklist/#client-configuration","title":"Client Configuration","text":"<ul> <li>[ ] Use connection pooling (ASAPClient default; tune <code>pool_connections</code>, <code>pool_maxsize</code> if needed)</li> <li>[ ] Enable compression for payloads &gt; 1KB (default in ASAPClient)</li> <li>[ ] Configure <code>RetryConfig</code> (retries, circuit breaker) for resilience</li> <li>[ ] Set appropriate timeouts (<code>timeout</code>, <code>MANIFEST_REQUEST_TIMEOUT</code>)</li> </ul>"},{"location":"tutorials/production-checklist/#server-configuration","title":"Server Configuration","text":"<ul> <li>[ ] Use multiple uvicorn workers or Gunicorn with Uvicorn workers</li> <li>[ ] Configure worker count based on CPU (e.g. 2\u20134 per core)</li> <li>[ ] Set <code>DEFAULT_POOL_MAXSIZE</code> and <code>DEFAULT_POOL_CONNECTIONS</code> for high concurrency</li> </ul>"},{"location":"tutorials/production-checklist/#caching","title":"Caching","text":"<ul> <li>[ ] Enable manifest caching (<code>ManifestCache</code>) for downstream agent manifests</li> <li>[ ] Tune cache TTL (e.g. 5 min) for your discovery pattern</li> <li>[ ] Use shared cache (Redis) for multi-instance deployments if needed</li> </ul>"},{"location":"tutorials/production-checklist/#state-and-snapshots","title":"State and Snapshots","text":"<ul> <li>[ ] Use a persistent <code>SnapshotStore</code> (Redis, PostgreSQL) for long-running tasks</li> <li>[ ] Avoid <code>InMemorySnapshotStore</code> in production (data lost on restart)</li> <li>[ ] Tune checkpoint frequency; keep snapshots lean</li> </ul>"},{"location":"tutorials/production-checklist/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>[ ] Run agents as stateless pods/containers where possible</li> <li>[ ] Use sticky sessions or shared state (Redis) if required</li> <li>[ ] Configure autoscaling (HPA, cluster autoscaler) based on CPU/memory/request rate</li> </ul>"},{"location":"tutorials/production-checklist/#resilience","title":"Resilience","text":"<ul> <li>[ ] Enable retries with backoff on the client</li> <li>[ ] Enable circuit breaker for failing downstream agents</li> <li>[ ] Implement fallbacks for critical paths (cached value, backup agent)</li> <li>[ ] Use state snapshots for resumable long-running tasks</li> </ul>"},{"location":"tutorials/production-checklist/#quick-reference","title":"Quick Reference","text":"Area Key docs Security Security Guide Metrics Metrics Guide Transport Transport Guide Resilience Building Resilient Agents"},{"location":"tutorials/resilience/","title":"Building Resilient Agents","text":"<p>Time: ~25 minutes | Level: Advanced</p> <p>This tutorial shows how to build agents that handle failures gracefully: retries with backoff, circuit breakers, fallbacks, and state recovery. The patterns align with ASAP's chaos testing (Sprint 8): message loss, server crashes, timeouts, and cascading failures.</p> <p>Prerequisites: Building Your First Agent, Stateful Workflows, Multi-Agent Orchestration</p>"},{"location":"tutorials/resilience/#why-resilience-matters","title":"Why Resilience Matters","text":"<p>Distributed agent systems face transient and persistent failures:</p> <ul> <li>Transient: Network timeouts, temporary overload, message loss \u2014 often fixed by retrying.</li> <li>Persistent: Down agent, repeated 5xx \u2014 retrying blindly can make things worse. Use circuit breakers and fallbacks.</li> </ul> <p>Chaos testing (Sprint 8) validated ASAP's handling of: server crashes, message loss, network partition, and clock skew. This tutorial applies those lessons to your agents.</p>"},{"location":"tutorials/resilience/#pattern-1-retry-with-backoff","title":"Pattern 1: Retry with Backoff","text":""},{"location":"tutorials/resilience/#using-asapclients-built-in-retry","title":"Using ASAPClient's Built-in Retry","text":"<p><code>ASAPClient</code> retries transient failures by default. Configure via <code>RetryConfig</code>:</p> <pre><code>from asap.transport.client import ASAPClient, RetryConfig\nfrom asap.models.envelope import Envelope\n\nconfig = RetryConfig(\n    max_retries=5,\n    base_delay=1.0,\n    max_delay=60.0,\n    jitter=True,  # Add randomness to avoid thundering herd\n)\n\nasync with ASAPClient(\"http://agent.example.com\", retry_config=config) as client:\n    response = await client.send(envelope)\n</code></pre> <ul> <li>Exponential backoff: delay = min(base_delay \u00d7 2^attempt, max_delay)</li> <li>Jitter: Reduces synchronized retries when many clients fail at once</li> </ul>"},{"location":"tutorials/resilience/#standalone-retry-for-custom-operations","title":"Standalone Retry for Custom Operations","text":"<p>For non-client operations (e.g. DB, external APIs), use the <code>error_recovery</code> pattern:</p> <pre><code>from asap.examples.error_recovery import retry_with_backoff\n\ndef flaky_operation() -&gt; str:\n    # May raise ConnectionError, TimeoutError, etc.\n    return call_external_service()\n\nresult = retry_with_backoff(\n    flaky_operation,\n    max_retries=3,\n    base_delay=0.5,\n    max_delay=30.0,\n    jitter=True,\n)\n</code></pre> <p>Run the built-in demo: <code>uv run python -m asap.examples.error_recovery --skip-circuit --skip-fallback</code></p>"},{"location":"tutorials/resilience/#pattern-2-circuit-breaker","title":"Pattern 2: Circuit Breaker","text":"<p>The circuit breaker stops requests when a target is failing repeatedly, then tests recovery after a timeout.</p>"},{"location":"tutorials/resilience/#states","title":"States","text":"State Meaning CLOSED Normal; requests allowed OPEN Too many failures; requests rejected HALF_OPEN Testing; one request allowed to probe recovery"},{"location":"tutorials/resilience/#using-asapclient-with-circuit-breaker","title":"Using ASAPClient with Circuit Breaker","text":"<pre><code>from asap.transport.client import ASAPClient, RetryConfig\nfrom asap.errors import CircuitOpenError\n\nconfig = RetryConfig(\n    max_retries=3,\n    circuit_breaker_enabled=True,\n    circuit_breaker_threshold=5,   # Open after 5 consecutive failures\n    circuit_breaker_timeout=60.0,  # Try again after 60 seconds\n)\n\nasync with ASAPClient(\"http://agent.example.com\", retry_config=config) as client:\n    try:\n        response = await client.send(envelope)\n    except CircuitOpenError:\n        # Circuit is open; use fallback or return cached/default result\n        response = get_fallback_response()\n</code></pre>"},{"location":"tutorials/resilience/#standalone-circuit-breaker","title":"Standalone Circuit Breaker","text":"<p>For custom logic (e.g. wrapping non-ASAP calls):</p> <pre><code>from asap.errors import CircuitOpenError\nfrom asap.transport.circuit_breaker import CircuitBreaker, CircuitState\n\nbreaker = CircuitBreaker(threshold=5, timeout=60.0)\n\ndef call_with_breaker():\n    if not breaker.can_attempt():\n        raise CircuitOpenError(\"Circuit is open\")\n    try:\n        result = risky_operation()\n        breaker.record_success()\n        return result\n    except Exception as e:\n        breaker.record_failure()\n        raise\n</code></pre> <p>Run the circuit breaker demo: <code>uv run python -m asap.examples.error_recovery --skip-retry --skip-fallback</code></p>"},{"location":"tutorials/resilience/#pattern-3-fallback","title":"Pattern 3: Fallback","text":"<p>When the primary operation fails, use a fallback: cached value, secondary agent, or default.</p>"},{"location":"tutorials/resilience/#using-the-fallback-helper","title":"Using the Fallback Helper","text":"<p>For sync operations, use <code>with_fallback</code>:</p> <pre><code>from asap.examples.error_recovery import with_fallback\n\ndef primary() -&gt; dict:\n    # Call primary agent (sync wrapper or in-process logic)\n    return call_primary_service()\n\ndef fallback() -&gt; dict:\n    # Return cached result or default; should not raise\n    return {\"status\": \"fallback\", \"message\": \"Using cached/default result\"}\n\nresult = with_fallback(primary, fallback)\n</code></pre>"},{"location":"tutorials/resilience/#fallback-in-multi-agent-orchestration","title":"Fallback in Multi-Agent Orchestration","text":"<pre><code>async def call_worker_with_fallback(primary_url: str, backup_url: str) -&gt; Envelope:\n    try:\n        async with ASAPClient(primary_url) as client:\n            return await client.send(envelope)\n    except (ASAPConnectionError, ASAPTimeoutError) as e:\n        logger.warning(\"Primary worker failed, trying backup\", error=str(e))\n        async with ASAPClient(backup_url) as client:\n            return await client.send(envelope)\n</code></pre> <p>Run the fallback demo: <code>uv run python -m asap.examples.error_recovery --skip-retry --skip-circuit</code></p>"},{"location":"tutorials/resilience/#pattern-4-state-recovery","title":"Pattern 4: State Recovery","text":"<p>Combine resilience with Stateful Workflows: persist state at checkpoints and resume after failures.</p> <pre><code>from asap.state.snapshot import InMemorySnapshotStore\nfrom asap.examples.long_running import run_steps, resume_from_store\n\nstore = InMemorySnapshotStore()\ntask_id = \"task_01HX5K4N...\"\n\n# Run until failure (e.g. crash, timeout)\ntry:\n    run_steps(store, task_id, num_steps=10, crash_after_step=3)\nexcept Exception:\n    pass  # State saved at step 3\n\n# Resume from last checkpoint\nfinal = resume_from_store(store, task_id, num_steps=10)\n</code></pre> <p>Use a persistent <code>SnapshotStore</code> (Redis, PostgreSQL) in production so state survives process restarts.</p>"},{"location":"tutorials/resilience/#combining-patterns","title":"Combining Patterns","text":""},{"location":"tutorials/resilience/#retry-circuit-breaker-asapclient","title":"Retry + Circuit Breaker (ASAPClient)","text":"<pre><code>config = RetryConfig(\n    max_retries=3,\n    circuit_breaker_enabled=True,\n    circuit_breaker_threshold=5,\n)\nasync with ASAPClient(url, retry_config=config) as client:\n    response = await client.send(envelope)\n</code></pre>"},{"location":"tutorials/resilience/#retry-fallback","title":"Retry + Fallback","text":"<pre><code>def primary_with_retry():\n    return retry_with_backoff(lambda: call_primary_agent())\n\nresult = with_fallback(primary_with_retry, fallback)\n</code></pre>"},{"location":"tutorials/resilience/#circuit-breaker-fallback","title":"Circuit Breaker + Fallback","text":"<pre><code>try:\n    response = await client.send(envelope)\nexcept CircuitOpenError:\n    response = fallback_response()\n</code></pre>"},{"location":"tutorials/resilience/#chaos-testing-scenarios-sprint-8","title":"Chaos Testing Scenarios (Sprint 8)","text":"<p>ASAP's chaos tests validate these scenarios:</p> Scenario Client behavior Message loss Retries until max_retries; raises <code>ASAPTimeoutError</code> Server crash Retries; raises <code>ASAPConnectionError</code> 503 Service Unavailable Retries (transient) Circuit open Immediate <code>CircuitOpenError</code>; no retries Network partition Timeout; retries; circuit opens after threshold"},{"location":"tutorials/resilience/#best-practices","title":"Best Practices","text":"<ol> <li>Retry only idempotent operations \u2014 Task requests are typically idempotent; others may not be.</li> <li>Use jitter \u2014 Avoid synchronized retries across many clients.</li> <li>Circuit breaker per target \u2014 One breaker per agent URL, not global.</li> <li>Fallback should not fail \u2014 Keep fallback logic simple and reliable.</li> <li>Log failures \u2014 Use structured logging (<code>get_logger</code>) for debugging.</li> </ol>"},{"location":"tutorials/resilience/#next-steps","title":"Next Steps","text":"<ul> <li>Production Deployment Checklist \u2014 Security, monitoring, scaling</li> <li>Error Handling \u2014 ASAP error taxonomy</li> <li>State Management \u2014 Snapshots and custom stores</li> </ul>"},{"location":"tutorials/stateful-workflows/","title":"Stateful Workflows","text":"<p>Time: ~20 minutes | Level: Intermediate</p> <p>This tutorial shows how to build long-running tasks that save state and resume after crashes. You will use <code>StateSnapshot</code> and <code>SnapshotStore</code> to persist progress and pick up where you left off.</p> <p>Prerequisites: Building Your First Agent</p>"},{"location":"tutorials/stateful-workflows/#why-stateful-workflows","title":"Why Stateful Workflows?","text":"<p>Long-running tasks (e.g. batch processing, multi-step pipelines) can fail or be interrupted:</p> <ul> <li>Process crash or restart</li> <li>Pod eviction in Kubernetes</li> <li>Network timeout or connection drop</li> </ul> <p>Without state persistence, you restart from scratch. With snapshots, you save progress at checkpoints and resume from the last known good state.</p>"},{"location":"tutorials/stateful-workflows/#concepts","title":"Concepts","text":""},{"location":"tutorials/stateful-workflows/#statesnapshot","title":"StateSnapshot","text":"<p>A <code>StateSnapshot</code> captures task state at a point in time:</p> <pre><code>from datetime import datetime, timezone\nfrom asap.models.entities import StateSnapshot\nfrom asap.models.ids import generate_id\n\nsnapshot = StateSnapshot(\n    id=generate_id(),\n    task_id=\"task_01HX5K4N...\",\n    version=1,\n    data={\"step\": 2, \"results\": [\"item_1\", \"item_2\"], \"completed\": False},\n    checkpoint=True,  # Mark significant milestone\n    created_at=datetime.now(timezone.utc),\n)\n</code></pre> <ul> <li>version: Monotonically increasing; used for ordering and rollback.</li> <li>data: JSON-serializable dict with your task state.</li> <li>checkpoint: Flag for important states (e.g. phase completion).</li> </ul>"},{"location":"tutorials/stateful-workflows/#snapshotstore","title":"SnapshotStore","text":"<p>The store persists snapshots. ASAP provides <code>InMemorySnapshotStore</code> for development:</p> <pre><code>from asap.state.snapshot import InMemorySnapshotStore\n\nstore = InMemorySnapshotStore()\nstore.save(snapshot)\nlatest = store.get(\"task_01HX5K4N...\")\nversions = store.list_versions(\"task_01HX5K4N...\")\n</code></pre> <p>For production, implement the <code>SnapshotStore</code> protocol with Redis, PostgreSQL, or your backend. See State Management Guide.</p>"},{"location":"tutorials/stateful-workflows/#step-1-run-the-long-running-demo","title":"Step 1: Run the Long-Running Demo","text":"<p>ASAP includes a demo that simulates a crash and resume:</p> <pre><code>uv run python -m asap.examples.long_running --num-steps 5 --crash-after 2\n</code></pre> <p>What happens:</p> <ol> <li>Task runs 5 steps; a snapshot is saved after each step.</li> <li>After step 2, the demo \"crashes\" (exits).</li> <li>The process restarts and resumes from the last snapshot (step 2).</li> <li>Steps 3\u20135 run and the task completes.</li> </ol> <p>Check the logs to see checkpoint saves and the resume.</p>"},{"location":"tutorials/stateful-workflows/#step-2-build-a-simple-stateful-task","title":"Step 2: Build a Simple Stateful Task","text":"<p>Create <code>my_long_task.py</code>:</p> <pre><code>from datetime import datetime, timezone\n\nfrom asap.models.entities import StateSnapshot\nfrom asap.models.ids import generate_id\nfrom asap.state.snapshot import InMemorySnapshotStore\n\n\ndef run_task(store: InMemorySnapshotStore, task_id: str, num_steps: int) -&gt; StateSnapshot | None:\n    \"\"\"Run a multi-step task, saving a snapshot after each step.\"\"\"\n    partial = {\"items\": [], \"step\": 0}\n\n    for step in range(1, num_steps + 1):\n        # Simulate work\n        partial[\"items\"].append(f\"result_{step}\")\n        partial[\"step\"] = step\n        completed = step == num_steps\n\n        snapshot = StateSnapshot(\n            id=generate_id(),\n            task_id=task_id,\n            version=step,\n            data={**partial, \"completed\": completed},\n            checkpoint=True,\n            created_at=datetime.now(timezone.utc),\n        )\n        store.save(snapshot)\n\n    return store.get(task_id)\n\n\nif __name__ == \"__main__\":\n    store = InMemorySnapshotStore()\n    task_id = generate_id()\n    run_task(store, task_id, 5)\n    latest = store.get(task_id)\n    print(\"Final state:\", latest.data if latest else None)\n</code></pre> <p>Run it: <code>uv run python my_long_task.py</code></p>"},{"location":"tutorials/stateful-workflows/#step-3-simulate-crash-and-resume","title":"Step 3: Simulate Crash and Resume","text":"<p>Extend the script to stop after a step (simulate crash) and resume:</p> <pre><code>def run_task(\n    store: InMemorySnapshotStore,\n    task_id: str,\n    num_steps: int,\n    crash_after: int | None = None,\n) -&gt; StateSnapshot | None:\n    \"\"\"Run steps 1..num_steps; stop after crash_after (simulate crash).\"\"\"\n    partial = {\"items\": [], \"step\": 0}\n\n    for step in range(1, num_steps + 1):\n        partial[\"items\"].append(f\"result_{step}\")\n        partial[\"step\"] = step\n        completed = step == num_steps\n\n        snapshot = StateSnapshot(\n            id=generate_id(),\n            task_id=task_id,\n            version=step,\n            data={**partial, \"completed\": completed},\n            checkpoint=True,\n            created_at=datetime.now(timezone.utc),\n        )\n        store.save(snapshot)\n\n        if crash_after is not None and step &gt;= crash_after:\n            print(f\"Simulated crash after step {step}\")\n            break\n\n    return store.get(task_id)\n\n\ndef resume_task(\n    store: InMemorySnapshotStore,\n    task_id: str,\n    num_steps: int,\n) -&gt; StateSnapshot | None:\n    \"\"\"Resume from the latest snapshot and complete remaining steps.\"\"\"\n    latest = store.get(task_id)\n    if latest is None:\n        return None\n\n    last_step = latest.data.get(\"step\", 0)\n    if last_step &gt;= num_steps:\n        return latest\n\n    partial = {\n        \"items\": list(latest.data.get(\"items\", [])),\n        \"step\": last_step,\n    }\n\n    for step in range(last_step + 1, num_steps + 1):\n        partial[\"items\"].append(f\"result_{step}\")\n        partial[\"step\"] = step\n        completed = step == num_steps\n\n        snapshot = StateSnapshot(\n            id=generate_id(),\n            task_id=task_id,\n            version=step,\n            data={**partial, \"completed\": completed},\n            checkpoint=True,\n            created_at=datetime.now(timezone.utc),\n        )\n        store.save(snapshot)\n\n    return store.get(task_id)\n\n\nif __name__ == \"__main__\":\n    store = InMemorySnapshotStore()\n    task_id = generate_id()\n\n    # Phase 1: run until crash\n    run_task(store, task_id, 5, crash_after=2)\n\n    # Phase 2: resume and complete\n    final = resume_task(store, task_id, 5)\n    print(\"Final state:\", final.data if final else None)\n</code></pre> <p>This pattern: save after each step \u2192 simulate crash \u2192 resume from latest snapshot is the core of stateful workflows.</p>"},{"location":"tutorials/stateful-workflows/#step-4-use-the-built-in-example","title":"Step 4: Use the Built-in Example","text":"<p>The <code>long_running</code> example uses the same pattern with structured helpers:</p> <pre><code>from asap.examples.long_running import run_steps, resume_from_store\nfrom asap.state.snapshot import InMemorySnapshotStore\n\nstore = InMemorySnapshotStore()\ntask_id = \"task_01HX5K4N...\"\n\n# Run until step 2, then \"crash\"\nrun_steps(store, task_id, num_steps=5, crash_after_step=2)\n\n# Resume and complete\nfinal = resume_from_store(store, task_id, num_steps=5)\n</code></pre>"},{"location":"tutorials/stateful-workflows/#best-practices","title":"Best Practices","text":"<ol> <li>Checkpoint at logical boundaries \u2014 After each phase or batch, not every tiny operation.</li> <li>Keep snapshots lean \u2014 Store only essential state; avoid large or derived data.</li> <li>Use version numbers \u2014 Increment versions so you can reason about ordering and rollback.</li> <li>Use a persistent store in production \u2014 <code>InMemorySnapshotStore</code> loses data on restart; use Redis, PostgreSQL, etc.</li> </ol>"},{"location":"tutorials/stateful-workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Agent Orchestration \u2014 Coordinate multiple agents</li> <li>Building Resilient Agents \u2014 Retries, circuit breakers, recovery</li> <li>State Management Guide \u2014 Task lifecycle, custom stores</li> </ul>"}]}