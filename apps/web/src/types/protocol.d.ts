/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Pydantic models.
 */

/**
 * Unique envelope identifier (ULID, auto-generated)
 */
export type Id = string | null;
/**
 * ASAP protocol version
 */
export type AsapVersion = string;
/**
 * Message timestamp (UTC, auto-generated)
 */
export type Timestamp = string | null;
/**
 * Sender agent URN
 */
export type Sender = string;
/**
 * Recipient agent URN
 */
export type Recipient = string;
/**
 * Payload type discriminator
 */
export type PayloadType = string;
/**
 * Message payload (typed when payload_type known, else dict)
 */
export type Payload =
  | TaskRequest
  | TaskResponse
  | TaskUpdate
  | TaskCancel
  | MessageSend
  | StateQuery
  | StateRestore
  | ArtifactNotify
  | McpToolCall
  | McpToolResult
  | McpResourceFetch
  | McpResourceData
  | MessageAck
  | {
      [k: string]: unknown;
    };
/**
 * Parent conversation ID
 */
export type ConversationId = string;
/**
 * Parent task ID for subtasks
 */
export type ParentTaskId = string | null;
/**
 * Skill identifier to execute
 */
export type SkillId = string;
/**
 * Maximum execution time in seconds
 */
export type TimeoutSeconds = number | null;
/**
 * Task priority (e.g., 'low', 'normal', 'high')
 */
export type Priority = string | null;
/**
 * Key for idempotent execution
 */
export type IdempotencyKey = string | null;
/**
 * Whether to stream progress updates
 */
export type Streaming = boolean | null;
/**
 * Whether to persist state snapshots
 */
export type PersistState = boolean | null;
/**
 * LLM model identifier
 */
export type Model = string | null;
/**
 * LLM temperature (0-2)
 */
export type Temperature = number | null;
/**
 * Task identifier
 */
export type TaskId = string;
/**
 * Final task status
 */
export type TaskStatus = "submitted" | "working" | "completed" | "failed" | "cancelled" | "input_required";
/**
 * Result data (summary, artifacts, etc.)
 */
export type Result = {
  [k: string]: unknown;
} | null;
/**
 * Final state snapshot
 */
export type FinalState = {
  [k: string]: unknown;
} | null;
/**
 * Execution duration in milliseconds
 */
export type DurationMs = number | null;
/**
 * Input token count
 */
export type TokensIn = number | null;
/**
 * Output token count
 */
export type TokensOut = number | null;
/**
 * Total tokens (fallback for tokens_out)
 */
export type TokensUsed = number | null;
/**
 * Number of API calls
 */
export type ApiCalls = number | null;
/**
 * Task identifier
 */
export type TaskId1 = string;
/**
 * Update type (progress, input_required)
 */
export type UpdateType = "progress" | "input_required" | "status_change";
/**
 * Current task status
 */
export type TaskStatus1 = "submitted" | "working" | "completed" | "failed" | "cancelled" | "input_required";
/**
 * Progress info (percent, message, ETA)
 */
export type Progress = {
  [k: string]: unknown;
} | null;
/**
 * Request for additional input
 */
export type InputRequest = {
  [k: string]: unknown;
} | null;
/**
 * Task identifier to cancel
 */
export type TaskId2 = string;
/**
 * Optional cancellation reason
 */
export type Reason = string | null;
/**
 * Parent task ID
 */
export type TaskId3 = string;
/**
 * Unique message identifier
 */
export type MessageId = string;
/**
 * Sender agent URN
 */
export type Sender1 = string;
/**
 * Message role (user, assistant, system)
 */
export type MessageRole = "user" | "assistant" | "system";
/**
 * Part IDs making up this message
 */
export type Parts = string[];
/**
 * Task identifier
 */
export type TaskId4 = string;
/**
 * Optional specific version to retrieve
 */
export type Version = number | null;
/**
 * Task identifier
 */
export type TaskId5 = string;
/**
 * Snapshot ID to restore from
 */
export type SnapshotId = string;
/**
 * Artifact identifier
 */
export type ArtifactId = string;
/**
 * Parent task ID
 */
export type TaskId6 = string;
/**
 * Optional human-readable artifact name
 */
export type Name = string | null;
/**
 * Unique request identifier
 */
export type RequestId = string;
/**
 * MCP tool name to invoke
 */
export type ToolName = string;
/**
 * Optional MCP context (server, session, etc.)
 */
export type McpContext = {
  [k: string]: unknown;
} | null;
/**
 * Original request identifier
 */
export type RequestId1 = string;
/**
 * Whether tool call succeeded
 */
export type Success = boolean;
/**
 * Result data (if successful)
 */
export type Result1 = {
  [k: string]: unknown;
} | null;
/**
 * Error message (if failed)
 */
export type Error = string | null;
/**
 * MCP resource URI to fetch
 */
export type ResourceUri = string;
/**
 * MCP resource URI
 */
export type ResourceUri1 = string;
/**
 * Envelope ID being acknowledged
 */
export type OriginalEnvelopeId = string;
export type Status = "received" | "processed" | "rejected";
/**
 * Reason when rejected
 */
export type Error1 = string | null;
/**
 * Optional correlation ID for request/response pairing
 */
export type CorrelationId = string | null;
/**
 * Optional trace ID for distributed tracing
 */
export type TraceId = string | null;
/**
 * When True, receiver must send a MessageAck for this envelope (WebSocket). Over WebSocket, auto-set for state-changing payloads: TaskRequest, TaskCancel, StateRestore, MessageSend. HTTP transport uses response as implicit ack.
 */
export type RequiresAck = boolean;
/**
 * Optional custom extensions. Can include a 'nonce' field (string) for replay attack prevention. If provided, the nonce must be unique within the TTL window (typically 10 minutes). Duplicate nonces will be rejected by the validation layer.
 */
export type Extensions = {
  [k: string]: unknown;
} | null;

/**
 * ASAP protocol message envelope.
 *
 * Envelope wraps all protocol messages with metadata for routing,
 * correlation, tracing, and versioning. Auto-generates id and timestamp
 * if not provided.
 *
 * Attributes:
 *     id: Unique envelope identifier (auto-generated if not provided)
 *     asap_version: ASAP protocol version (e.g., "0.1")
 *     timestamp: Message timestamp in UTC (auto-generated if not provided)
 *     sender: Sender agent URN
 *     recipient: Recipient agent URN
 *     payload_type: Type of payload (TaskRequest, TaskResponse, etc.)
 *     payload: Actual message payload
 *     correlation_id: Optional ID for correlating request/response pairs
 *     trace_id: Optional ID for distributed tracing
 *     extensions: Optional custom extensions
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> envelope = Envelope(
 *     ...     asap_version="0.1",
 *     ...     sender="urn:asap:agent:coordinator",
 *     ...     recipient="urn:asap:agent:research-v1",
 *     ...     payload_type="TaskRequest",
 *     ...     payload={"conversation_id": "conv_123", "skill_id": "research", "input": {}}
 *     ... )
 *     >>> # id and timestamp are auto-generated
 *     >>> assert envelope.id is not None
 *     >>> assert envelope.timestamp is not None
 */
export interface Envelope {
  id?: Id;
  asap_version: AsapVersion;
  timestamp?: Timestamp;
  sender: Sender;
  recipient: Recipient;
  payload_type: PayloadType;
  payload: Payload;
  correlation_id?: CorrelationId;
  trace_id?: TraceId;
  requires_ack?: RequiresAck;
  extensions?: Extensions;
}
/**
 * Request to execute a task on an agent.
 *
 * TaskRequest initiates task execution, specifying the skill to invoke,
 * input data, and optional configuration parameters.
 *
 * Attributes:
 *     conversation_id: ID of the conversation this task belongs to
 *     parent_task_id: Optional ID of parent task (for subtasks)
 *     skill_id: Identifier of the skill to execute
 *     input: Input data for the skill (JSON-serializable)
 *     config: Optional configuration (timeout, priority, streaming, etc.)
 */
export interface TaskRequest {
  conversation_id: ConversationId;
  parent_task_id?: ParentTaskId;
  skill_id: SkillId;
  input: Input;
  /**
   * Optional configuration (timeout, priority, streaming, etc.)
   */
  config?: TaskRequestConfig | null;
}
/**
 * Input data for the skill (skill-specific)
 */
export interface Input {
  [k: string]: unknown;
}
/**
 * TaskRequest.config (extra allowed).
 */
export interface TaskRequestConfig {
  timeout_seconds?: TimeoutSeconds;
  priority?: Priority;
  idempotency_key?: IdempotencyKey;
  streaming?: Streaming;
  persist_state?: PersistState;
  model?: Model;
  temperature?: Temperature;
}
/**
 * Response to a task execution request.
 *
 * TaskResponse provides the final result of task execution, including
 * status, result data, final state snapshot, and execution metrics.
 *
 * Attributes:
 *     task_id: ID of the completed task
 *     status: Final task status (completed, failed, cancelled, etc.)
 *     result: Optional result data (summary, artifacts, etc.)
 *     final_state: Optional final state snapshot
 *     metrics: Optional execution metrics (duration, tokens used, etc.)
 */
export interface TaskResponse {
  task_id: TaskId;
  status: TaskStatus;
  result?: Result;
  final_state?: FinalState;
  /**
   * Execution metrics (duration, tokens, etc.)
   */
  metrics?: TaskMetrics | null;
}
/**
 * TaskResponse.metrics (extra allowed).
 */
export interface TaskMetrics {
  duration_ms?: DurationMs;
  tokens_in?: TokensIn;
  tokens_out?: TokensOut;
  tokens_used?: TokensUsed;
  api_calls?: ApiCalls;
}
/**
 * Update on task execution progress or status.
 *
 * TaskUpdate provides real-time updates during task execution, including
 * progress information or requests for additional input.
 *
 * Attributes:
 *     task_id: ID of the task being updated
 *     update_type: Type of update (progress, input_required, etc.)
 *     status: Current task status
 *     progress: Optional progress information (percent, message, ETA)
 *     input_request: Optional request for additional input from user
 */
export interface TaskUpdate {
  task_id: TaskId1;
  update_type: UpdateType;
  status: TaskStatus1;
  progress?: Progress;
  input_request?: InputRequest;
}
/**
 * Request to cancel a running task.
 *
 * TaskCancel requests cancellation of a task that is currently executing.
 * The agent should attempt graceful cancellation and cleanup.
 *
 * Attributes:
 *     task_id: ID of the task to cancel
 *     reason: Optional reason for cancellation
 */
export interface TaskCancel {
  task_id: TaskId2;
  reason?: Reason;
}
/**
 * Send a message within a task conversation.
 *
 * MessageSend exchanges conversation turns between agents during
 * task execution, containing message content as parts.
 *
 * Attributes:
 *     task_id: ID of the task this message belongs to
 *     message_id: Unique identifier for this message
 *     sender: Agent URN of the message sender
 *     role: Message role (user, assistant, system)
 *     parts: List of part IDs that make up this message
 */
export interface MessageSend {
  task_id: TaskId3;
  message_id: MessageId;
  sender: Sender1;
  role: MessageRole;
  parts: Parts;
}
/**
 * Request a state snapshot for a task.
 *
 * StateQuery requests the current or a specific version of a task's
 * state snapshot for inspection or restoration.
 *
 * Attributes:
 *     task_id: ID of the task to query state for
 *     version: Optional specific version number to retrieve
 */
export interface StateQuery {
  task_id: TaskId4;
  version?: Version;
}
/**
 * Restore a task to a previous state snapshot.
 *
 * StateRestore requests restoration of a task to a previously saved
 * state snapshot, enabling rollback and recovery scenarios.
 *
 * Attributes:
 *     task_id: ID of the task to restore
 *     snapshot_id: ID of the snapshot to restore from
 */
export interface StateRestore {
  task_id: TaskId5;
  snapshot_id: SnapshotId;
}
/**
 * Notify about artifact creation or availability.
 *
 * ArtifactNotify informs agents when a new artifact has been created
 * or is available for retrieval.
 *
 * Attributes:
 *     artifact_id: ID of the artifact
 *     task_id: ID of the task that produced the artifact
 *     name: Optional human-readable artifact name
 */
export interface ArtifactNotify {
  artifact_id: ArtifactId;
  task_id: TaskId6;
  name?: Name;
}
/**
 * Call an MCP tool.
 *
 * McpToolCall invokes a tool provided by an MCP server, enabling
 * agents to leverage external capabilities and integrations.
 *
 * Attributes:
 *     request_id: Unique identifier for this tool call request
 *     tool_name: Name of the MCP tool to invoke
 *     arguments: Arguments to pass to the tool (JSON-serializable)
 *     mcp_context: Optional MCP-specific context (server, session, etc.)
 */
export interface McpToolCall {
  request_id: RequestId;
  tool_name: ToolName;
  arguments: Arguments;
  mcp_context?: McpContext;
}
/**
 * Tool arguments (JSON-serializable)
 */
export interface Arguments {
  [k: string]: unknown;
}
/**
 * Result of an MCP tool call.
 *
 * McpToolResult provides the outcome of an MCP tool invocation,
 * including success status, result data, or error information.
 *
 * Attributes:
 *     request_id: ID of the original tool call request
 *     success: Whether the tool call succeeded
 *     result: Optional result data (if successful)
 *     error: Optional error message (if failed)
 */
export interface McpToolResult {
  request_id: RequestId1;
  success: Success;
  result?: Result1;
  error?: Error;
}
/**
 * Request to fetch an MCP resource.
 *
 * McpResourceFetch requests retrieval of a resource from an MCP server,
 * such as documentation, data, or other content.
 *
 * Attributes:
 *     resource_uri: URI of the MCP resource to fetch
 */
export interface McpResourceFetch {
  resource_uri: ResourceUri;
}
/**
 * Data from an MCP resource.
 *
 * McpResourceData provides the content of a fetched MCP resource.
 *
 * Attributes:
 *     resource_uri: URI of the resource
 *     content: Resource content (JSON-serializable)
 */
export interface McpResourceData {
  resource_uri: ResourceUri1;
  content: Content;
}
/**
 * Resource content (JSON-serializable)
 */
export interface Content {
  [k: string]: unknown;
}
/**
 * Application-level ack for WebSocket state-changing messages (ADR-16).
 */
export interface MessageAck {
  original_envelope_id: OriginalEnvelopeId;
  status: Status;
  error?: Error1;
}

/**
 * Task identifier
 */
export type TaskId = string;
/**
 * Optional specific version to retrieve
 */
export type Version = number | null;

/**
 * Request a state snapshot for a task.
 *
 * StateQuery requests the current or a specific version of a task's
 * state snapshot for inspection or restoration.
 *
 * Attributes:
 *     task_id: ID of the task to query state for
 *     version: Optional specific version number to retrieve
 */
export interface StateQuery {
  task_id: TaskId;
  version?: Version;
}

/**
 * Original request identifier
 */
export type RequestId = string;
/**
 * Whether tool call succeeded
 */
export type Success = boolean;
/**
 * Result data (if successful)
 */
export type Result = {
  [k: string]: unknown;
} | null;
/**
 * Error message (if failed)
 */
export type Error = string | null;

/**
 * Result of an MCP tool call.
 *
 * McpToolResult provides the outcome of an MCP tool invocation,
 * including success status, result data, or error information.
 *
 * Attributes:
 *     request_id: ID of the original tool call request
 *     success: Whether the tool call succeeded
 *     result: Optional result data (if successful)
 *     error: Optional error message (if failed)
 */
export interface McpToolResult {
  request_id: RequestId;
  success: Success;
  result?: Result;
  error?: Error;
}

/**
 * Task identifier to cancel
 */
export type TaskId = string;
/**
 * Optional cancellation reason
 */
export type Reason = string | null;

/**
 * Request to cancel a running task.
 *
 * TaskCancel requests cancellation of a task that is currently executing.
 * The agent should attempt graceful cancellation and cleanup.
 *
 * Attributes:
 *     task_id: ID of the task to cancel
 *     reason: Optional reason for cancellation
 */
export interface TaskCancel {
  task_id: TaskId;
  reason?: Reason;
}

/**
 * Unique request identifier
 */
export type RequestId = string;
/**
 * MCP tool name to invoke
 */
export type ToolName = string;
/**
 * Optional MCP context (server, session, etc.)
 */
export type McpContext = {
  [k: string]: unknown;
} | null;

/**
 * Call an MCP tool.
 *
 * McpToolCall invokes a tool provided by an MCP server, enabling
 * agents to leverage external capabilities and integrations.
 *
 * Attributes:
 *     request_id: Unique identifier for this tool call request
 *     tool_name: Name of the MCP tool to invoke
 *     arguments: Arguments to pass to the tool (JSON-serializable)
 *     mcp_context: Optional MCP-specific context (server, session, etc.)
 */
export interface McpToolCall {
  request_id: RequestId;
  tool_name: ToolName;
  arguments: Arguments;
  mcp_context?: McpContext;
}
/**
 * Tool arguments (JSON-serializable)
 */
export interface Arguments {
  [k: string]: unknown;
}

/**
 * Task identifier
 */
export type TaskId = string;
/**
 * Final task status
 */
export type TaskStatus = "submitted" | "working" | "completed" | "failed" | "cancelled" | "input_required";
/**
 * Result data (summary, artifacts, etc.)
 */
export type Result = {
  [k: string]: unknown;
} | null;
/**
 * Final state snapshot
 */
export type FinalState = {
  [k: string]: unknown;
} | null;
/**
 * Execution duration in milliseconds
 */
export type DurationMs = number | null;
/**
 * Input token count
 */
export type TokensIn = number | null;
/**
 * Output token count
 */
export type TokensOut = number | null;
/**
 * Total tokens (fallback for tokens_out)
 */
export type TokensUsed = number | null;
/**
 * Number of API calls
 */
export type ApiCalls = number | null;

/**
 * Response to a task execution request.
 *
 * TaskResponse provides the final result of task execution, including
 * status, result data, final state snapshot, and execution metrics.
 *
 * Attributes:
 *     task_id: ID of the completed task
 *     status: Final task status (completed, failed, cancelled, etc.)
 *     result: Optional result data (summary, artifacts, etc.)
 *     final_state: Optional final state snapshot
 *     metrics: Optional execution metrics (duration, tokens used, etc.)
 */
export interface TaskResponse {
  task_id: TaskId;
  status: TaskStatus;
  result?: Result;
  final_state?: FinalState;
  /**
   * Execution metrics (duration, tokens, etc.)
   */
  metrics?: TaskMetrics | null;
}
/**
 * TaskResponse.metrics (extra allowed).
 */
export interface TaskMetrics {
  duration_ms?: DurationMs;
  tokens_in?: TokensIn;
  tokens_out?: TokensOut;
  tokens_used?: TokensUsed;
  api_calls?: ApiCalls;
}

/**
 * Task identifier
 */
export type TaskId = string;
/**
 * Update type (progress, input_required)
 */
export type UpdateType = "progress" | "input_required" | "status_change";
/**
 * Current task status
 */
export type TaskStatus = "submitted" | "working" | "completed" | "failed" | "cancelled" | "input_required";
/**
 * Progress info (percent, message, ETA)
 */
export type Progress = {
  [k: string]: unknown;
} | null;
/**
 * Request for additional input
 */
export type InputRequest = {
  [k: string]: unknown;
} | null;

/**
 * Update on task execution progress or status.
 *
 * TaskUpdate provides real-time updates during task execution, including
 * progress information or requests for additional input.
 *
 * Attributes:
 *     task_id: ID of the task being updated
 *     update_type: Type of update (progress, input_required, etc.)
 *     status: Current task status
 *     progress: Optional progress information (percent, message, ETA)
 *     input_request: Optional request for additional input from user
 */
export interface TaskUpdate {
  task_id: TaskId;
  update_type: UpdateType;
  status: TaskStatus;
  progress?: Progress;
  input_request?: InputRequest;
}

/**
 * Parent conversation ID
 */
export type ConversationId = string;
/**
 * Parent task ID for subtasks
 */
export type ParentTaskId = string | null;
/**
 * Skill identifier to execute
 */
export type SkillId = string;
/**
 * Maximum execution time in seconds
 */
export type TimeoutSeconds = number | null;
/**
 * Task priority (e.g., 'low', 'normal', 'high')
 */
export type Priority = string | null;
/**
 * Key for idempotent execution
 */
export type IdempotencyKey = string | null;
/**
 * Whether to stream progress updates
 */
export type Streaming = boolean | null;
/**
 * Whether to persist state snapshots
 */
export type PersistState = boolean | null;
/**
 * LLM model identifier
 */
export type Model = string | null;
/**
 * LLM temperature (0-2)
 */
export type Temperature = number | null;

/**
 * Request to execute a task on an agent.
 *
 * TaskRequest initiates task execution, specifying the skill to invoke,
 * input data, and optional configuration parameters.
 *
 * Attributes:
 *     conversation_id: ID of the conversation this task belongs to
 *     parent_task_id: Optional ID of parent task (for subtasks)
 *     skill_id: Identifier of the skill to execute
 *     input: Input data for the skill (JSON-serializable)
 *     config: Optional configuration (timeout, priority, streaming, etc.)
 */
export interface TaskRequest {
  conversation_id: ConversationId;
  parent_task_id?: ParentTaskId;
  skill_id: SkillId;
  input: Input;
  /**
   * Optional configuration (timeout, priority, streaming, etc.)
   */
  config?: TaskRequestConfig | null;
}
/**
 * Input data for the skill (skill-specific)
 */
export interface Input {
  [k: string]: unknown;
}
/**
 * TaskRequest.config (extra allowed).
 */
export interface TaskRequestConfig {
  timeout_seconds?: TimeoutSeconds;
  priority?: Priority;
  idempotency_key?: IdempotencyKey;
  streaming?: Streaming;
  persist_state?: PersistState;
  model?: Model;
  temperature?: Temperature;
}

/**
 * MCP resource URI
 */
export type ResourceUri = string;

/**
 * Data from an MCP resource.
 *
 * McpResourceData provides the content of a fetched MCP resource.
 *
 * Attributes:
 *     resource_uri: URI of the resource
 *     content: Resource content (JSON-serializable)
 */
export interface McpResourceData {
  resource_uri: ResourceUri;
  content: Content;
}
/**
 * Resource content (JSON-serializable)
 */
export interface Content {
  [k: string]: unknown;
}

/**
 * MCP resource URI to fetch
 */
export type ResourceUri = string;

/**
 * Request to fetch an MCP resource.
 *
 * McpResourceFetch requests retrieval of a resource from an MCP server,
 * such as documentation, data, or other content.
 *
 * Attributes:
 *     resource_uri: URI of the MCP resource to fetch
 */
export interface McpResourceFetch {
  resource_uri: ResourceUri;
}

/**
 * Artifact identifier
 */
export type ArtifactId = string;
/**
 * Parent task ID
 */
export type TaskId = string;
/**
 * Optional human-readable artifact name
 */
export type Name = string | null;

/**
 * Notify about artifact creation or availability.
 *
 * ArtifactNotify informs agents when a new artifact has been created
 * or is available for retrieval.
 *
 * Attributes:
 *     artifact_id: ID of the artifact
 *     task_id: ID of the task that produced the artifact
 *     name: Optional human-readable artifact name
 */
export interface ArtifactNotify {
  artifact_id: ArtifactId;
  task_id: TaskId;
  name?: Name;
}

/**
 * Parent task ID
 */
export type TaskId = string;
/**
 * Unique message identifier
 */
export type MessageId = string;
/**
 * Sender agent URN
 */
export type Sender = string;
/**
 * Message role (user, assistant, system)
 */
export type MessageRole = "user" | "assistant" | "system";
/**
 * Part IDs making up this message
 */
export type Parts = string[];

/**
 * Send a message within a task conversation.
 *
 * MessageSend exchanges conversation turns between agents during
 * task execution, containing message content as parts.
 *
 * Attributes:
 *     task_id: ID of the task this message belongs to
 *     message_id: Unique identifier for this message
 *     sender: Agent URN of the message sender
 *     role: Message role (user, assistant, system)
 *     parts: List of part IDs that make up this message
 */
export interface MessageSend {
  task_id: TaskId;
  message_id: MessageId;
  sender: Sender;
  role: MessageRole;
  parts: Parts;
}

/**
 * Task identifier
 */
export type TaskId = string;
/**
 * Snapshot ID to restore from
 */
export type SnapshotId = string;

/**
 * Restore a task to a previous state snapshot.
 *
 * StateRestore requests restoration of a task to a previously saved
 * state snapshot, enabling rollback and recovery scenarios.
 *
 * Attributes:
 *     task_id: ID of the task to restore
 *     snapshot_id: ID of the snapshot to restore from
 */
export interface StateRestore {
  task_id: TaskId;
  snapshot_id: SnapshotId;
}

/**
 * Part type discriminator
 */
export type Type = "data";
/**
 * Optional JSON Schema URI for validation
 */
export type SchemaUri = string | null;

/**
 * Structured JSON data part.
 *
 * DataPart represents structured data in JSON format, optionally
 * with a schema URI for validation.
 *
 * Attributes:
 *     type: Discriminator field, always "data"
 *     data: Arbitrary JSON-serializable data
 *     schema_uri: Optional URI to JSON Schema for validation
 *
 * Example:
 *     >>> part = DataPart(
 *     ...     type="data",
 *     ...     data={"query": "AI trends", "max_results": 10},
 *     ...     schema_uri="https://example.com/schemas/search.json"
 *     ... )
 */
export interface DataPart {
  type: Type;
  data: Data;
  schema_uri?: SchemaUri;
}
/**
 * Structured data (JSON-serializable)
 */
export interface Data {
  [k: string]: unknown;
}

/**
 * Part type discriminator
 */
export type Type = "text";
/**
 * Text content
 */
export type Content = string;

/**
 * Plain text content part.
 *
 * TextPart represents simple text content, such as user messages,
 * agent responses, or any textual information.
 *
 * Attributes:
 *     type: Discriminator field, always "text"
 *     content: The text content
 *
 * Example:
 *     >>> part = TextPart(
 *     ...     type="text",
 *     ...     content="Research Q3 market trends for AI infrastructure"
 *     ... )
 */
export interface TextPart {
  type: Type;
  content: Content;
}

/**
 * Part type discriminator
 */
export type Type = "resource";
/**
 * MCP resource URI
 */
export type ResourceUri = string;

/**
 * Reference to an MCP resource.
 *
 * ResourcePart represents a reference to a resource provided by
 * an MCP (Model Context Protocol) server, enabling integration
 * with external tools and data sources.
 *
 * Attributes:
 *     type: Discriminator field, always "resource"
 *     resource_uri: URI of the MCP resource
 *
 * Example:
 *     >>> part = ResourcePart(
 *     ...     type="resource",
 *     ...     resource_uri="mcp://tools.example.com/web/search_results"
 *     ... )
 */
export interface ResourcePart {
  type: Type;
  resource_uri: ResourceUri;
}

/**
 * Part type discriminator
 */
export type Type = "file";
/**
 * File URI (asap://, https://, data:; file:// and .. rejected)
 */
export type Uri = string;
/**
 * MIME type (e.g., application/pdf)
 */
export type MimeType = string;
/**
 * Optional base64-encoded inline file data
 */
export type InlineData = string | null;

/**
 * Binary or text file part.
 *
 * FilePart represents file content, either by reference (URI) or
 * inline (base64-encoded data). Includes MIME type for proper handling.
 *
 * Attributes:
 *     type: Discriminator field, always "file"
 *     uri: File URI (asap://, https://, or data:; file:// and path traversal rejected)
 *     mime_type: MIME type of the file (e.g., "application/pdf")
 *     inline_data: Optional base64-encoded inline file data
 *
 * Example:
 *     >>> part = FilePart(
 *     ...     type="file",
 *     ...     uri="asap://artifacts/task_123/report.pdf",
 *     ...     mime_type="application/pdf"
 *     ... )
 *     >>>
 *     >>> # With inline data
 *     >>> part_inline = FilePart(
 *     ...     type="file",
 *     ...     uri="data:text/plain;base64,SGVsbG8gV29ybGQ=",
 *     ...     mime_type="text/plain",
 *     ...     inline_data="SGVsbG8gV29ybGQ="
 *     ... )
 */
export interface FilePart {
  type: Type;
  uri: Uri;
  mime_type: MimeType;
  inline_data?: InlineData;
}

/**
 * Part type discriminator
 */
export type Type = "template";
/**
 * Template string with {{variable}} syntax
 */
export type Template = string;

/**
 * Parameterized prompt template.
 *
 * TemplatePart represents a template string with variable placeholders
 * (using {{variable}} syntax) and their corresponding values.
 *
 * Attributes:
 *     type: Discriminator field, always "template"
 *     template: Template string with {{variable}} placeholders
 *     variables: Dictionary mapping variable names to their values
 *
 * Example:
 *     >>> part = TemplatePart(
 *     ...     type="template",
 *     ...     template="Research {{topic}} for {{timeframe}}",
 *     ...     variables={"topic": "AI trends", "timeframe": "Q3 2025"}
 *     ... )
 */
export interface TemplatePart {
  type: Type;
  template: Template;
  variables: Variables;
}
/**
 * Variable name to value mapping
 */
export interface Variables {
  [k: string]: unknown;
}

/**
 * Unique snapshot identifier (ULID)
 */
export type Id = string;
/**
 * Parent task ID
 */
export type TaskId = string;
/**
 * Snapshot version number
 */
export type Version = number;
/**
 * Whether this is a significant checkpoint
 */
export type Checkpoint = boolean;
/**
 * Creation timestamp (UTC)
 */
export type CreatedAt = string;

/**
 * First-class state persistence mechanism.
 *
 * StateSnapshots enable task state to be saved and restored,
 * addressing a key limitation in other agent protocols. Supports
 * versioning and checkpoint flagging for important states.
 *
 * Attributes:
 *     id: Unique snapshot identifier (ULID format)
 *     task_id: ID of the task this snapshot belongs to
 *     version: Snapshot version number (auto-incremented)
 *     data: Arbitrary state data (JSON-serializable dict)
 *     checkpoint: Whether this is a significant checkpoint (default: False)
 *     created_at: When the snapshot was created (UTC)
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> snapshot = StateSnapshot(
 *     ...     id="snap_01HX5K7R...",
 *     ...     task_id="task_01HX5K4N...",
 *     ...     version=3,
 *     ...     data={"search_completed": True, "sources_analyzed": 15},
 *     ...     checkpoint=True,
 *     ...     created_at=datetime.now(timezone.utc)
 *     ... )
 */
export interface StateSnapshot {
  id: Id;
  task_id: TaskId;
  version: Version;
  data: Data;
  checkpoint?: Checkpoint;
  created_at: CreatedAt;
}
/**
 * State data (JSON-serializable)
 */
export interface Data {
  [k: string]: unknown;
}

/**
 * Unique artifact identifier (ULID)
 */
export type Id = string;
/**
 * Parent task ID
 */
export type TaskId = string;
/**
 * Human-readable artifact name
 */
export type Name = string;
/**
 * Part IDs making up this artifact
 */
export type Parts = string[];
/**
 * Creation timestamp (UTC)
 */
export type CreatedAt = string;

/**
 * Concrete output produced by task execution.
 *
 * Artifacts represent the tangible results of task completion,
 * such as reports, data files, or other generated content.
 *
 * Attributes:
 *     id: Unique artifact identifier (ULID format)
 *     task_id: ID of the task that produced this artifact
 *     name: Human-readable artifact name
 *     parts: List of part IDs that make up this artifact
 *     created_at: When the artifact was created (UTC)
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> artifact = Artifact(
 *     ...     id="art_01HX5K6Q...",
 *     ...     task_id="task_01HX5K4N...",
 *     ...     name="Q3 Market Analysis Report",
 *     ...     parts=["part_01HX5K..."],
 *     ...     created_at=datetime.now(timezone.utc)
 *     ... )
 */
export interface Artifact {
  id: Id;
  task_id: TaskId;
  name: Name;
  parts: Parts;
  created_at: CreatedAt;
}

/**
 * Unique conversation identifier (ULID)
 */
export type Id = string;
/**
 * Agent URNs in conversation
 *
 * @minItems 1
 */
export type Participants = [string, ...string[]];
/**
 * Creation timestamp (UTC)
 */
export type CreatedAt = string;
/**
 * Conversation purpose
 */
export type Purpose = string | null;
/**
 * Time-to-live in hours
 */
export type TtlHours = number | null;
/**
 * Source identifier
 */
export type Source = string | null;
/**
 * ISO timestamp
 */
export type Timestamp = string | null;
/**
 * Tags for categorization
 */
export type Tags = string[] | null;

/**
 * A context for related interactions between agents.
 *
 * Conversations enable shared context accumulation, task grouping,
 * and state isolation between unrelated work.
 *
 * Attributes:
 *     id: Unique conversation identifier (ULID format)
 *     participants: List of agent URNs participating in the conversation
 *     created_at: Timestamp when the conversation was created (UTC)
 *     metadata: Optional metadata (e.g., purpose, TTL, tags)
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> conversation = Conversation(
 *     ...     id="conv_01HX5K3MQVN8...",
 *     ...     participants=["urn:asap:agent:coordinator", "urn:asap:agent:research-v1"],
 *     ...     created_at=datetime.now(timezone.utc),
 *     ...     metadata={"purpose": "quarterly_report_research", "ttl_hours": 72}
 *     ... )
 */
export interface Conversation {
  id: Id;
  participants: Participants;
  created_at: CreatedAt;
  /**
   * Optional metadata (purpose, TTL, etc.)
   */
  metadata?: CommonMetadata | null;
}
/**
 * Common metadata keys (extra allowed).
 */
export interface CommonMetadata {
  purpose?: Purpose;
  ttl_hours?: TtlHours;
  source?: Source;
  timestamp?: Timestamp;
  tags?: Tags;
}

/**
 * Unique agent identifier (URN format)
 */
export type Id = string;
/**
 * URL to agent's manifest
 */
export type ManifestUri = string;
/**
 * Agent capability strings
 *
 * @minItems 1
 */
export type Capabilities = [string, ...string[]];

/**
 * An autonomous entity capable of sending and receiving ASAP messages.
 *
 * Agents are symmetric peers with no inherent client/server distinction.
 * Each agent has a unique identifier and publishes a manifest describing
 * its capabilities.
 *
 * Attributes:
 *     id: Unique agent identifier (URN format, e.g., "urn:asap:agent:research-v1")
 *     manifest_uri: URL where the agent's manifest can be retrieved
 *     capabilities: List of capability strings (e.g., ["task.execute", "mcp.tools"])
 *
 * Example:
 *     >>> agent = Agent(
 *     ...     id="urn:asap:agent:research-v1",
 *     ...     manifest_uri="https://agents.example.com/.well-known/asap/research-v1.json",
 *     ...     capabilities=["task.execute", "state.persist", "mcp.tools"]
 *     ... )
 */
export interface Agent {
  id: Id;
  manifest_uri: ManifestUri;
  capabilities: Capabilities;
}

/**
 * Unique message identifier (ULID)
 */
export type Id = string;
/**
 * Parent task ID
 */
export type TaskId = string;
/**
 * Sender agent URN
 */
export type Sender = string;
/**
 * Message role (user, assistant, system)
 */
export type MessageRole = "user" | "assistant" | "system";
/**
 * Part IDs or references
 */
export type Parts = string[];
/**
 * Message timestamp (UTC)
 */
export type Timestamp = string;

/**
 * A single communication turn containing one or more parts.
 *
 * Messages are the atomic units of communication within tasks,
 * containing content parts and metadata about the sender and role.
 *
 * Attributes:
 *     id: Unique message identifier (ULID format)
 *     task_id: ID of the task this message belongs to
 *     sender: Agent URN of the message sender
 *     role: Message role (user, assistant, system)
 *     parts: List of part IDs or part references
 *     timestamp: When the message was sent (UTC)
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> message = Message(
 *     ...     id="msg_01HX5K5P...",
 *     ...     task_id="task_01HX5K4N...",
 *     ...     sender="urn:asap:agent:coordinator",
 *     ...     role="user",
 *     ...     parts=["part_01HX5K...", "part_01HX5L..."],
 *     ...     timestamp=datetime.now(timezone.utc)
 *     ... )
 */
export interface Message {
  id: Id;
  task_id: TaskId;
  sender: Sender;
  role: MessageRole;
  parts: Parts;
  timestamp: Timestamp;
}

/**
 * Unique agent identifier (URN format)
 */
export type Id = string;
/**
 * Human-readable agent name
 */
export type Name = string;
/**
 * Semantic version (e.g., '1.0.0')
 */
export type Version = string;
/**
 * What the agent does
 */
export type Description = string;
/**
 * ASAP protocol version
 */
export type AsapVersion = string;
/**
 * Unique skill identifier
 */
export type Id1 = string;
/**
 * Human-readable skill description
 */
export type Description1 = string;
/**
 * JSON Schema for skill input validation
 */
export type InputSchema = {
  [k: string]: unknown;
} | null;
/**
 * JSON Schema for skill output validation
 */
export type OutputSchema = {
  [k: string]: unknown;
} | null;
/**
 * Available skills
 */
export type Skills = Skill[];
/**
 * Supports state snapshots
 */
export type StatePersistence = boolean;
/**
 * Supports streaming responses
 */
export type Streaming = boolean;
/**
 * Available MCP tools
 */
export type McpTools = string[];
/**
 * HTTP endpoint for ASAP messages
 */
export type Asap = string;
/**
 * WebSocket endpoint for streaming events
 */
export type Events = string | null;
/**
 * Supported authentication schemes
 */
export type Schemes = string[];
/**
 * OAuth2 configuration if oauth2 is in schemes
 */
export type Oauth2 = {
  [k: string]: unknown;
} | null;
/**
 * Cryptographic signature for verification
 */
export type Signature = string | null;
/**
 * Target uptime as percentage (e.g., '99.5%')
 */
export type Availability = string | null;
/**
 * Maximum p95 latency in milliseconds
 */
export type MaxLatencyP95Ms = number | null;
/**
 * Maximum error rate as percentage (e.g., '1%')
 */
export type MaxErrorRate = string | null;
/**
 * Support coverage (e.g., '24/7', 'business')
 */
export type SupportHours = string | null;
/**
 * Verification state (e.g., 'verified', 'pending')
 */
export type Status = string;
/**
 * ISO timestamp when verification was granted
 */
export type VerifiedAt = string;
/**
 * How long to consider agent alive without re-check (seconds)
 */
export type TtlSeconds = number;

/**
 * Self-describing metadata about an agent's capabilities.
 *
 * The manifest is analogous to A2A's Agent Card but extended with
 * additional ASAP-specific features. It provides all information
 * needed to interact with an agent.
 *
 * Attributes:
 *     id: Unique agent identifier (matches Agent.id)
 *     name: Human-readable agent name
 *     version: Semantic version of the agent
 *     description: Description of what the agent does
 *     capabilities: Detailed capability information
 *     endpoints: Network endpoints for communication
 *     auth: Optional authentication configuration
 *     signature: Optional cryptographic signature for manifest verification
 *     sla: Optional SLA guarantees (availability, latency, error rate)
 *     ttl_seconds: How long to consider agent alive without re-check (default 300)
 *
 * Example:
 *     >>> manifest = Manifest(
 *     ...     id="urn:asap:agent:research-v1",
 *     ...     name="Research Agent",
 *     ...     version="1.0.0",
 *     ...     description="Performs web research and summarization",
 *     ...     capabilities=Capability(
 *     ...         asap_version="0.1",
 *     ...         skills=[Skill(id="web_research", description="Research skill")],
 *     ...         state_persistence=True
 *     ...     ),
 *     ...     endpoints=Endpoint(asap="https://api.example.com/asap")
 *     ... )
 *     >>> # With SLA (optional):
 *     >>> manifest_with_sla = Manifest(
 *     ...     id="urn:asap:agent:research-v1",
 *     ...     name="Research Agent",
 *     ...     version="1.0.0",
 *     ...     description="Performs web research",
 *     ...     capabilities=Capability(
 *     ...         asap_version="0.1",
 *     ...         skills=[Skill(id="web_research", description="Research skill")],
 *     ...         state_persistence=True,
 *     ...     ),
 *     ...     endpoints=Endpoint(asap="https://api.example.com/asap"),
 *     ...     sla=SLADefinition(
 *     ...         availability="99.5%",
 *     ...         max_latency_p95_ms=500,
 *     ...         max_error_rate="1%",
 *     ...         support_hours="24/7",
 *     ...     ),
 *     ... )
 */
export interface Manifest {
  id: Id;
  name: Name;
  version: Version;
  description: Description;
  capabilities: Capability;
  endpoints: Endpoint;
  /**
   * Authentication configuration
   */
  auth?: AuthScheme | null;
  signature?: Signature;
  /**
   * SLA guarantees (availability, latency, error rate)
   */
  sla?: SLADefinition | null;
  /**
   * Verification status for marketplace trust badge (Task 3.6)
   */
  verification?: VerificationStatus | null;
  ttl_seconds?: TtlSeconds;
}
/**
 * Agent capabilities
 */
export interface Capability {
  asap_version?: AsapVersion;
  skills?: Skills;
  state_persistence?: StatePersistence;
  streaming?: Streaming;
  mcp_tools?: McpTools;
}
/**
 * A specific capability that an agent can perform.
 *
 * Skills define what an agent can do, along with the expected input
 * and output schemas for validation.
 *
 * Attributes:
 *     id: Unique identifier for the skill (e.g., "web_research")
 *     description: Human-readable description of what the skill does
 *     input_schema: Optional JSON Schema for validating skill inputs
 *     output_schema: Optional JSON Schema for validating skill outputs
 *
 * Example:
 *     >>> skill = Skill(
 *     ...     id="web_research",
 *     ...     description="Search and synthesize information from the web",
 *     ...     input_schema={"type": "object", "properties": {"query": {"type": "string"}}},
 *     ...     output_schema={"type": "object", "properties": {"summary": {"type": "string"}}}
 *     ... )
 */
export interface Skill {
  id: Id1;
  description: Description1;
  input_schema?: InputSchema;
  output_schema?: OutputSchema;
}
/**
 * Communication endpoints
 */
export interface Endpoint {
  asap: Asap;
  events?: Events;
}
/**
 * Authentication configuration for agent access.
 *
 * Defines the authentication methods supported by an agent and
 * optional OAuth2 configuration.
 *
 * Attributes:
 *     schemes: List of supported auth schemes (e.g., ["bearer", "oauth2"])
 *     oauth2: Optional OAuth2 configuration with URLs and scopes
 *
 * Example:
 *     >>> auth = AuthScheme(
 *     ...     schemes=["bearer", "oauth2"],
 *     ...     oauth2={
 *     ...         "authorization_url": "https://auth.example.com/authorize",
 *     ...         "token_url": "https://auth.example.com/token",
 *     ...         "scopes": ["asap:execute", "asap:read"]
 *     ...     }
 *     ... )
 */
export interface AuthScheme {
  schemes: Schemes;
  oauth2?: Oauth2;
}
/**
 * Service level agreement guarantees published by an agent.
 *
 * SLAs define availability, latency, error rate, and support hours.
 * Used as trust signals in the marketplace (v2.0) and for breach detection.
 *
 * Attributes:
 *     availability: Target uptime as percentage string (e.g., "99.5%").
 *     max_latency_p95_ms: Maximum 95th percentile latency in milliseconds.
 *     max_error_rate: Maximum acceptable error rate as percentage string (e.g., "1%").
 *     support_hours: Support coverage (e.g., "24/7", "business").
 *
 * Example:
 *     >>> sla = SLADefinition(
 *     ...     availability="99.5%",
 *     ...     max_latency_p95_ms=500,
 *     ...     max_error_rate="1%",
 *     ...     support_hours="24/7"
 *     ... )
 */
export interface SLADefinition {
  availability?: Availability;
  max_latency_p95_ms?: MaxLatencyP95Ms;
  max_error_rate?: MaxErrorRate;
  support_hours?: SupportHours;
}
/**
 * Verification status for marketplace trust badge (Task 3.6).
 *
 * When status is 'verified', the agent displays a Verified badge in the
 * registry UI. Admins add this after manual review of verification requests.
 *
 * Attributes:
 *     status: Verification state (e.g., 'verified', 'pending', 'rejected').
 *     verified_at: ISO timestamp when verification was granted (if status is 'verified').
 */
export interface VerificationStatus {
  status: Status;
  verified_at: VerifiedAt;
}

/**
 * Unique task identifier (ULID)
 */
export type Id = string;
/**
 * Parent conversation ID
 */
export type ConversationId = string;
/**
 * Parent task ID for subtasks
 */
export type ParentTaskId = string | null;
/**
 * Task status (submitted, working, etc.)
 */
export type TaskStatus = "submitted" | "working" | "completed" | "failed" | "cancelled" | "input_required";
/**
 * Nesting depth for subtasks (0 = root); prevents infinite recursion
 */
export type Depth = number;
/**
 * Progress info (percent, message, ETA)
 */
export type Progress = {
  [k: string]: unknown;
} | null;
/**
 * Creation timestamp (UTC)
 */
export type CreatedAt = string;
/**
 * Last update timestamp (UTC)
 */
export type UpdatedAt = string;

/**
 * The fundamental unit of work in ASAP.
 *
 * Tasks are uniquely identified, stateful with a defined lifecycle,
 * cancellable, resumable, and capable of producing artifacts.
 *
 * Attributes:
 *     id: Unique task identifier (ULID format)
 *     conversation_id: ID of the conversation this task belongs to
 *     parent_task_id: Optional ID of parent task (for subtasks)
 *     status: Current task status (submitted, working, completed, etc.)
 *     depth: Nesting depth (0 = root); must be â‰¤ MAX_TASK_DEPTH to prevent infinite recursion
 *     progress: Optional progress information (percent, message, ETA)
 *     created_at: Timestamp when the task was created (UTC)
 *     updated_at: Timestamp of last status update (UTC)
 *
 * Example:
 *     >>> from datetime import datetime, timezone
 *     >>> task = Task(
 *     ...     id="task_01HX5K4N...",
 *     ...     conversation_id="conv_01HX5K3MQVN8...",
 *     ...     status="working",
 *     ...     progress={"percent": 45, "message": "Analyzing search results..."},
 *     ...     created_at=datetime.now(timezone.utc),
 *     ...     updated_at=datetime.now(timezone.utc)
 *     ... )
 */
export interface Task {
  id: Id;
  conversation_id: ConversationId;
  parent_task_id?: ParentTaskId;
  status: TaskStatus;
  depth?: Depth;
  progress?: Progress;
  created_at: CreatedAt;
  updated_at: UpdatedAt;
}

