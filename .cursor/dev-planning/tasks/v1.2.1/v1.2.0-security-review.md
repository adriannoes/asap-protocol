# Security Review: v1.2.0

**Date:** 2026-02-15
**Target:** ASAP Protocol v1.2.0 Codebase
**Reviewer:** Gemini 3.0 Pro

## Executive Summary

A comprehensive security review of the v1.2.0 codebase was conducted. A **HIGH SEVERITY** vulnerability was identified in the JWT validation logic where token expiration is not verified, allowing expired tokens to be accepted. Several other findings regarding configuration security and potential SSRF risks were also noted.


---

# Part 2: Deep-Dive Codebase Review

## 1. Executive Summary

| Metric | Assessment |
| :--- | :--- |
| **Architecture** | ⚠️ Risky (SQLite Sync Bridge) |
| **Test Coverage** | ✅ Solid (High coverage, gaps closed) |
| **Blocking Issues** | 0 Critical Bugs (1 High Security found in Part 1) |

## 2. Architecture & Stack Violations (Critical)

### Inefficient Sync/Async Bridging
* **File:** `src/asap/state/stores/sqlite.py:23`
* **Rule Broken:** "Performance: Avoid heavy object creation in hot paths"
* **Context:** The `_run_sync` helper creates a new `ThreadPoolExecutor` and `EventLoop` for *every single database operation* when called from an async context. This is a massive performance bottleneck for high-throughput agents.
* **Required Fix:**

```python
# [Bad Code]
def _run_sync(coro: Any) -> Any:
    # ...
    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as pool:
        future = pool.submit(asyncio.run, coro)
        return future.result()

# [Corrected Code]
# Use a global executor or asyncio.to_thread (if running in async context)
# Ideally, evolve SnapshotStore to be Async (refer to tech-stack-decisions.md)
```

## 3. Red Team Findings (Bugs & Logic)

### WebSocket Error Swallowing
- **Location:** `src/asap/transport/websocket.py:427`
- **Attack Vector/Risk:** The `_recv_loop` catches generic `Exception`, logs a warning, and exits. While `_run_loop` detects the task completion, it doesn't know *why* it failed. If the error is a `SystemExit` or keyboard interrupt, it might be swallowed.
- **Fix Suggestion:** Reraise critical exceptions or set a "needs_restart" flag explicitly.

### Auth Custom Claim Default Mismatch
- **Location:** `src/asap/auth/middleware.py:37`
- **Issue:** Code defaults to `https://github.com/adriannoes/...` but `tech-stack-decisions.md` suggests `https://asap.ai/agent_id`.
- **Impact:** Confusion for implementers expecting the documentation's example to work out-of-the-box.

## 4. QA & Test Health

*   **Coverage**: Excellent mapping between `src/` and `tests/`.
*   **Fixture Hygiene**: Good usage of `tests/conftest.py`. `_isolate_rate_limiter` correctly patches the global state for isolation.
*   **Verification Command**: `uv run pytest tests/ -v`

## 5. Refactoring & Nitpicks

*   **Loose Typing**: `src/asap/models/*.py` uses `dict[str, Any]` extensively. While necessary for dynamic payloads, consider using `pydantic.Json` or specific TypedDicts where possible to tighten validation.

*   **Severity**: **HIGH**
*   **Category**: Authentication Bypass
*   **Description**: The `validate_jwt` function in `src/asap/auth/jwks.py` uses `joserfc.jwt.decode` without explicitly validating the `exp` (expiration) claim. The function docstring explicitly states it "Does not check exp", but the `BearerTokenValidator` and `AuthenticationMiddleware` rely on this function for security, assuming valid tokens. There is no downstream check for expiration in the core middleware.
*   **Exploit Scenario**: An attacker with a valid but expired token (e.g., a stolen token from a previous session) can continue to use it indefinitely to access the API. This bypasses the key rotation and short-lived token security model.
*   **Proof of Concept**: A reproduction script `reproduce_jwt_exp.py` confirmed that a token signed with an expiration time in the past is accepted as valid by `validate_jwt`.
*   **Recommendation**: 
    1.  Update `validate_jwt` to enforce `exp` validation by passing `claims={"exp": ...}` or using `validate_claims` from `joserfc`.
    2.  Alternatively, manually check `claims["exp"] > time.time()` immediately after decoding.
    3.  Add a test case in `tests/auth/test_jwks.py` that specifically asserts that expired tokens raise a `JoseError` or `ExpiredTokenError`.

# Vuln 2: Potential Command Injection via MCP Configuration: `src/asap/mcp/client.py:111`

*   **Severity**: **LOW** (Configuration dependent)
*   **Category**: Command Injection
*   **Description**: The `MCPClient` takes a `server_command` list and passes it directly to `asyncio.create_subprocess_exec`. While `exec` is safer than `shell=True`, if the `server_command` is derived from untrusted input (e.g., a user-controlled config file or API parameter), it could allow an attacker to execute arbitrary binaries.
*   **Exploit Scenario**: An attacker gains control of the configuration file and changes the `server_command` to `/bin/bash -c "rm -rf /"`.
*   **Recommendation**: 
    1.  Validate `server_command` against a allowlist of known safe binaries if possible.
    2.  Document clearly that `server_command` must come from a trusted source.
    3.  Consider running subprocesses in a restricted capability environment (sandbox).

# Vuln 3: Potential SSRF in OIDC Discovery: `src/asap/auth/oidc.py:120`

*   **Severity**: **LOW** (Configuration dependent)
*   **Category**: Server-Side Request Forgery (SSRF)
*   **Description**: `OIDCDiscovery` fetches configuration from a constructed URL based on `issuer_url`. If `issuer_url` is attacker-controlled, the server can be made to send HTTP requests to internal network resources.
*   **Exploit Scenario**: An attacker configures the agent to use an OIDC provider at `http://localhost:8080` (or an internal metadata service), causing the agent to scan internal ports or retrieve sensitive metadata.
*   **Recommendation**:
    1.  Implement a validator for `issuer_url` that blocks private/internal IP ranges (0.0.0.0, 127.0.0.1, 10.x.x.x, etc.) unless explicitly allowed by configuration.
    2.  Use a strict allowlist of trusted OIDC providers if feasible.

## Positive Findings

*   **Logging Security**: `src/asap/observability/logging.py` implements robust redaction for sensitive keys like `password`, `token`, `secret`.
*   **Crypto standards**: Use of `Ed25519` for signing uses standard cryptography libraries and JCS canonicalization correctly.
*   **Limit Checking**: Infinite headers or body checks are in place (e.g., `SizeLimitMiddleware`).

## Conclusion

The codebase is generally well-structured, but the **JWT Expiration Bypass** is a critical issue that requires immediate attention in a patch release (v1.2.1).

# Test Coverage Review

## Coverage Analysis

*   **Overall Coverage**: **94.12%** (5105 / 5423 lines covered).
*   **High Coverage Areas**: `asap.models`, `asap.crypto`, `asap.schemas` all have **100%** coverage, indicating strong data validation and core logic stability.
*   **Low Coverage Areas**:
    *   **`src/asap/transport/websocket.py` (82.11%)**:
        *   **Missing Lines**: 249-253 (Race condition during close), 890-919 (Error handling in message loop).
        *   **Risk**: High. The error handling logic during message processing is largely untested, which could lead to zombie connections or undefined behavior during runtime exceptions.
    *   **`src/asap/auth/introspection.py` (87.27%)**:
        *   **Missing Lines**: 151-154 (Cache eviction), 190-191 (Exception handling for `exp`).
        *   **Risk**: Medium. Cache eviction logic is untested, which could execute incorrectly under load.

## Quality Assessment

*   **Structure**: Tests generally follow `arrange-act-assert`.
*   **Independence**: High usage of `pytest-asyncio` fixtures ensures test isolation.
*   **Mocking**: Extensive use of `httpx.MockTransport` is excellent for deterministic networking tests (seen in `test_jwks.py`, `test_oidc.py`).

## Missing Scenarios

1.  **WebSocket Error Handling**:
    *   Scenario: `ASAPRequestHandler.handle_message` raises an unexpected exception.
    *   Expected: WebSocket sends a valid JSON-RPC error frame (-32603) and does NOT close the connection.
    *   Status: **Uncovered** (lines 890-919).
2.  **Introspection Cache Eviction**:
    *   Scenario: `TokenIntrospector` cache exceeds `max_cache_size`.
    *   Expected: Oldest entries are removed (LRU behavior).
    *   Status: **Uncovered** (lines 151-154).
3.  **SSL/TLS Connection initialization**:
    *   Scenario: Connect with `ssl_context`.
    *   Status: **Uncovered** (line 243).

## Recommendations

1.  **Add Error Injection Tests for WebSocket**: Create a test where the handler mock raises `Exception("Boom")` and assert that the client receives the correct error frame.
2.  **Test Cache Eviction**: Initialize `TokenIntrospector` with `max_cache_size=2`, introspect 3 different tokens, and verify size remains 2.
3.  **Automate Coverage Check**: Enforce a minimum coverage threshold (e.g., 90%) in CI to prevent regression.
